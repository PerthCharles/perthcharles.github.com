<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天赋，无与伦比的坚持]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://perthcharles.github.com/"/>
  <updated>2014-12-01T13:07:07.755Z</updated>
  <id>http://perthcharles.github.com/</id>
  
  <author>
    <name><![CDATA[Perth Charles]]></name>
    <email><![CDATA[zhongbincharles@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(9): TCP Memory Management]]></title>
    <link href="http://perthcharles.github.com/2014/11/28/tcp-design-and-implementation-9/"/>
    <id>http://perthcharles.github.com/2014/11/28/tcp-design-and-implementation-9/</id>
    <published>2014-11-28T09:13:03.000Z</published>
    <updated>2014-11-28T13:42:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h3 id="TODO">TODO</h3>
<ol>
<li>sk-&gt;forward_alloc的真实含义？  </li>
<li>sk_wmem_schedule 和 sk_rmem_schedule的用途？<br> Note: 书中有提到tcp_mem_schedule是一个forward allocation of memory的相关函数。<br> 所以sk_wmem_schedule这些是不是也有可能是一样的？  </li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h3 id="TODO">TODO</h3>
<ol>
<li>sk-&gt;forward_alloc的真实含义？  </li>
<li>sk_wmem_schedule 和 sk_rmem_schedule的用途？<br> Note: 书中有提到tcp_mem_s]]>
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(8): TCP receive]]></title>
    <link href="http://perthcharles.github.com/2014/11/20/tcp-design-and-implementation-8/"/>
    <id>http://perthcharles.github.com/2014/11/20/tcp-design-and-implementation-8/</id>
    <published>2014-11-20T08:17:45.000Z</published>
    <updated>2014-11-27T14:18:37.000Z</updated>
    <content type="html"><![CDATA[<p>这章主要是TCP接收包得处理流程。<br>kernel对于TCP包得处理大致可以分为两类：  </p>
<ol>
<li>如果处理in-sequence的包时，application正阻塞在read操作中，则接收到的数据包的数据会被直接拷贝到user buffer。  </li>
<li>否则，in-sequence包会被放在receive queue中，out-of-order包会房子啊out-of-order queue中。  </li>
</ol>
<a id="more"></a>  

<p>8.1 Queuing mechanism<br>处理收到的TCP时，涉及到三个queue：backlog queue, prequeue, 和receive queue。<br>注：prequeue好像已经是一个过气的概念了。  </p>
<pre><code><span class="number">1</span>. receive queue 包含的都是处理过的包，也就是说所有的协议头都被解析完了，  
   里面的数据就等着被复制到<span class="literal">user</span> space了。  
</code></pre><p>TCP层处理数据包的第一个函数是tcp_v4_rcv()，首先从这个函数开始理解整个流程。  </p>
<pre><code>tcp_v4_rcv()  <span class="comment">// net/ipv4/tcp_ipv4.c  </span>
    =&gt; sk = __inet_lookup_skb()  <span class="comment">// 找到skb属于的sock结构体  </span>
    =&gt; <span class="keyword">if</span> (!sock_owned_by_user(sk))  <span class="comment">// sock未被加锁  </span>
        =&gt; <span class="keyword">if</span> (!tcp_prequeue(sk, skb))  <span class="comment">// 如果符合加入prequeue的原则，则加入prequeue，返回true;反之返回false  </span>
            =&gt; ret = tcp_v4_do_rcv(sk, skb)  
                =&gt; tcp_rcv_established()  <span class="comment">// receive function for the ESTABLISHED state  </span>
                    =&gt; <span class="keyword">if</span> (len == tcp_header_len)  <span class="comment">// 如果是纯ack包</span>
                        =&gt; tcp_ack(sk, skb, <span class="number">0</span>)  <span class="comment">// dealing with incoming acks  </span>
                            =&gt; flag |= tcp_clean_rtx_queue()  <span class="comment">// see if we can take anything off of the retransmit queue  </span>
                            =&gt; <span class="keyword">if</span> (tcp_ack_is_dubious(sk, flag)  <span class="comment">// 判断时候出现可疑情况，具体看下代码吧。  </span>
                                =&gt; tcp_fastretrans_alert()  <span class="comment">// 进入快速重传  </span>
                                    =&gt; tcp_cwnd_down()  <span class="comment">// decrease cwnd each second ack, 该函数就是快速重传对cwnd操作的关键函数  </span>
                                    =&gt; tcp_xmit_retransmit_queue(sk)  <span class="comment">// 在重传阶段，该函数负责找到合适的数据进行重传  </span>
                        =&gt; __kfree_skb(skb)  <span class="comment">// free an sk_buff  </span>
                        =&gt; tcp_data_snd_check(sk)  <span class="comment">// 如果有数据需要发送，则发送数据到对端  </span>
                            =&gt; tcp_push_pending_frames(sk)   <span class="comment">// 发送pending的数据</span>
                                =&gt; tcp_write_xmit()  <span class="comment">// writes packets to the network， 这部分在上一章已经分析过了   </span>
                            =&gt; tcp_check_space(sk)  <span class="comment">//  如果有内存释放，则唤醒等待内存的队列  </span>
                                <span class="comment">/* when incoming ACK allows to free some skb from write_queue,  
                                 * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket  
                                 * on the exit from tcp input hander.
                                 *  
                                 * PROBLEM: sndbuf expansion does not work well with largesend. 
                                 */</span>
                                =&gt; tcp_new_space(sk)  
                                    =&gt; sk<span class="variable">-&gt;sk_sndbuf</span> = min(sndmem, sysctl_tcp_wmem[<span class="number">2</span>])  <span class="comment">// expand the sndbuf if possible  </span>
                    =&gt; <span class="keyword">else</span> <span class="comment">// 如果是带数据的包  </span>
                        <span class="comment">/* 此数据包刚好是下一个读取的数据，并且用户空间可存放下该数据包 */</span>
                        =&gt; <span class="keyword">if</span> (tp<span class="variable">-&gt;copied_seq</span> == tp<span class="variable">-&gt;rcv_nxt</span> &amp;&amp; len - tcp_header_len &lt;= tp<span class="variable">-&gt;ucopy</span>.len)  
                            <span class="comment">/* 如果函数在进程上下文调用并且sock被用户占用的话 */</span>
                            =&gt; <span class="keyword">if</span> (tp<span class="variable">-&gt;ucopy</span>.task == current &amp;&amp; sock_owned_by_user(sk) &amp;&amp; !copied_early)  
                                =&gt; tcp_copy_to_iovec()  <span class="comment">// 直接copy 到用户空间  </span>
                        =&gt; <span class="keyword">if</span> (!eaten)  <span class="comment">// 没有直接读到用户空间  </span>
                            <span class="comment">/* 当truesize大于sk_forward_alloc时，表示已分配的限额已经用完，不能直接放到receive queue中, 此时往往要重新计算sk_forward_alloc */</span>
                            =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;truesize</span> &gt; sk<span class="variable">-&gt;sk_forward_alloc</span>) <span class="keyword">goto</span> step5  
                            =&gt; eaten = tcp_queue_rcv()  
                                =&gt; tcp_try_coalesce()  <span class="comment">// try merge skb to prior one  </span>
                                =&gt; <span class="keyword">if</span> (!eaten) __skb_queue_tail()  <span class="comment">// 如果上一步未成功，则将skb放入receive queue中  </span>
                        =&gt; tcp_event_data_recv(sk, skb)  <span class="comment">// 数据包接收后续处理  </span>
                            <span class="comment">/* 每次收到超过128字节的数据报后，需要调用tcp_grow_window增加rcv_ssthresh的值 */</span>
                            =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;len</span> &gt;= <span class="number">128</span>) tcp_grow_window(sk, skb) 
                        =&gt; __tcp_ack_snd_check(sk, <span class="number">0</span>) <span class="comment">// check if sending an ack is needed  </span>

                    =&gt; tcp_validate_incoming(sk, skb, th, <span class="number">1</span>)  <span class="comment">// standard slow path, [details ignored]  </span>
                    =&gt; tcp_data_queue(sk, skb)  <span class="comment">// 对数据包进行处理  </span>
                        =&gt; <span class="keyword">if</span> (TCP_SKB_CB(skb)<span class="variable">-&gt;seq</span> == tp<span class="variable">-&gt;rcv_nxt</span>)   <span class="comment">// 如果是待接收的报文  </span>
                            =&gt; <span class="keyword">if</span> (tcp_receive_window(tp) == <span class="number">0</span>) <span class="keyword">goto</span> out_of_window;  <span class="comment">// 如果超出rwnd，则直接丢掉  </span>
                            =&gt; 如果正在读，且正是要读的数据，那么直接拷贝到用户空间  
                            =&gt; <span class="keyword">else</span> eaten = tcp_queue_rcv()  <span class="comment">// 将数据放入receive queue中  </span>
                            =&gt; <span class="keyword">if</span> (!skb_queue_empty(&amp;tp<span class="variable">-&gt;out_of_order_queue</span>))  <span class="comment">// 如果out of ordre queue不为空  </span>
                                =&gt; tcp_ofo_queue(sk)  <span class="comment">// This one checks to see if we can put data from the out-of-order queue into the receive-queue  </span>
                            =&gt; tcp_fast_path_check(sk)  <span class="comment">// 检查是否可以从slowpath回到fastpath  </span>

                        =&gt; <span class="keyword">else</span> tcp_data_queue_ofo(sk, skb)  <span class="comment">// 将数据包放到out-of-order queue中  </span>
                    =&gt; tcp_data_snd_check(sk)  <span class="comment">// 如果有数据需要发送，则发送数据到对端  </span>
                    =&gt; tcp_ack_snd_check(sk)  <span class="comment">// 判断是否有必要发送一个ack  </span>
</code></pre><hr>
<h4 id="prequeue的作用">prequeue的作用</h4>
<p>首先来理解两个相关的参数。    </p>
<ol>
<li><p>sysctl_tcp_low_latency == /proc/sys/net/ipv4/tcp_low_latency<br>通过man 7 tcp可以看到官方的解释  </p>
<p> tcp_low_latency (Boolean; default: disabled)  </p>
<pre><code> <span class="keyword">If</span> enabled, the  TCP  stack makes decisions that prefer lower
 latency <span class="keyword">as</span> opposed <span class="keyword">to</span> higher throughput.   It  this  <span class="keyword">option</span>  <span class="keyword">is</span>
 disabled,  <span class="keyword">then</span>  higher throughput <span class="keyword">is</span> preferred.  An example <span class="keyword">of</span>
 an application <span class="keyword">where</span> this <span class="keyword">default</span> should be changed would be  a
 Beowulf compute cluster.
</code></pre></li>
</ol>
<ol>
<li>tcp_sock-&gt;ucopy.task<br>ucopy.task != NULL 表示进程空间有进程在等待sock的数据到来  </li>
</ol>
<p>下面这句话是tcp_prequeue()的一个关键判断：是否将该skb放到prequeue中。  </p>
<pre><code><span class="keyword">if</span> (sysctl_tcp_low_latency || !tp-&gt;ucopy.task) <span class="keyword">return</span> <span class="keyword">false</span>;  
</code></pre><p>首先字面理解这行代码就是说:<br>如果更关心low latency则不用prequeue;<br>如果当前用进程在等待读数据，则不用prequeue.  </p>
<p>根据目前的理解，我认为prequeue有如下几方面的作用：  </p>
<pre><code>1. 进prequeue处理会更侧重throughput。
    由于软中断每次处理一个包，如果不进prequeue，而调用<span class="function">tcp_v4_do_rcv</span>()放进receive queue的话，  
    工作量会不少(<span class="function">tcp_rcv_established</span>()函数很复杂的)。  
    为了软中断更快的完成，放进prequeue后软中断就直接返回了，从而能更多地处理更多地收包。  
    具体处理prequeue中数据的任务交给了进程上下文(即tcp_recvmsg调用中)去处理了。   
    注：其实最终prequeue中的skb还是调用<span class="function">tcp_v4_do_rcv</span>()来处理的，所以放在prequeue中只是选择不同的处理skb的时机罢了。  
2. 进prequeue能够更快速的唤醒blocking状态的数据读请求。  
    这点很显然，进入prequeue的话，一般会立即wake up等待的进程。
</code></pre><hr>
<p>fastpath VS slowpath<br>这是一个看代码才了解到的概念，目前理解还不是太透彻，只是通过注释和代码初步知道了一些判断是否进入fast path的原则。区分这两类path的具体原因还没理解，等之后理解了再来补充吧。<br>目前的猜测可能是说满足fast path条件的话能省去许多判断的工作。暂时就简单列下tcp_rcv_established函数前面的一些注释吧：  </p>
<pre><code>The fast path <span class="keyword">is</span> disabled <span class="keyword">when</span>:  
- A zero window was announced from us - zero window probing  
  <span class="keyword">is</span> only handled properly <span class="keyword">in</span> the slow path.  
- <span class="keyword">Out</span> <span class="keyword">of</span> order segments arrived.  
- Urgent data <span class="keyword">is</span> expected.  
- There <span class="keyword">is</span> no <span class="keyword">buffer</span> space left.  
- Unexpected TCP flags/window value/header lenghts are received  
  (detected by checking the TCP header against pred_flags)  
- Data <span class="keyword">is</span> sent <span class="keyword">in</span> both directions. Fast path only supports <span class="keyword">pure</span> senders  
  <span class="keyword">or</span> <span class="keyword">pure</span> receivers (this means either the <span class="keyword">sequence</span> number <span class="keyword">or</span> the ack  
  value must stay <span class="keyword">constant</span>)  
- Unexpected TCP option.  

Fast processing <span class="keyword">is</span> turned <span class="keyword">on</span> <span class="keyword">in</span> tcp_data_queue <span class="keyword">when</span> everything <span class="keyword">is</span> OK.  
</code></pre><hr>
<h3 id="Processing_of_Queues">Processing of Queues</h3>
<p>TCP的接收队列的处理主要是在tcp_recvmsg()函数中，所以先从这个函数入手。<br>CSDN的<a href="http://blog.csdn.net/mrpre/article/details/33347221" target="_blank" rel="external">这篇博客</a>是一个不错的参考，不过一切还请以代码为准。  </p>
<pre><code>tcp_recvmsg()  <span class="regexp">//</span> <span class="keyword">this</span> routine copies from a sock struct into the user buffer<span class="function">  
    =&gt;</span> lock_sock(sk)  <span class="regexp">//</span> become a socket user<span class="function">  
    =&gt;</span> skb_queue_walk()  <span class="regexp">//</span> get a skb<span class="function">  

    =&gt;</span> 如果有skb可供拷贝<span class="function">  
        =&gt;</span> err = skb_copy_datagram_iovec()  <span class="regexp">//</span> copy data into iovec <span class="keyword">if</span> found_ok_skb  
        /* This <span class="reserved">function</span> should be called every time data <span class="keyword">is</span> copied to user space.  
         * It calculates the appropriate TCP receive buffer space.  
         */<span class="function">  
        =&gt;</span> tcp_rcv_space_adjust<span class="function"><span class="params">(sk)</span>  
            =&gt;</span> 调整至少每隔一个RTT才进行一次<span class="function">  
            =&gt;</span> space = <span class="number">2</span> * (tp-&gt;copied_seq - tp-&gt;rcvq_space.seq)  <span class="regexp">//</span> 一个RTT内，接收并复制到用户空间的数量的<span class="number">2</span>倍  
            ...<span class="function">  
            =&gt;</span> sk-&gt;sk_rcvbuf = space  <span class="regexp">//</span> 调整接收缓冲区的大小<span class="function">  
        =&gt;</span> sk_eat_skb(sk, skb, copied_early)  <span class="regexp">//</span> 如果一个skb内数据被拷贝完了，则释放掉该skb<span class="function">  

    =&gt;</span> 如果没有skb可供拷贝  
        <span class="regexp">/* 如果设置了MSG_WAITALL，target == len; 否则target == 1 */</span><span class="function">
        =&gt;</span> <span class="keyword">if</span> (copied &gt;= target &amp;&amp; !sk-&gt;sk_backlog.tail) <span class="keyword">break</span>;  <span class="regexp">//</span> 如果读够了target，且backlog queue 为空则直接<span class="keyword">return</span><span class="function">  

        =&gt;</span> tcp_cleanup_rbuf(sk, copied)  
            <span class="regexp">/* 注意区分这个函数与sk_eat_skb()  后者是清掉某个skb及其内存, 前者的主要功能是发送一个接收窗口更新的ACK--因为用户进程消费了读缓存中的数据 */</span><span class="function">
            =&gt;</span> <span class="keyword">if</span> <span class="function"><span class="params">(inet_csk_ack_scheduled(sk))</span>  // <span class="title">if</span> <span class="title">the</span> <span class="title">ack</span> <span class="title">is</span> <span class="title">scheduled</span> <span class="title">by</span> <span class="title">calling</span> <span class="title">tcp_ack_scheduled</span><span class="params">()</span>  
                =&gt;</span> <span class="keyword">if</span> delayed ACK was blocked <span class="keyword">by</span> socket lock, send an ACK<span class="function">  
                =&gt;</span> <span class="keyword">if</span> we have <span class="keyword">not</span> ACKed data <span class="keyword">of</span> length &gt; <span class="number">1</span>mss, send an ACK<span class="function">  
                =&gt;</span> <span class="keyword">if</span> we have emptied the receive buffer, <span class="keyword">and</span> there <span class="keyword">is</span> data flow only <span class="keyword">in</span> one direction, send an ACK<span class="function">  
            =&gt;</span> rcv_window_now = tcp_receive_window(tp)  <span class="regexp">//</span> 计算当前的应该通知对方的receive <span class="built_in">window</span><span class="function">
                =&gt;</span> win = tp-&gt;rcv_wup + tp-&gt;rcv_wnd - tp-&gt;rcv_nxt  <span class="regexp">//</span> 左边界 + 当前receive_window - 已用<span class="function">  
            =&gt;</span> new_window = __tcp_select_window(sk)  <span class="regexp">//</span> 计算新的接收窗口大小, 约为rcvbuf空闲部分的一半<span class="function">  
            =&gt;</span> <span class="keyword">if</span> (new_window &amp;&amp; new_window &gt;= <span class="number">2</span> * rcv_window_now)  send an ACK<span class="function">  

            =&gt;</span> <span class="keyword">if</span> (time_to_ack) tcp_send_ack(sk)   <span class="regexp">//</span> 如果上面有需要发送ack的需求，则发送一个ACK  
        /* <span class="keyword">if</span> prequeue <span class="keyword">is</span> <span class="keyword">not</span> empty, we have to process it before releasing socket  
         * queue的处理优先级如下：  
         * receive queue 最高
         * prequeue queue 次之
         * backlog queue 最低
         */<span class="function">  
        =&gt;</span> <span class="keyword">if</span> prequeue <span class="keyword">is</span> <span class="keyword">not</span> empty, goto do_prequeue<span class="function">
            =&gt;</span> tcp_prequeue_process<span class="function"><span class="params">(sk)</span>  
                =&gt;</span> sk_backlog_rcv<span class="function"><span class="params">(sk, skb)</span>  == <span class="title">tcp_v4_do_rcv</span><span class="params">()</span>  

        =&gt;</span> <span class="keyword">if</span> (copied &gt;= target)   <span class="regexp">//</span> 下面两个步骤主要就是为了处理backlog queue<span class="function">  
            =&gt;</span> release_sock<span class="function"><span class="params">(sk)</span>  
                =&gt;</span> <span class="keyword">if</span> <span class="function"><span class="params">(sk-&gt;sk_backlog.tail)</span>   
                    =&gt;</span> __release_sock<span class="function"><span class="params">(sk)</span>  
                        =&gt;</span> sk_backlog_rcv<span class="function"><span class="params">(sk, skb)</span>  == <span class="title">tcp_v4_do_rcv</span><span class="params">()</span>  
            =&gt;</span> lock_sock<span class="function"><span class="params">(sk)</span> 
        =&gt;</span> <span class="keyword">else</span><span class="function">  
            =&gt;</span> sk_wait_data(sk, &amp;timeo)  <span class="regexp">//</span> 睡眠等待新数据的到来  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这章主要是TCP接收包得处理流程。<br>kernel对于TCP包得处理大致可以分为两类：  </p>
<ol>
<li>如果处理in-sequence的包时，application正阻塞在read操作中，则接收到的数据包的数据会被直接拷贝到user buffer。  </li>
<li>否则，in-sequence包会被放在receive queue中，out-of-order包会房子啊out-of-order queue中。  </li>
</ol>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(7): TCP send]]></title>
    <link href="http://perthcharles.github.com/2014/11/19/tcp-design-and-implementation-7/"/>
    <id>http://perthcharles.github.com/2014/11/19/tcp-design-and-implementation-7/</id>
    <published>2014-11-19T11:30:22.000Z</published>
    <updated>2014-11-20T08:10:24.000Z</updated>
    <content type="html"><![CDATA[<p>这种重点描述从应用层下发的数据，是在TCP中如何被管理以及被传输的。主要会涉及到MTU，各类TCP层的算法（如Nagle）以及核心的拥塞控制算法和flow control算法（滑动窗口机制）。<br>另外需要注意的是，这块我看的内核3.10与书中的内核版本实现存在较大不同，看代码的时候需要引起注意。  </p>
<a id="more"></a>  

<p>7.1 TCP segmentation unit for sending data<br>当应用层调用send发送数据后，内核中对应的函数就是tcp_sendmsg()。因此我们从这个函数切入来理解TCP的发送流程。  </p>
<pre><code>SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len, unsigned int, flags) // net/socket.c  
=<span class="ruby">&gt; sys_sendto(fd, buff, len, flags, <span class="constant">NULL</span>, <span class="number">0</span>)  /<span class="regexp">/ send a datagram to a given address, net/socket</span>.c line <span class="number">1754</span>  
</span>    =<span class="ruby">&gt; sock = sockfd_lookup_light()  /<span class="regexp">/ 通过fd找到sock  
</span></span>    =<span class="ruby">&gt; err = sock_sendmsg(sock, &amp;msg, len)  
</span>        =<span class="ruby">&gt; sock-&gt;ops-&gt;sendmsg()  == tcp_sendmsg()
</span>
tcp_sendmsg()  
    =<span class="ruby">&gt; mss_now = tcp_send_mss()  /<span class="regexp">/ 获得current mss
</span></span>    =<span class="ruby">&gt; sg = !!(sk-&gt;sk_route_caps * <span class="constant">NETIF_F_SG</span>)  /<span class="regexp">/ 检查硬件是否支持scatter-gather
</span></span>    =<span class="ruby">&gt; 两个循环，第一层遍历所有的buffer块，第二层遍历某一个buffer的所有数据  
</span><span class="comment">        /* 获取sk-&gt;sk_write_queue的最后一个skb，用于检查是否用满。</span>
         * 用满了就新建一个skb放新数据，否则将新数据拼接到这最后一个skb中   
         */
        =<span class="ruby">&gt; skb = tcp_write_queue_tail(sk)  
</span>        =<span class="ruby">&gt; <span class="keyword">if</span> (copy &lt;= <span class="number">0</span>) /<span class="regexp">/ 需要new a segment
</span></span>            =<span class="ruby">&gt; sk_stream_memory_free(sk)  /<span class="regexp">/ 检查send buffer的配额是否超过上限, 超过了要跳转到wait_for_sndbuf  
</span></span>                =<span class="ruby">&gt; <span class="keyword">return</span> sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf  
</span>            =<span class="ruby">&gt; skb = sk_stream_alloc_skb() /<span class="regexp">/ 为新数据新分配一个skb  
</span></span>            =<span class="ruby">&gt; skb_entail(sk, skb)    /<span class="regexp">/ 将新生成的skb挂到sk-&gt;sk_write_queue的尾部  
</span></span>        =<span class="ruby">&gt; skb_can_coalesce()  /<span class="regexp">/ 判断最后一页能否合并更多数据  
</span></span>
        =<span class="ruby">&gt; forced_push(tp) /<span class="regexp">/ 解释见接下来的note
</span></span>        =<span class="ruby">&gt; tcp_mark_push(tp, skb)  /<span class="regexp">/ 解释见接下来的note
</span></span><span class="comment">        /* push out any pending frames which were held back due to TCP_CORK </span>
         * or attempt at coalescing tiny packets 
         */
        =<span class="ruby">&gt; __tcp_push_pending_frame()  /<span class="regexp">/ 如果是设置了PSH flag，会调用该函数尽快的将数据发送出去  
</span></span>
        =<span class="ruby">&gt; <span class="keyword">if</span> (copied) tcp_push()  /<span class="regexp">/发送数据
</span></span>            =<span class="ruby">&gt; check sk-&gt;sk_send_head is <span class="constant">NULL</span> <span class="keyword">or</span> <span class="keyword">not</span> /<span class="regexp">/ 不为空表示有数据待发送  
</span></span>            =<span class="ruby">&gt; __tcp_push_pending_frames()  /<span class="regexp">/ 大部分数据应该是走这条流程被发送出去的  
</span></span>                =<span class="ruby">&gt; tcp_write_xmit()  /<span class="regexp">/ this rountine write packets to the network  
</span></span><span class="comment">                    /* 只要有数据pending在write queue里面就继续发送，</span>
                     * 当然循环内部有各种条件判断是否应该终止循环  
                     */
                    =<span class="ruby">&gt; <span class="keyword">while</span> (skb = tcp_send_head(sk))  
</span>                        =<span class="ruby">&gt; cwnd_quota = tcp_cwnd_test(tp, skb)  /<span class="regexp">/ 根据cwnd与packet in flight的差得到配额  
</span></span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)) <span class="keyword">break</span>;  <span class="regexp">//</span> 判断是否受限于rwnd  
</span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(!tcp_nagle_test()) <span class="keyword">break</span>;  <span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> allow by <span class="constant">Nagle</span>
</span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)) <span class="keyword">break</span>;  <span class="regexp">//</span> 发送一个skb，不成功则<span class="keyword">break</span>。参数<span class="number">1</span>表示传递一份clone  
</span>                            =<span class="ruby">&gt; 细节见后续章节    
</span>                        =<span class="ruby">&gt; tcp_event_new_data_sent(sk, skb)  /<span class="regexp">/ 更新sk-&gt;sk_send_head，tp-&gt;snd_nxt, tp-&gt;packet_out等  
</span></span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (push_one) <span class="keyword">break</span>;  <span class="regexp">//</span> 如果之前只允许发送一个，则<span class="keyword">break</span>  
</span>


tcp_mark_push()为sk_buff设置PSH flag。当满足下面某一个条件时，PSH会被设置：  
    1. we have written more than half of the so far maximum window size from the last byte marked as pushed  
    2. we have one full-sized TCP segment ready for transmission.  

forced_push()就是用来判断上面条件一是否成立的  
</code></pre><h4 id="tcp_transmit_skb">tcp_transmit_skb</h4>
<p>源代码函数上方的几句注释摘录一下，应该基本知道该函数的功能了。  </p>
<pre><code>This routine actually transmits TCP packets queued <span class="keyword">in</span> <span class="keyword">by</span> tcp_do_sendmsg().  
This <span class="keyword">is</span> used <span class="keyword">by</span> both the initial transmission <span class="keyword">and</span> possible later retransmissions.  
All SKB<span class="comment">'s seen here are completely headerless.  </span>
</code></pre><p>话多不说，直接读代码  </p>
<pre><code>tcp_transmit_skb()  
    =&gt; skb = skb_clone(skb, gfp_mask)  <span class="comment">// 复制一份skb，新的skb不属于任何一个socket  </span>
    =&gt; <span class="keyword">if</span> (tcp_packets_in_flight(tp) == <span class="number">0</span>) tcp_ca_event(sk, CA_EVENT_TX_START);  <span class="comment">// 根据packet inflight判断传输的开始  </span>
    =&gt; skb_push(skb, tcp_head_size)  <span class="comment">// 根据计算得到的TCP header长度调整skb  </span>
    =&gt; th = tcp_hdr(skb)  <span class="comment">// 获得TCP header对应位置，并开始构建TCP header</span>
    =&gt; tcp_options_write()  <span class="comment">// write previously computed TCP options to the packet</span>
    =&gt; icsk<span class="variable">-&gt;icsk_af_ops</span><span class="variable">-&gt;send_check</span>(sk, skb) == tcp_v4_send_check()  <span class="comment">// compute an IPv4 TCP checksum  </span>
    =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;len</span> != tcp_header_size) tcp_event_data_send(tp, sk)  <span class="comment">// congestion state accounting after a packet has been sent  </span>
    =&gt; err = icsk<span class="variable">-&gt;icsk_af_ops</span><span class="variable">-&gt;queue_xmit</span>()   ==  ip_queue_xmit() <span class="comment">// 目前不关心ip层及以下的实现  </span>
</code></pre><h3 id="TODO">TODO</h3>
<p>sock结构体中有一个sk_forward_alloc，需要理解一下这个变量  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这种重点描述从应用层下发的数据，是在TCP中如何被管理以及被传输的。主要会涉及到MTU，各类TCP层的算法（如Nagle）以及核心的拥塞控制算法和flow control算法（滑动窗口机制）。<br>另外需要注意的是，这块我看的内核3.10与书中的内核版本实现存在较大不同，看代码的时候需要引起注意。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(6): Movement of sk_buff across protocol layers]]></title>
    <link href="http://perthcharles.github.com/2014/11/18/tcp-design-and-implementation-6/"/>
    <id>http://perthcharles.github.com/2014/11/18/tcp-design-and-implementation-6/</id>
    <published>2014-11-18T13:50:50.000Z</published>
    <updated>2014-11-19T11:30:56.000Z</updated>
    <content type="html"><![CDATA[<p>这章主要是从宏观上来理解整个TCP/IP协议栈道额工作机制。在整个讨论的过程中，涉及到以下的层次划分：  </p>
<pre><code><span class="keyword">socket</span> layer  
tcp    layer  
ip     layer  
<span class="keyword">link</span>   layer  
packet scheduling layer, qdisc  
softIRQ framework  
transmission/reception  
</code></pre><a id="more"></a>  

<p>这一章太重要了，建议直接看书，尤其是理解书中的几个图。<br>哦对了，如果大家找不到该书的电子版，可以在博客下方留下邮箱。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这章主要是从宏观上来理解整个TCP/IP协议栈道额工作机制。在整个讨论的过程中，涉及到以下的层次划分：  </p>
<pre><code><span class="keyword">socket</span> layer  
tcp    layer  
ip     layer  
<span class="keyword">link</span>   layer  
packet scheduling layer, qdisc  
softIRQ framework  
transmission/reception  
</code></pre>]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(5): sk_buff and protocol headers]]></title>
    <link href="http://perthcharles.github.com/2014/11/18/tcp-design-and-implementation-5/"/>
    <id>http://perthcharles.github.com/2014/11/18/tcp-design-and-implementation-5/</id>
    <published>2014-11-18T06:22:06.000Z</published>
    <updated>2014-11-21T12:15:32.000Z</updated>
    <content type="html"><![CDATA[<p>这章学习一下TCP用于表示数据包的最重要的一个数据结构：sk_buff。<br>sk_buff有三部分：sk_buff基本数据元素, linear-data buffer, paged-data(struct skb_shared_info)。<br>这章将详细的讲解如何有sk_buff构建一个被发送出去的包（主要就是包头的构建）和如何解析一个数据包得到一个sk_buff。  </p>
<a id="more"></a>  

<h3 id="struct_sk_buff">struct sk_buff</h3>
<p>sk_buff结构体的定义位于：include/linux/skbuff.h文件中。其中的主要元素及解释如下所示：  </p>
<pre><code><span class="keyword">struct</span> sk_buff {
    <span class="comment">/* These two members must be first */</span>
    <span class="keyword">struct</span> sk_buff      *next;  
    <span class="keyword">struct</span> sk_buff      *prev;

    <span class="keyword">struct</span> sk_buff      tstamp;                 <span class="comment">// sk_buff发送时间/接收时间</span>

    <span class="keyword">struct</span> sock         *sk;                    <span class="comment">// 标示这个sk_buff属于哪个sock  </span>
    <span class="keyword">struct</span> net_device   *dev;                   <span class="comment">// 表示从哪个设备接收/发出  </span>

    <span class="keyword">char</span>                cb[<span class="number">48</span>] __aligned(<span class="number">8</span>);    <span class="comment">// control buffer, TCP map this buffer to struct tcp_skb_cb  </span>
    ...  

    <span class="keyword">unsigned</span> <span class="keyword">int</span>        len;                    <span class="comment">// sk_buff的总长度  = linear-data + paged-data  </span>
    <span class="keyword">unsigned</span> <span class="keyword">int</span>        data_len;               <span class="comment">// paged-data length</span>
    __u16               mac_len;            
    __u16               hdr_len;                <span class="comment">// writable header length of cloned skb</span>
    ...  

    __u32               priority;               <span class="comment">// packet queueing priority</span>
    ...  
    __u8                peeked:<span class="number">1</span>;               <span class="comment">// packet has been seen already, so stats have been done for it, don't do them again</span>
    ...  
    <span class="comment">/* 有意思的是alloc_skb时，skb-&gt;tail = skb-&gt;data - skb-&gt;head。tail其实是一个偏移量，而不是一个真正意义上的指针
     * 同时skb-&gt;end = skb-&gt;tail + size 也是一样偏移量。
     */</span>
    sk_buff_data_t      tail;                   <span class="comment">// last byte of the data residing in linear area (与data指针对应)</span>
    sk_buff_data_t      end;                    <span class="comment">// end of linear-data area (与head指针对应)</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span>       *head;                  <span class="comment">// points to the start of the linear data area (first byte allocated)</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span>       *data;                  <span class="comment">// start of data residing in the linear area   (first byte used)</span>

    <span class="keyword">unsigned</span> <span class="keyword">int</span>        truesize;               <span class="comment">// total memory allocated for this buffer = sizeof(sk_buff) + the size of the data block allocated for this sk_buff  </span>
};

<span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *sk_buff_data_t;
</code></pre><h4 id="struct_skb_shared_info">struct skb_shared_info</h4>
<p>This data is invariant(不变的) across clones and lives at the end of the header data, ie. at skb-&gt;end.<br>这个数据结构主要半酣sk_buff中的nonlinear data。所谓的nonlinear data其实就是linear-data area放不下的数据就放到nonlinear area了。<br>书中把nonlinear data area也叫做 paged-data area. The paged-data area is possible only if DMA allows scatter-gather operations on the physically scattered pages.  </p>
<hr>
<h3 id="Routines_operating_on_sk_buff">Routines operating on sk_buff</h3>
<ol>
<li><p>stuct sk_buff *__alloc_skb(unsigned int size, gfp_t gfp_mask, int flags, int mode)<br>该函数分配一个新的sk_buff实例，需要给定的参数是linear-data area的大小和内存分配的模式。  </p>
</li>
<li><p>static inline void skb_reserve(struct sk_buff *skb, int len)<br>该函数将skb的data和tail指针往后移动，移动长度为len。常见的用途是为协议头部保留空间。  </p>
</li>
<li><p>unsigned char <em>skb_put(struct sk_buff </em>skb, unsigned int len)<br>该函数负责将sk_buff的linear-data area的tail指针增加len。可以看到3.10的kernel里面使用了skb_tail_pointer的方式获取真正意义上的指向数据使用部分的最后一个字节的指针。进一步验证了之前分析sk_buff结构体定义时认为tail是一个offset的判断。这点与书中描述的是不一致的。可见Linux kernel中关于TCP这块的更新还是很频繁的。连sk_buff这种重要的数据结构也一直在改动。  </p>
</li>
<li><p>unsigned char <em>skb_push(struct sk_buff </em>skb, unsigend int len)<br>该函数负责将sk_buff的linear-data area的data指针往前移动，距离为len。不难看出，skb_put是用来构建包的数据的，而skb_push则是当一个上层包传递到下一层后，下层在添加头部数据时调用skb_push。  </p>
</li>
<li><p>unsigned char <em>skb_pull(struct sk_buff </em>skb, unsigned int len)<br>该函数与skb_push相对应，它将data指针往后移动，距离为len。也就意味着skb-&gt;len要减少len。当有数据包到达后，一层层解析包头的过程中往往会用到该函数。  </p>
</li>
</ol>
<p>书中的5.5节描述了发送数据包时header是如何添加的，5.6节描述了收到的数据包头是如何被解析的。不过基本上熟悉了上面几个函数后，基本的操作方法应该都能理解了。还有不清楚的可以看下书。<br>这章主要就是讲sk_buff及其相关的一些操作函数，还算比较好理解。  </p>
<pre><code>tcp_skb_cb结构体是TCP层对于sk_buff-&gt;<span class="keyword">cb</span>的实例化。里面主要有seq，timestamp和sacked flag  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这章学习一下TCP用于表示数据包的最重要的一个数据结构：sk_buff。<br>sk_buff有三部分：sk_buff基本数据元素, linear-data buffer, paged-data(struct skb_shared_info)。<br>这章将详细的讲解如何有sk_buff构建一个被发送出去的包（主要就是包头的构建）和如何解析一个数据包得到一个sk_buff。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Guide for Technical Development by Google]]></title>
    <link href="http://perthcharles.github.com/2014/11/13/guide-for-technical-development/"/>
    <id>http://perthcharles.github.com/2014/11/13/guide-for-technical-development/</id>
    <published>2014-11-13T06:27:15.000Z</published>
    <updated>2014-11-13T10:16:41.000Z</updated>
    <content type="html"><![CDATA[<p>网上偶尔发现的一篇好文，读完顺手推荐给大家。<br><a href="https://www.google.com/edu/tools-and-solutions/guide-for-technical-development/index.html" target="_blank" rel="external">英文原版</a><br><a href="http://mooc.guokr.com/post/610231/" target="_blank" rel="external">中文翻译版</a><br>另外在推荐一下孙志刚老师在知乎的回答<a href="http://www.zhihu.com/question/26594660" target="_blank" rel="external">Google发布了程序员养成指南，国内互联网巨头是否也有类似的指南和课程推荐？</a><br><a id="more"></a></p>
<h3 id="Recommendations_for_Academic_Learnings">Recommendations for Academic Learnings</h3>
<hr>
<h4 id="Introduction_to_CS_Course">Introduction to CS Course</h4>
<p><a href="https://www.udacity.com/course/cs101" target="_blank" rel="external">Intro to Computer Science</a><br><a href="https://www.coursera.org/course/cs101" target="_blank" rel="external">Computer Science 101</a>  </p>
<h4 id="Code_in_at_least_one_object_oriented_programming_language">Code in at least one object oriented programming language</h4>
<p>这里根据自己的兴趣选择了相关的几门。<br><em>入门</em><br><a href="https://www.coursera.org/course/programming1" target="_blank" rel="external">Learn to Program: The fundamentals</a><br><a href="https://developers.google.com/edu/python/" target="_blank" rel="external">Google’s Python Class</a><br><a href="https://www.coursera.org/course/interactivepython" target="_blank" rel="external">An Introduction to Interactive Programing in Python</a><br><a href="http://www.openbookproject.net/thinkcs/python/english2e/" target="_blank" rel="external">How to Think Like a Compter Scientist</a>  </p>
<p><em>高阶</em><br><a href="https://www.udacity.com/course/cs212" target="_blank" rel="external">Design of Computer Programs</a><br><a href="https://www.coursera.org/course/programming2" target="_blank" rel="external">Learn to Program: Crafting Quality Code</a>  </p>
<p>更多地其他语言的课程，可以上w3cschool.com和codeacademy.com上去自己找。  </p>
<h4 id="Test_Your_Code">Test Your Code</h4>
<p><a href="https://www.udacity.com/course/cs258" target="_blank" rel="external">Software Testing: How to make software fail</a><br><a href="https://www.udacity.com/course/cs259" target="_blank" rel="external">Software Debugging: Automating the Boring Tasks</a>  </p>
<h4 id="Develop_logical_reasoning_and_knowledge_of_discrete_math">Develop logical reasoning and knowledge of discrete math</h4>
<p><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/index.htm" target="_blank" rel="external">Mathematics for Computer Science</a><br><a href="https://www.coursera.org/course/intrologic" target="_blank" rel="external">Introduction to Logic</a><br><a href="https://www.coursera.org/course/linearopt" target="_blank" rel="external">Linear and Discrete Optimization</a><br><a href="https://www.coursera.org/course/pgm" target="_blank" rel="external">Probabilistic Graphical Models</a><br><a href="https://www.coursera.org/course/gametheory" target="_blank" rel="external">Game Theory</a><br><a href="https://www.coursera.org/course/gametheory2" target="_blank" rel="external">Game Theory II: Advanced Applications</a>  </p>
<h4 id="Algorithms_and_Data_Structures">Algorithms and Data Structures</h4>
<p><a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-spring-2008/index.htm" target="_blank" rel="external">Introduction to Algorithms</a><br><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">Algorithms, Part I</a><br><a href="https://www.coursera.org/course/algs4partII" target="_blank" rel="external">Algorithms, Part II</a><br><a href="http://en.wikipedia.org/wiki/List_of_algorithms" target="_blank" rel="external">List of algorithms</a><br><a href="http://en.wikipedia.org/wiki/List_of_data_structures" target="_blank" rel="external">List of data structures</a><br><a href="http://book.douban.com/subject/3072383/" target="_blank" rel="external">The Algorithm Design Manual</a>  </p>
<h4 id="Develop_a_strong_knowledge_of_operating_systems">Develop a strong knowledge of operating systems</h4>
<p>注：下面这个链接是YouTube上的，请首先学会科学上网。<br><a href="http://www.youtube.com/watch?v=XgQo4JkN4Bw&amp;list=PL3289DD0D0F0CD4A3" target="_blank" rel="external">UC Berkeley Computer Science 162</a><br>另课件PPT<a href="http://cs162.eecs.berkeley.edu/" target="_blank" rel="external">在这里</a>  </p>
<h4 id="AI,_Compilers_和Cryptography暂略过">AI, Compilers 和Cryptography暂略过</h4>
<h4 id="Learn_Parallel_Programming">Learn Parallel Programming</h4>
<p><a href="https://www.coursera.org/course/hetero" target="_blank" rel="external">Heterogeneous Parallel Programming</a>  </p>
<h3 id="Recommendations_for_Non-Academic_Learnings">Recommendations for Non-Academic Learnings</h3>
<hr>
<p>这部分是一些实践相关的建议，赞啊！<br>Work on project outsides of the classroom.  </p>
<pre><code><span class="operator"><span class="keyword">Create</span> <span class="keyword">and</span> maintain a website  
Build your own <span class="keyword">server</span>  
Build a robot  </span>
</code></pre><p>Work on a small piece of a large system, read and understand existing code, track down documentation, and debug things.  </p>
<pre><code>Github <span class="keyword">is</span> a great way <span class="keyword">to</span> read other people<span class="attribute">'s</span> code <span class="keyword">or</span> contribute <span class="keyword">to</span> a project.  
</code></pre><p>Work on project with other programmmers.  </p>
<p>Practice your algorithmic knowledge and coding skills.  </p>
<pre><code><span class="title">CodeJam</span>  
ACM  
我补充几个：leetcode, hackrank, codeforces.   
</code></pre><p>Become a Teaching Assistant  </p>
<p>Intership experience in software engineering  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>网上偶尔发现的一篇好文，读完顺手推荐给大家。<br><a href="https://www.google.com/edu/tools-and-solutions/guide-for-technical-development/index.html" target="_blank" rel="external">英文原版</a><br><a href="http://mooc.guokr.com/post/610231/" target="_blank" rel="external">中文翻译版</a><br>另外在推荐一下孙志刚老师在知乎的回答<a href="http://www.zhihu.com/question/26594660" target="_blank" rel="external">Google发布了程序员养成指南，国内互联网巨头是否也有类似的指南和课程推荐？</a><br>]]>
    
    </summary>
    
      <category term="google" scheme="http://perthcharles.github.com/tags/google/"/>
    
      <category term="自学材料" scheme="http://perthcharles.github.com/tags/%E8%87%AA%E5%AD%A6%E6%9D%90%E6%96%99/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(4): TCP Connection Setup]]></title>
    <link href="http://perthcharles.github.com/2014/11/05/tcp-design-and-implementation-4/"/>
    <id>http://perthcharles.github.com/2014/11/05/tcp-design-and-implementation-4/</id>
    <published>2014-11-05T01:52:27.000Z</published>
    <updated>2014-11-24T09:17:47.000Z</updated>
    <content type="html"><![CDATA[<p>这一章主要学习TCP网络编程的几个关键函数：bind(),listen(),accept()和connect()。当然这里说的是这几个函数对应的systemcall的内核实现，并不是用户层怎么使用这些函数。同时还会介绍一些内核中与这些函数相关的数据结构。  </p>
<a id="more"></a>  

<h3 id="服务器端调用关键系统调用的顺序及简单说明">服务器端调用关键系统调用的顺序及简单说明</h3>
<p>英文水平有限，没法准确的翻译出这些句子。所以直接摘录原文了，:-)  </p>
<p>socket(): Identify correct set of socket * protocol operation and link them together with the help of sock &amp; socket structure. Hook this socket to vfs and associate this socket to the inode.  </p>
<p>bind(): Register this socket and request kernel to associate port number and(/or) IP address with the socket. At this stage kernel will lock the port number.  </p>
<p>listen(): request to the kernel to configure the connection baklog queue for the socket.  </p>
<p>accept(): this is the final step to get the server application up. Server application requests the kernel to now start accepting the connection for itself. Kernel creates a new socket on behalf of the server application, associates this socket with the VFS and returns new socket fd to the server applications.  </p>
<h3 id="Bind过程及其相关数据结构">Bind过程及其相关数据结构</h3>
<hr>
<p>bind完成的主要工作就是将socket与sockaddr结构体进行绑定。这点从bind的函数原型就能看出来。  </p>
<pre><code><span class="keyword">int</span> bind(<span class="keyword">int</span> sockfd, <span class="keyword">struct</span> sockaddr *my_addr, <span class="keyword">int</span> addrlen);
</code></pre><p>而struct sockaddr其实只是一个通用的数据结构，写实际代码的时候往往声明更加具体的结构体，比如AF_INET family的话就使用sockaddr_in结构体。然后调用bind的时候完成类型转换即可。<br>相关结构体声明如下：  </p>
<pre><code><span class="comment">// 声明在include/linux/socket.h中</span>
<span class="keyword">struct</span> sockaddr {
    sa_family_t                sa_family;        <span class="comment">// 存储address family，AF_xxx</span>
    <span class="keyword">char</span>                    sa_data[<span class="number">14</span>];    <span class="comment">// 通用内存区域</span>
};

<span class="comment">// 声明在include/uapi/linux/in.h中</span>
<span class="keyword">struct</span> sockaddr_in {
    __kernel_sa_family_t     sin_family;        <span class="comment">// address family， unsigined short</span>

    __be16                    sin_port;        <span class="comment">// port number, __u16, 应是2Bytes</span>
    <span class="keyword">struct</span>    in_addr            sin_addr;        <span class="comment">// internet address</span>

    <span class="comment">// pad to size of `struct sockaddr`</span>
    <span class="keyword">unsigned</span> <span class="keyword">char</span>             _padXXX;        <span class="comment">// 补齐未用完的内存，已具体声明省略</span>
};

<span class="comment">// 声明在include/uapi/linux/in.h中</span>
<span class="keyword">struct</span> in_addr {
    __be32                    s_addr;            <span class="comment">// __u32,应是4Bytes</span>
};
</code></pre><p>可以看出sockaddr_in其实只用了其中6个字节作为有效区域。需要说明的是，作为服务器端sin_addr一般设置为INADDR_ANY（0x00000000）, 意思就是说可以接受来自不同网卡（服务器一般有多个网卡，也就对应对个IP地址）的链接请求。  </p>
<h4 id="bind系统调用的过程">bind系统调用的过程</h4>
<pre><code>sys_bind()
    =&gt; sockfd_lookup_light() <span class="comment">// 根据fd 获取套接口指针，并返回是否需要减少文件引用计数</span>
    =&gt; sock<span class="variable">-&gt;ops</span><span class="variable">-&gt;bind</span>()  == inet_bind()
        =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;bind</span>() == raw_bind()  <span class="comment">// 如果是RAW sock</span>
        =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;get_port</span>() == inet_csk_get_port()  <span class="comment">// 如果是 TCP</span>
        =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;get_port</span>() == udp_v4_get_port()  <span class="comment">// 如果是 UDP    </span>
</code></pre><p>sys_bind的实现在net/socket.c中，具体的声明如下：  </p>
<pre><code>SYSCALL_DEFINE3(bind, <span class="keyword">int</span>, fd, <span class="keyword">struct</span> sockaddr __user *, umyaddr, <span class="keyword">int</span>, addrlen)  
</code></pre><p>主要完成的动作就是首先根据fd找到sock结构体，然后将sockaddr从用户空间move到内核空间。之后就根据sock结构体中的ops-&gt;bind函数执行具体的调用。如果fput_needed被标记，则将sock的引用计数减一。  </p>
<p>sock_fd_lookup_light的具体过程如下：  </p>
<pre><code>sock_fd_lookup_light()
<span class="output"><span class="status">    =&gt;</span> file = fget_light(fd, fput_needed);    <span class="regexp">//</span> 获取文件指针</span>
<span class="output"><span class="status">    =&gt;</span> sock = sock_from_file(file, err);      <span class="regexp">//</span> 获取sock指针</span>
        <span class="keyword">return</span> file-&gt;private_data;  <span class="regexp">//</span> private_data即是file结构体中的指向sock结构体的指针
</code></pre><p>inet_bind的实现在net/ipv4/af_inet.c中，具体过程如下：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">如果是RAW sock的话，直接调用bind</div><div class="line">检查addr_len和sin_family</div><div class="line">chk_addr_ret = inet_addr_type();  <span class="comment">// 得到地址的类型，用于后续检查</span></div><div class="line">对port进行判断，用户仅能使用Port &gt;= <span class="number">1024</span>的端口。</div><div class="line">根据sk-&gt;sk_state及inet-&gt;inet_num判断socket状态，检查重复绑定的错误</div><div class="line"></div><div class="line"><span class="comment">/* rcv_saddr用于hash lookups, inet_saddr用于transmit。正常情况下它们值相同 */</span></div><div class="line">inet-&gt;inet_rcv_saddr = inet-&gt;inet_saddr = addr-&gt;sin_addr.s_addr;  </div><div class="line"></div><div class="line">调用sk-&gt;sk_prot-&gt;get_port(sk, snum);  <span class="comment">// snum就是sin_port</span></div></pre></td></tr></table></figure>



<h4 id="端口管理">端口管理</h4>
<p>在介绍具体的get_port函数之前，需要先来了解一下内核对于端口是怎么管理的。<br>Linux内核是通过一张hash表管理socket使用时的端口的，hash表存放在tcp_hashinfo中，通过sk-&gt;sk_prot-&gt;h.hashinfo引用。  </p>
<pre><code><span class="keyword">struct</span> inet_hashinfo {
    <span class="keyword">struct</span> inet_ehash_bucket    *ehash;        
    spinlock_t                    *ehash_locks;
    <span class="keyword">unsigned</span> <span class="keyword">int</span>                ehash_mask;
    <span class="keyword">unsigned</span> <span class="keyword">int</span>                ehash_locks_mask;

    <span class="keyword">struct</span> inet_bind_hashbucket        *bhash;    
    <span class="keyword">unsigned</span> <span class="keyword">int</span>                    bhash_size;
    <span class="keyword">struct</span> kmem_cache                *bind_bucket_cachep;

    <span class="comment">/* 上面的变量在bootup时确定，之后是只读的
     * 下面的变量往往是dirty的，所以用了cacheline对齐
     */</span>

    <span class="keyword">struct</span> inet_listen_hashbucket    listening_hash[INET_LHTABLE_SIZE]
                                    ____cacheline_aligned_in_smp;
    atomic_t                        bsockets;
};

<span class="keyword">struct</span> inet_bind_hashbucket {
    spinlock_t            lock;
    <span class="keyword">struct</span> hlist_head    chain;
};

<span class="keyword">struct</span> hlist_head {
    <span class="keyword">struct</span> hlist_node     *first;
};

<span class="keyword">struct</span> hlist_node {
    strcut hlist_node    *next, **pprev;
};
</code></pre><h4 id="TCP端口绑定实现：inet_csk_get_port()">TCP端口绑定实现：inet_csk_get_port()</h4>
<p>新版的内核中TCP的get_port函数改名为了inet_csk_get_port，这点是与书中不一样的地方。当然完成的功能是一样的，参数是sock结构体和Port，如果Port=0，则需要找到一个空闲的Port给sock。函数的实现位于net/ipv4/inet_connection_sock.c中，具体执行过程可参考<a href="http://hellojavaer.iteye.com/blog/1114726" target="_blank" rel="external">这里</a>. 主要就是找到一个可用的Port过程，然后就是判断找到的Port是否可重用，不能重用的Port在使用是还要检查绑定冲突，即调用bind_conflict().<br>bind_confict()对于TCP来说，就是inet_csk_bind_conflict，具体的实现位于net/ipv4/tcp_ipv4.c中。  </p>
<pre><code>小技巧：对于TCP而言，sk-&gt;sk_prot结构体的初始化位于net/ipv4/tcp_ipv4.c文件中，<span class="keyword">struct</span> proto tcp_prot.  
</code></pre><h3 id="Listen过程及其相关结构体">Listen过程及其相关结构体</h3>
<hr>
<p>sys_listen()是listen在内核的表示，而具体的实现是在net/socket.c中，声明为：  </p>
<pre><code>SYSCALL_DEFINE2(<span class="keyword">listen</span>, <span class="keyword">int</span>, fd, <span class="keyword">int</span>, backlog)  
</code></pre><p>sys_listen在获得sock结构体之后，会进一步检查backlog是否超过系统允许的上限，最后就是调用sock-&gt;ops-&gt;list。先手来看一下sys_listen关键的调用过程：  </p>
<pre><code>sys_listen()
=&gt; sock<span class="variable">-&gt;ops</span><span class="variable">-&gt;listen</span>()  == inet_listen()
    =&gt; fastopen_init_queue(sk, backlog)    <span class="comment">// 条件允许的话，建立fastopen队列</span>
    =&gt; inet_csk_listen_start(sk, backlog)
        =&gt; sk<span class="variable">-&gt;sk_state</span> = TCP_LISTEN
        =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;get_port</span>(sk, inet<span class="variable">-&gt;inet_num</span>)  <span class="comment">// re-check port是否可用，原因见下面一段原文引用。</span>
        =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;hash</span>(sk) == inet_hash(sk)     <span class="comment">// 如果一切正常，则为该socket建立hash表项</span>
            =&gt; __inet_hash()  <span class="comment">// 为socket生成表项，并加入listen hash table</span>
</code></pre><p>inet_listen()首先判断sock的状态，如果不是合法的状态的话就直接返回错误。随后如果不是listen状态，则需要做更多的事情将sock置于listen状态，否则直接设置sk-&gt;sk_max_ack_backlog即可。如果需要将sock置于listen状态，首先会判断一些条件看是否满足TCP_FASTOPEN（TFO）的要求，若满足则执行fastopen_init_queue()，然后执行inet_csk_listen_start(). sk-&gt;sk_prot-&gt;hash(sk)对于TCP来讲的话，具体的实现就是inet_hash(), 位于net/ipv4/inet_hashtables.c文件中。    </p>
<p>至于为什么sys_listen还需要调用get_port确认一次，我还不是太懂。根据代码的注释和书本的讲解，大概可以理解为多线程可能存在竞争（race）。关键就是reuse标示可能被重置，详细解释摘录一段书中的解释如下：  </p>
<blockquote>
<p> We need to check if we are still eligible to use the same port to which we earlier bound this socket. There is a window between the bind() and listen() calls form an application when two threads can race to bind two sockets to the same port. After both the threads are bound to the same port (both the sockets are in the bind hash list, tcp_bhash), one of the sockets makes the socket port not reusable (resets sk-&gt;reuse for itself) and gets into the TCP_LISTEN state. The other thread now enters the listen() systemcall and gets into this part of the code. So, once again it needs to make sure whether it can use the same port that it requested eariler.  </p>
</blockquote>
<h4 id="分析调用bind和listen对socket状态的影响">分析调用bind和listen对socket状态的影响</h4>
<pre><code><span class="number">1</span>. 一个调用了<span class="keyword">bind</span>，而没有调用<span class="keyword">listen</span>的<span class="keyword">socket</span>，是仅仅绑定了端口（或IP）的，并不能接收连接请求。  
    此时<span class="keyword">socket</span>的状态还不是listening，如果客户端发出连接请求，服务器端会回复<span class="keyword">reset</span>包  
<span class="number">2</span>. 为<span class="keyword">socket</span>调用了<span class="keyword">listen</span>，而没有调用<span class="keyword">accept</span>时，<span class="keyword">socket</span>的状态是listening，  
    此时如果客户端发出连接请求，能能够看到三次握手成功的【注意！】；
    同时客户端也能发送数据并收到ACK，但是在发完rwnd数量的数据后会收到rwnd等于<span class="number">0</span>的确认包。  
    此后客户端就会停止发送数据。最终由于服务器端不会consume接收的数据，会导致客户端的<span class="number">0</span>窗口探测包超时后结束连接。  
</code></pre><p>tcp_ehash结构中存储这所有状态为TCP_ESTABLISHED和TIME_WAIT状态下的TCP流。当一个新的数据包到来时，我们需要找到这个包对应的socket，具体就是使用四元组（remote IP, PORT 和 local IP, PORT）作为key在tcp_ehash查找。  </p>
<h4 id="区分SYN_queue和Accept_queue">区分SYN queue和Accept queue</h4>
<p>SYN queue: 当一个调用过listen函数的socket收到连接请求（第一个SYN包）后，会首先发送SYN/ACK包然后添加对应的connection request到SYN queue中去等待最后一个ACK包。  </p>
<p>Accept queue: 一旦收到了三次握手的最后一个ACK包，一个新的socket将会为对应的connection request建立，然后将connection request从SYN queue中移除。最后connection request 将放入listening socket对应的accept queue中。  </p>
<h4 id="Flow_control_for_handling_a_new_connection_request">Flow control for handling a new connection request</h4>
<p>当TCP层收到一个IP包时，被调用的函数是tcp_v4_rcv()，该函数的实现是在net/ipv4/tcp_ipv4.c中。  </p>
<pre><code>tcp_v4_rcv(struct sk_buff *skb)  
    =&gt; sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th<span class="variable">-&gt;source</span>, th<span class="variable">-&gt;dest</span>) <span class="comment">//根据四元组查找该IP包对应的sock结构体  </span>
        =&gt; __inet_lookup()
            =&gt; __inet_lookup_established()  <span class="comment">// 在tcp_ehash table中查找  </span>
            =&gt; __inet_lookup_listener()     <span class="comment">// 上一步没找到再到hashinfo-&gt;listening-hash[]中查找  </span>

    =&gt; ret = tcp_v4_do_rcv(sk, skb)  
        =&gt; <span class="keyword">if</span> (sk<span class="variable">-&gt;sk_state</span> == TCP__ESTABLISHED)
            =&gt; tcp_rcv_established()  <span class="comment">// 后续再分析该函数  </span>
        =&gt; <span class="keyword">if</span> (sk<span class="variable">-&gt;sk_state</span> == TCP_LISTEN)
            =&gt; struct sock *nsk = tcp_v4_hnd_req(sk, skb)    <span class="comment">// 找到skb对应的sock，找不到则丢弃  </span>
            =&gt; <span class="keyword">if</span> (nsk != sk)  <span class="comment">// 如果nsk与sk不同，即说明已经为该connection request新建了sock</span>
                =&gt; tcp_child_process(sk, nsk, skb)  <span class="comment">// 对新建立的sock结构体做更多地处理</span>
        =&gt; tcp_rcv_state_process(sk, skb, tcp_hdr(skb), skb<span class="variable">-&gt;len</span>)    <span class="comment">// 根据不同的状态处理响应的包，此处关心listen和syn_sent状态      </span>
            =&gt; <span class="keyword">case</span> TCP_LISTEN:  
                =&gt; icsk<span class="variable">-&gt;icsk_af_ops</span><span class="variable">-&gt;conn_request</span>() == tcp_v4_conn_request()
                    =&gt; inet_csk_reqsk_queue_is_full(sk)    <span class="comment">// 判断request queue是否用满  </span>
                    =&gt; sk_acceptq_is_full(sk)              <span class="comment">// 判断accept queue是否用满</span>
                    =&gt; req = inet_reqsk_alloc()            <span class="comment">// 为connection request分配一个request sock</span>
                    =&gt; tcp_parse_options()                 <span class="comment">// 解析TCP options  </span>
                    =&gt; tcp_openreq_init()
                    =&gt; ip_build_and_send_pkt()             <span class="comment">// add an ip header to a skbuff and send it out  </span>
                    =&gt; inet_csk_reqsk_queue_hash_add()     <span class="comment">// add the request sock to the SYN table</span>
            =&gt; <span class="keyword">case</span> TCP_SYN_SENT:  
                =&gt; queue = tcp_rcv_syssent_state_process(sk, skb, th, len)    <span class="comment">// 代码里面注释较详细  </span>
                    =&gt; tcp_finish_connect()     <span class="comment">// 完成连接，进行最后的设置  </span>
                        =&gt; tcp_set_state(sk, TCP_ESTABLISHED)   <span class="comment">// 设置sk_state</span>
                        =&gt; tcp_init_congestion_control(sk)      <span class="comment">// 设置congestion control algorithm，我实现的快速重传算法的初始化也是在这附近  </span>
                        =&gt; tcp_init_buffer_space(sk)  
</code></pre><h3 id="Accept过程及相关结构体">Accept过程及相关结构体</h3>
<hr>
<p>accept系统调用对应内核中的sys_accept()函数，具体的实现则在net/socket.c文件中。主要调用流程如下：  </p>
<pre><code>SYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,  
                int __user *, upeer_addrlen, int, flags)  == sys_accept4   
    =&gt; sock = sockfd_lookup_light(fd, &amp;err, &amp;fput_needed)  <span class="comment">// 根据监听的socket fd找到其sock结构体  </span>
    =&gt; newsock = sock_alloc()   <span class="comment">// 分配一个新的BSD socket </span>
    =&gt; newfd = get_unused_fd_flags(flags)
    =&gt; newfile = sock_alloc_file(newsock, flags, sock<span class="variable">-&gt;sk</span><span class="variable">-&gt;sl_prot_creator</span><span class="variable">-&gt;name</span>)
    =&gt; err = sock<span class="variable">-&gt;ops</span><span class="variable">-&gt;accept</span>(sock, newsock, sock<span class="variable">-&gt;file</span><span class="variable">-&gt;f_flags</span>)  == inet_accept()
        =&gt; *sk2 = sk1<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;accept</span>()  == inet_csk_accept()
            =&gt; <span class="keyword">if</span> accept queue is <span class="keyword">empty</span>, wait <span class="keyword">for</span> connect <span class="keyword">if</span> is blocking
            =&gt; otherwise, get the very first request

            =&gt; newsk = req<span class="variable">-&gt;sk</span>    <span class="comment">// 获取request结构体中的sock结构体指针并返回</span>
        =&gt; sock_graft(sk2, newsock)  <span class="comment">// 将获取的sock结构体与之前新建的BSD socket关联  </span>
        =&gt; newsock<span class="variable">-&gt;state</span> = SS_CONNECTED;
    =&gt; fd_install(newfd, newfile);   <span class="comment">// index newfile for the socket inode in the process file table  </span>
        =&gt; fd_install主要完成的动作就是：current<span class="variable">-&gt;files</span><span class="variable">-&gt;fd</span>[fd] = file;
</code></pre><p>inet_accept()在net/ipv4/af_inet.c文件中，完成连接建立的最后一步：accept a pending connection. 当然这里的pending connection 其实已经完成了三次握手的过程。<br>注意这里sock_graft函数，函数实现在include/net/sock.h文件中。第一个参数是struct sock <em>sk, 这是通过获取accept queue中第一项找到的，是在三次握手阶段创建的；第二个参数是struct socket </em>parent，这是一个网络编程时看到的一个概念，与kernel中的sock有着本质的区别。<br>同时也要注意到kernel中命名的一个小规律：<br>    struct socket 结构体的实例化名字，常缩写成sock<br>    struct sock结构体的实例化名字，常缩写成sk  </p>
<h4 id="BSD_socket与sock结构体的关系">BSD socket与sock结构体的关系</h4>
<p>同时sock_graft函数也很直接的现实了BSD socket结构体与sock结构体的关系，源代码不长就直接贴出来了。需要注意的是，这里为了完整的展现sock_graft的功能，手动的展开了inline函数。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">static <span class="keyword">inline</span> <span class="literal">void</span> sock_graft(struct sock <span class="subst">*</span>sk, struct socket <span class="subst">*</span><span class="keyword">parent</span>)</div><div class="line">{</div><div class="line">    write_lock_bh(<span class="subst">&</span>sk<span class="subst">-&gt;</span>sk_callback_lock);</div><div class="line">    sk<span class="subst">-&gt;</span>sk_wq <span class="subst">=</span> <span class="keyword">parent</span><span class="subst">-&gt;</span>wq;</div><div class="line">    <span class="keyword">parent</span><span class="subst">-&gt;</span>sk <span class="subst">=</span> sk;</div><div class="line"></div><div class="line">    sk<span class="subst">-&gt;</span>sk_tx_queue_mapping <span class="subst">=</span> <span class="subst">-</span><span class="number">1</span>;</div><div class="line">    sk<span class="subst">-&gt;</span>sk_socket <span class="subst">=</span> <span class="keyword">parent</span>;</div><div class="line"></div><div class="line">    write_unlock_bh(<span class="subst">&</span>sk<span class="subst">-&gt;</span>sk_callback_lock);</div><div class="line">}</div></pre></td></tr></table></figure>



<p>至于file, inode 和 socket结构体的关系用文字表达比较费劲，推荐看下书中的Figure 4.21, Figure 4.22再结合代码理解。  </p>
<h3 id="Connect过程及相关结构体">Connect过程及相关结构体</h3>
<hr>
<p>客户端建立一个TCP connection需要做的事情相对简单。先调用socket()新建一个BSD socket，然后调用connect函数与远端相连即可。引用一段书中的一段更详细准确的解释如下：  </p>
<pre><code>Socket():
    <span class="number">1.</span> Identify correct <span class="built_in">set</span> <span class="operator">of</span> <span class="built_in">socket</span> &amp; protocol operations <span class="operator">and</span>  
    link them together <span class="operator">with</span> <span class="operator">the</span> help <span class="operator">of</span> sock &amp; <span class="built_in">socket</span> structure.  
    <span class="number">2.</span> Initialize some <span class="operator">of</span> <span class="operator">the</span> fields <span class="operator">of</span> protocol specific data structures.  
    <span class="number">3.</span> Hook this <span class="built_in">socket</span> <span class="built_in">to</span> <span class="operator">the</span> vfs <span class="operator">and</span> associate this <span class="built_in">socket</span> <span class="built_in">to</span> <span class="operator">the</span> inode.
</code></pre><p>   Connect():</p>
<pre><code>    <span class="number">1.</span> Let <span class="operator">the</span> kernel know what services (server port <span class="built_in">number</span>) you want <span class="built_in">to</span> avail <span class="operator">and</span>  
    <span class="built_in">from</span> where (IP address).  
    <span class="number">2.</span> Initializes protocol specific data structures, allocates resources <span class="keyword">for</span> client  
    application, <span class="operator">and</span> sets up complete procotol stack <span class="keyword">for</span> <span class="operator">the</span> client side.  
    <span class="number">3.</span> By default, connect blocks <span class="operator">and</span> returns <span class="built_in">to</span> <span class="operator">the</span> application once <span class="operator">the</span> connection  
    is established <span class="operator">with</span> <span class="operator">the</span> server <span class="keyword">else</span> returns <span class="operator">an</span> error <span class="built_in">number</span>.  
</code></pre><p>connect系统调用对应内核中的sys_connect()函数，具体的实现则在net/socket.c文件中。<br>connect主要调用流程如下：  </p>
<pre><code>SYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,  
                int, addrlen)  == sys_connect<span class="function"><span class="params">()</span>  
    =&gt;</span> sock = sockfd_lookup_light<span class="function"><span class="params">()</span>  
    =&gt;</span> err = move_addr_to_kernel<span class="function"><span class="params">()</span>  
    =&gt;</span> err = sock-&gt;ops-&gt;connect<span class="function"><span class="params">()</span>  == <span class="title">inet_stream_connect</span><span class="params">()</span>  
        =&gt;</span> Any state other <span class="keyword">then</span> SS_CONNECTED <span class="keyword">is</span> unacceptable <span class="keyword">for</span> processing<span class="function">  
        =&gt;</span> err = sk-&gt;sk_prot-&gt;connect<span class="function"><span class="params">(sk, uaddr, addr_len)</span>  == <span class="title">tcp_v4_connect</span><span class="params">()</span>  
            =&gt;</span> rt = ip_route_connect()  <span class="regexp">//</span> get the route <span class="keyword">for</span> the dst addr. All routing entries <span class="keyword">for</span> the system are hashed <span class="keyword">in</span> the <span class="built_in">global</span> table rt_hash_table[].<span class="function">    
            =&gt;</span> tcp_set_state<span class="function"><span class="params">(sk, TCP_SYN_SEND)</span>
            =&gt;</span> err = inet_hash_connect(&amp;tcp_death_row, sk);  <span class="regexp">//</span> 获得一个free的Port,流程与tcp_v4_get_port较类似<span class="function">  
                =&gt;</span> inet_get_local_port_range<span class="function"><span class="params">(&amp;low, &amp;high)</span>
                =&gt;</span> 遍历所有端口，对某个备选端口，遍历inet_bind_bucket确认是否有冲突。<span class="function">  
                =&gt;</span> 如果没有冲突，则tb = inet_bind_bucket_create()创建bind_bucket中的hash表项<span class="function">

            =&gt;</span> Until now we got the route to destination, <span class="keyword">and</span> obtained the local port number,  
               <span class="keyword">and</span> we have initialized remote address, remote port, local address, <span class="keyword">and</span> local address fields <span class="keyword">of</span> the socket.<span class="function">  

            =&gt;</span> err = tcp_connect(sk)  <span class="regexp">//</span> generate a SYN packet <span class="keyword">and</span> give it to the IP layer<span class="function">  
                =&gt;</span> tcp_connect_init(sk)  <span class="regexp">//</span> <span class="keyword">do</span> all connect socket setups that can be done AF independent<span class="function">  
                    =&gt;</span> tcp_select_initial_window() <span class="regexp">//</span> determine  a <span class="built_in">window</span> scaling <span class="keyword">and</span> initial <span class="built_in">window</span> to offer<span class="function">  
                =&gt;</span> buff = alloc_skb_fclone()  <span class="regexp">//</span> allocate a sk_buff structure, 细节在下一章再写<span class="function">  
                =&gt;</span> tcp_transmit_skb(sk, buff, <span class="number">1</span>, sk-&gt;sk_allocation)  <span class="regexp">//</span> 复制一份Buff，然后发送出去<span class="function">
                    =&gt;</span> skb = skb_clone(skb, gfp_mask)  <span class="regexp">//</span> 复制一份buff<span class="function">  
                    =&gt;</span> 初始化skb及TCP header<span class="function">  
                    =&gt;</span> tcp_options_write()  <span class="regexp">//</span> write previously computed tcp options to the packet<span class="function">  
                    =&gt;</span> icsk-&gt;icsk_af_ops-&gt;send_check(sk, skb)  == tcp_v4_send_check()  <span class="regexp">//</span> compute checksum<span class="function">
                    =&gt;</span> err = icsk-&gt;icsk_af_ops-&gt;queue_xmit()  == ip_queue_xmit()  <span class="regexp">//</span> transmit packet to IP layer<span class="function">  
        =&gt;</span> 至此已发送SYN包，然后等待SYN/ACK包从而完成三次握手<span class="function">  
        =&gt;</span> timeo = sock_sndtimeo<span class="function"><span class="params">(sk, flag * O_NONBLOCK)</span>
        =&gt;</span> inet_wait_for_connect(sk, timeo, writebias)  <span class="regexp">//</span> 完成三次握手的最后的工作  
</code></pre><h3 id="SUMMARY">SUMMARY</h3>
<p>摘录书中的原文如下  </p>
<pre><code>Protocol-specific operation one the socket <span class="keyword">is</span> accessed from prot field <span class="keyword">of</span> the sock object.  
<span class="keyword">For</span> the INET stream protocol, this field <span class="keyword">is</span> initialized <span class="keyword">to</span> tcp_prot.  

The tcp_hashinfo object has pointers <span class="keyword">to</span> different hash tables <span class="keyword">for</span> bind, established, <span class="keyword">and</span> listening sockets.  
    <span class="number">1.</span> tcp_bhash <span class="keyword">is</span> an object <span class="keyword">of</span> <span class="keyword">type</span> tcp_bind_hashbucket pointing <span class="keyword">to</span> bind hash table.  
       This table <span class="keyword">is</span> hased based ont the <span class="keyword">port</span> number sockets are bound <span class="keyword">to</span> them.  
    <span class="number">2.</span> ehash <span class="keyword">is</span> object <span class="keyword">of</span> <span class="keyword">type</span> tcp_ehash_bucket points <span class="keyword">to</span> established hash table. 
       Hashed <span class="keyword">on</span> the destination <span class="keyword">and</span> source <span class="keyword">port</span>/IP.
    <span class="number">3.</span> tcp_listenging_hash <span class="keyword">is</span> a hash table <span class="keyword">of</span> sock objects hashing <span class="keyword">all</span> the listenging sockets.  
       Hashed <span class="keyword">on</span> the listening <span class="keyword">port</span> number.  

tcp_bind_conflict() checks <span class="keyword">for</span> any conflicts related <span class="keyword">to</span> allocation <span class="keyword">of</span> <span class="keyword">port</span>.  
tcp_port_rover stores the last allocated <span class="keyword">port</span> number.  
tcp_listen_opt <span class="keyword">is</span> an object that keeps information about <span class="keyword">all</span> connection requests <span class="keyword">for</span> a listening socket.  
    sys_table field <span class="keyword">of</span> tcp_lisen_opt object <span class="keyword">of</span> <span class="keyword">type</span> open_request.  
    This hashes <span class="keyword">in</span> <span class="keyword">all</span> the connection requests <span class="keyword">for</span> the lisening socket.  

Once a three-way handshake <span class="keyword">is</span> over, the connection request <span class="keyword">is</span> moved from listeners SYN queue <span class="keyword">to</span> accept queue, tp-&gt;accept_queue  
[Important] sock <span class="keyword">and</span> tcp_opt objects are initialized <span class="keyword">for</span> the <span class="keyword">new</span> connection int the accept queue.  
[Important] Once an application accepts a connection request int the accept queue,  
            a BSD socket <span class="keyword">is</span> created <span class="keyword">for</span> the <span class="keyword">new</span> connection <span class="keyword">and</span> <span class="keyword">is</span> associated <span class="keyword">with</span> VFS.  

__tcp_v4_lookup_established() searches <span class="keyword">for</span> established connections <span class="keyword">in</span> the ehash table.  
tcp_v4_lookup_listener() searches <span class="keyword">for</span> listening sockets <span class="keyword">in</span> the tcp_listening_hash hash table.  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这一章主要学习TCP网络编程的几个关键函数：bind(),listen(),accept()和connect()。当然这里说的是这几个函数对应的systemcall的内核实现，并不是用户层怎么使用这些函数。同时还会介绍一些内核中与这些函数相关的数据结构。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo搭建博客]]></title>
    <link href="http://perthcharles.github.com/2014/11/04/change-to-hexo/"/>
    <id>http://perthcharles.github.com/2014/11/04/change-to-hexo/</id>
    <published>2014-11-04T06:55:07.000Z</published>
    <updated>2014-11-04T10:22:07.000Z</updated>
    <content type="html"><![CDATA[<p>本来只是觉着之前的主题代码快有点丑，开始寻找更好地显示代码块的方法。没想到找到了hexo这么给力的一个东西。看了几个博主的网站发现确实很好看，所以就下定决心开始折腾了。这篇博文就是记录我从jekyll换到hexo的一个过程。  </p>
<a id="more"></a>

<h3 id="必备软件">必备软件</h3>
<p>Node.js:直接打开<a href="http://nodejs.org/" target="_blank" rel="external">官网</a>，点击INSTALL即可下载安装包。官网能够识别你的电脑是不是MAC，这点还是蛮给力的。  </p>
<p>Git: 这个不会装的可以去面壁了。  </p>
<p>至于编辑markdown的软件的话，在MAC下当然是推荐Mou了，不过我还是喜欢直接在vim下编辑，vim重度患者没办法。  </p>
<h3 id="hexo主要安装过程及常用命令">hexo主要安装过程及常用命令</h3>
<pre><code><span class="preprocessor"># sudo -i                 // 先切换到root权限下</span>
<span class="preprocessor"># npm install -g hexo</span>
<span class="preprocessor"># cd my-blog-dir</span>
<span class="preprocessor"># hexo init               // 在该目录下初始化</span>
<span class="preprocessor"># hexo install            // 安装依赖包</span>
<span class="preprocessor"># hexo new post "test"    // 新建一个空白post</span>
<span class="preprocessor"># hexo generate           // 生成静态页面</span>
<span class="preprocessor"># hexo server             // 启动本地预览服务</span>

<span class="preprocessor"># hexo g == hexo generate</span>
<span class="preprocessor"># hexo d == hexo deploy   // 将仓库部署到在config文件中指定的repo中  </span>
<span class="preprocessor"># hexo s == hexo server</span>
<span class="preprocessor"># hexo n == hexo new</span>
<span class="preprocessor"># hexo deploy -g          // deploy + generate</span>
<span class="preprocessor"># hexo server -g          // server + generate</span>
<span class="preprocessor"># hexo deploy -m "msg"    // custom message</span>
</code></pre><p>如果任何一步遇到问题，可自行Google。当然看看<a href="http://hexo.io/docs/index.html" target="_blank" rel="external">官网的文档</a>也是必要的。<br>参考资料中一些博主的博文也是很好的guide。  </p>
<h3 id="常用的技巧">常用的技巧</h3>
<p>markdown语法还是有必要学一学的，不过很简单请放心。  </p>
<p>向Google提交sitemap：<a href="http://fionat.github.io/blog/2013/10/23/sitemap/" target="_blank" rel="external">如何向google提交sitemap</a>  </p>
<p>hexo的作者提示过，使用四个空格的方式标志的代码块是没有行号的，需要行号的请使用三个反引号的形式。  </p>
<p>hexo does not watch for configuration file changes. You have to restart hexo to make the new configurations take effects.  </p>
<p>添加RSS和sitemap  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># npm <span class="operator"><span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span></div><div class="line"># vim _config.yml</div><div class="line">    Plugins:</div><div class="line">    - hexo-generator-feed</div><div class="line">    - hexo-generator-sitemap</div><div class="line">    sitemap:</div><div class="line">      path: sitemap.<span class="keyword">xml</span></div><div class="line">    feed:</div><div class="line">      type: atom</div><div class="line">      path: atom.<span class="keyword">xml</span></div><div class="line">      <span class="keyword">limit</span>: <span class="number">20</span></div></pre></td></tr></table></figure>



<p>可以用下面这句话在markdown文件中分隔摘要  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--more--&gt;</span></div></pre></td></tr></table></figure>


<p>更多plugins，可以查看<a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">官方文档</a>。  </p>
<p>由于我之前就用disqus管理博客的留言，所以直接在_config.yml文件中配置好disqus_shortname即可。  </p>
<p>觉得默认主题的recent部分显示的数量较少的话，可以修改themes/landscape/layout/_widget/recent_posts.ejs文件  </p>
<p>tag的话，直接使用tag cloud就比较好了，所以我去掉了tags的详细显示，方法就是直接注释掉landscape主题的配置文件中对应的tag行。  </p>
<p>配置访问统计，直接将之前的统计代码写进_widget/count.ejs后，在config文件中配置好即可。  </p>
<p>添加about页面  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># hexo new page "about"</span></div><div class="line"><span class="preprocessor"># vim source/about/index.md  // 编辑index.md页面</span></div><div class="line"><span class="preprocessor"># vim themse/landscape/_config.yml  </span></div><div class="line">    menu:</div><div class="line">      About: /about  <span class="comment">//添加该行</span></div></pre></td></tr></table></figure>



<hr>
<h3 id="未完成">未完成</h3>
<p>使用图床加速带图片的网页，比如七牛，又拍云。  </p>
<p>添加友情链接widget  </p>
<p>购买自己的域名  </p>
<p>设置404页面  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">hexo你的博客</a><br><a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客</a><br><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">Zipperary的hexo系列教程</a><br><a href="http://hexo.io/docs/index.html" target="_blank" rel="external">Hexo官方文档</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本来只是觉着之前的主题代码快有点丑，开始寻找更好地显示代码块的方法。没想到找到了hexo这么给力的一个东西。看了几个博主的网站发现确实很好看，所以就下定决心开始折腾了。这篇博文就是记录我从jekyll换到hexo的一个过程。  </p>
]]>
    
    </summary>
    
      <category term="hexo" scheme="http://perthcharles.github.com/tags/hexo/"/>
    
      <category term="博客搭建" scheme="http://perthcharles.github.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(3): Implementation of Sockets]]></title>
    <link href="http://perthcharles.github.com/2014/10/23/tcp-design-and-implementation-3/"/>
    <id>http://perthcharles.github.com/2014/10/23/tcp-design-and-implementation-3/</id>
    <published>2014-10-23T14:29:08.000Z</published>
    <updated>2014-12-01T13:06:32.000Z</updated>
    <content type="html"><![CDATA[<p>这章主要从socket()系统调用入手，介绍socket建立时初始化的一些重要数据结构。熟练掌握这些数据结构和他们之间的关系能够有效的帮助理解代码，所以这部分随着理解的加深，随时需要补充和完善。  </p>
<a id="more"></a>

<p>首先是，sock结构体，是network layer对于socket的表示。结构体定义在include/net/sock.h中，主要需要理解的结构元素如下：  </p>
<pre><code>// sock_common是第一个内嵌的结构体，是于inet_timewait_sock共享的layout  
struct    sock_common        __sk_common;  
<span class="keyword">...</span>  
struct    sk_buff_head    sk_receive_queue;    // 接收队列，注意是skb head的队列  
<span class="keyword">...</span>  
int                        sk_forward_alloc;    // 预分配的空间  
<span class="keyword">...</span>  
int                        sk_rcvbuf;            // 接收buf的大小（Bytes）  
<span class="keyword">...</span>  
atomic_t                sk_wmem_alloc;        // 传输队列中已committed的字节数
atomic_t                sk_omem_alloc;        // <span class="string">'o'</span> 表示 other
int                        sk_sndbuf;            // 发送buf的大小（Bytes）  
struct    sk_buff_head    sk_write_queue;        // 数据包的发送队列  
<span class="keyword">...</span>  
int                        sk_wmem_queue;        // persistent 队列大小
gfp_t                    sk_allocation;        // allocation mode
u32                        sk_pacing_rate;        // pacing rate(Bps，<span class="keyword">if</span> supported by transport/packet scheduler)  
<span class="keyword">...</span>  
struct    sk_buff_head    sk_error_queue;        // queue of defactive packets  
<span class="keyword">...</span>  
long                    sk_rcvtimeo;        // 判断接收超时的上限  
long                    sk_sndtimeo;        // 判断发送超时的上限  
<span class="keyword">...</span>  
struct                    *sk_send_head;        // 指向下一个应该发送的skb
int                     sk_write_pending;    // a write to stream socket waits to start  
<span class="keyword">...</span>  
</code></pre><p>然后是inet_sock。sock结构体是inet_sock的第一个元素，然后inet_sock中包含了一些TTL，IP和Port等信息。结构体的定义在include/net/inet_sock.h中。  </p>
<p>再接着就是inet_connection_sock。inet_sock是inet_connection_sock的第一个元素，然后从字面理解也可以看出inet_connection_sock相比于inet_sock添加了一些面向connection的信息。主要元素如下：  </p>
<pre><code>struct    inet_sock        icsk_inet;
<span class="keyword">...</span>  
struct    timer_list        icsk_retransmit_timer;    // resend (no ack)  
__u32                    icsk_rto;                  // retransmit timeout  
<span class="keyword">...</span>  
const    struct tcp_congestion_ops    *icsk_ca_ops; // 拥塞控制算法hook  
__u8                    icsk_ca_state;              // 拥塞控制的状态  
</code></pre><p>最后就是TCP最相关的，tcp_sock结构体。类似的，inet_connection_sock是tcp_sock的第一个元素。主要元素如下：  </p>
<pre><code><span class="keyword">struct</span>    inet_connection_sock    inet_conn;  
...  
<span class="comment">/* RFC793 and RFC1122 are the best references for this */</span>
<span class="keyword">u32</span>        rcv_nxt;                <span class="comment">// what we want to receive next  </span>
<span class="keyword">u32</span>        copied_seq;                <span class="comment">// Head of yet unread data  </span>
<span class="keyword">u32</span>        snd_nxt;                <span class="comment">// next sequence we send  </span>
<span class="keyword">u32</span>        snd_una;                <span class="comment">// first byte we want an ack for  </span>
...  
<span class="keyword">u32</span>        rcv_tstamp;                <span class="comment">// timestamp of last rcv ack (for keepalives)  </span>
<span class="keyword">u32</span>        lsndtime;                <span class="comment">// timestamp of last snd pkt (for restart window)  </span>
...  
<span class="keyword">u32</span>        snd_wnd;                <span class="comment">// the window we expect to receive  </span>
<span class="keyword">u32</span>        max_window;                <span class="comment">// maximal window ever seen from peer  </span>
<span class="keyword">u32</span>        window_clamp;            <span class="comment">// maximal window to advertise  </span>
<span class="keyword">u32</span>        rcv_ssthresh;            <span class="comment">// current window clamp  </span>
u16        advmss;                    <span class="comment">// advertised MSS  </span>

<span class="comment">/* RTT measurement */</span>
<span class="keyword">u32</span>        srtt;                    <span class="comment">// smoothed RTT &lt;&lt; 3  </span>
<span class="keyword">u32</span>        mdev;                    <span class="comment">// medium deviation  </span>
<span class="keyword">u32</span>        mdev_max;                <span class="comment">// maximal mdev for the last rtt period  </span>
<span class="keyword">u32</span>        rttvar;                    <span class="comment">// smoothed mdev_max  </span>
<span class="keyword">u32</span>        rtt_seq;                <span class="comment">// sequence number to update rttvar  </span>

<span class="keyword">u32</span>        packets_out;            <span class="comment">// packets which are "in_flight"  </span>
<span class="keyword">u32</span>        retrans_out;            <span class="comment">// retransmitted packets out  </span>
...  

<span class="comment">/* Slow start and congestion control */</span>
<span class="keyword">u32</span>        snd_ssthresh;            <span class="comment">// slow start size threshold  </span>
<span class="keyword">u32</span>        snd_cwnd;                <span class="comment">// sending congestion window, 注意与snd_wnd区分开  </span>
<span class="keyword">u32</span>        snd_cwnd_cnt;            <span class="comment">// linear increase counter  </span>
<span class="keyword">u32</span>        snd_cwnd_clamp;            <span class="comment">// snd_cwnd的上限  </span>
<span class="keyword">u32</span>        snd_cwnd_used;
<span class="keyword">u32</span>        snd_cwnd_stamp;
<span class="keyword">u32</span>        prior_cwnd;                <span class="comment">// Recovery 开始时的cwnd值  </span>
<span class="keyword">u32</span>        prr_delivered;            <span class="comment">// # of newly delivered pkts in Recovery  </span>
<span class="keyword">u32</span>        prr_out;                <span class="comment">// # of total sent pkts during Recovery  </span>

<span class="keyword">u32</span>        rcv_wnd;                <span class="comment">// current receiver window, 表示的是自己作为receiver时的window大小，用于通知对方  </span>

<span class="keyword">struct</span> sk_buff *highest_sack;    <span class="comment">// skb just after the highest skb with SACKed bit set  </span>
...  
<span class="keyword">u32</span>        retransmit_high;
<span class="keyword">u32</span>        lost_retrans_low;
<span class="keyword">u32</span>        prior_ssthresh;            <span class="comment">// ssthresh saved at Recovery start  </span>
<span class="keyword">u32</span>        high_seq;  
<span class="keyword">u32</span>        retrans_stamp;            <span class="comment">// timestamp of the last retransmit  </span>
<span class="keyword">u32</span>        uodo_marker;            <span class="comment">// tracking retrans started here  </span>
<span class="keyword">int</span>     undo_retrans;            <span class="comment">// number of undoable retransmissions  </span>
<span class="keyword">u32</span>        total_retrans;            <span class="comment">// total retransmits for entire connection  </span>
</code></pre><h3 id="总结">总结</h3>
<p>可以看出来，这些结构体是一个嵌套一个的形式被定义，个人感觉很像C++中类继承时的内存分布状况。下面是书中总结的一段，觉得很好，就直接摘录了。  </p>
<pre><code>There are <span class="constant">two</span> levels <span class="operator">of</span> <span class="built_in">socket</span> abstraction. At <span class="operator">the</span> top is <span class="operator">the</span> BSD  
<span class="built_in">socket</span> layer defined <span class="keyword">as</span> struct <span class="built_in">socket</span> <span class="operator">and</span> <span class="keyword">then</span> protocol-specific  
<span class="built_in">socket</span> defined <span class="keyword">as</span> sturct sock.  
    <span class="number">1.</span> sock_register() is <span class="operator">an</span> interface <span class="built_in">to</span> register BSD sockets <span class="keyword">for</span>
    different net families. For INET family, inet_family_ops <span class="operator">of</span>  
    type net_proto_family is registered.  
    <span class="number">2.</span> net_families is <span class="operator">a</span> <span class="built_in">global</span> array <span class="built_in">to</span> indexed <span class="command"><span class="keyword">on</span> <span class="title">net</span> <span class="title">family</span></span>
    <span class="built_in">number</span>. Net family sockets are registered <span class="operator">with</span> this table.  
    <span class="number">3.</span> inet_register_protose() is <span class="operator">an</span> interface <span class="built_in">to</span> register  
    protocol supported <span class="keyword">by</span> <span class="operator">the</span> INET family. These protocols  
    are TCP, UDP <span class="operator">and</span> RAW.  
    <span class="number">4.</span> inetsw_array is <span class="operator">a</span> <span class="built_in">global</span> table that registers <span class="operator">the</span>  
    INET family protocols, object <span class="operator">of</span> type inet_protosw.  
    <span class="number">5.</span> inet_stream_ops is <span class="built_in">set</span> <span class="operator">of</span> operation <span class="keyword">for</span> INET stream BSD  
    <span class="built_in">socket</span>, <span class="operator">and</span> tcp_prot is <span class="operator">a</span> protocol-specific <span class="built_in">set</span> <span class="operator">of</span> operations  
    TCP sockets.  
</code></pre><p>最后结合Linux v3.10的代码梳理一下，sys-socket()中暂时感兴趣的major rountines.  </p>
<pre><code>socket() [User Space] 等价于 sys_socket() [Kernel Space]
__________________________________________________________________
SYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)  <span class="comment">// net/socket.c</span>
    =&gt; sock_create() <span class="comment">// 在net/socket.c文件中  </span>
        =&gt; sock = sock_alloc()  <span class="comment">// allocate the BSD socket</span>
        =&gt; pf = rcu_dereference(net_families[family]);  <span class="comment">// 根据family值，得到struct net_proto_family结构体  </span>
        =&gt; pf<span class="variable">-&gt;create</span>() = inet_create()  <span class="comment">// PF_INET对应的定义在net/ipv4/af_inet.c中  </span>
            =&gt; 遍历inetsw <span class="keyword">list</span>，如果protocol没设置，则默认会匹配成IPPROTO_TCP
            =&gt; sock<span class="variable">-&gt;ops</span> = answer<span class="variable">-&gt;ops</span>  <span class="comment">// 设置sock-&gt;ops = &amp;inet_stream_ops</span>
            =&gt; sk = sk_alloc()  <span class="comment">// 分配struct sock结构体，传递了tcp_prot结构体地址作为参数，所以一次性分配了整个tcp_sock结构体大小的内存空间  </span>
            =&gt; sock_init_data()  <span class="comment">// 完成sock结构体的初始化，把sock与socket关联</span>

            =&gt; sk<span class="variable">-&gt;sk_prot</span><span class="variable">-&gt;init</span>() = tcp_v4_init_sock()    
                =&gt; tcp_init_sock()  <span class="comment">// 完成tcp_sock结构体的初始化</span>
    =&gt; sock_map_fd()  <span class="comment">// bind sock with fd</span>
        =&gt; fd = get_unused_fd_flags()
        =&gt; newfile = sock_alloc_file()  <span class="comment">// create file 结构体，并于socket关联</span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这章主要从socket()系统调用入手，介绍socket建立时初始化的一些重要数据结构。熟练掌握这些数据结构和他们之间的关系能够有效的帮助理解代码，所以这部分随着理解的加深，随时需要补充和完善。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(2): Protocol Fundamentals]]></title>
    <link href="http://perthcharles.github.com/2014/10/23/tcp-design-and-implementation-2/"/>
    <id>http://perthcharles.github.com/2014/10/23/tcp-design-and-implementation-2/</id>
    <published>2014-10-23T09:29:08.000Z</published>
    <updated>2014-11-03T14:33:30.000Z</updated>
    <content type="html"><![CDATA[<p>这章主要还是基础知识的介绍，更加详细的介绍TCP/IP相关协议。  </p>
<a id="more"></a>

<p>经典的TCP header构成剖析。需要注意的就是header len只有4bits，因此最长支持60B（15*4B）  </p>
<pre><code>Src port: 16<span class="built_in">bits</span>      Dst port: 16<span class="built_in">bits</span>  
Seq num: 32<span class="built_in">bits</span>  
Ack num: 32<span class="built_in">bits</span>  
Header len: 4<span class="built_in">bits</span>     Unused: 6<span class="built_in">bits</span>    Flags: 6<span class="built_in">bits</span>  
<span class="label">Rwnd:</span> 16<span class="built_in">bits</span>  
Check sum: 16<span class="built_in">bits</span>    Urgent pointers: 16<span class="built_in">bits</span>  
</code></pre><p>TCP Options (RFC 1323)  </p>
<pre><code>标准的option格式：  Kind(<span class="number">1</span>B) | Len(<span class="number">1</span>B) | Value(Variable length)  
常见option:  
<span class="number">1</span>. End of Option List:   | <span class="variable">kind =</span> <span class="number">0</span> |  
<span class="number">2</span>. No operation:         | <span class="variable">kind =</span> <span class="number">1</span> |  &lt;== 用于内存对齐  
<span class="number">3</span>. MSS:                  | <span class="variable">kind =</span> <span class="number">2</span> | <span class="variable">length =</span> <span class="number">4</span> | <span class="variable">mss =</span> <span class="number">2</span>B |  
<span class="number">4</span>. Window-Scaling:       | <span class="variable">kind =</span> <span class="number">3</span> | <span class="variable">length =</span> <span class="number">3</span> | left shift <span class="variable">count =</span> <span class="number">1</span>B |  
<span class="number">5</span>. SACK-permit:          | <span class="variable">kind =</span> <span class="number">4</span> | <span class="variable">lenght =</span> <span class="number">2</span> |
<span class="number">6</span>. SACK:                 | <span class="variable">kind =</span> <span class="number">5</span> | <span class="variable">length =</span> variable | <span class="variable">Start =</span> <span class="number">4</span>B | <span class="variable">End =</span> <span class="number">4</span>B | ...  
<span class="number">7</span>. Timestamp:            | <span class="variable">kind =</span> <span class="number">8</span> | <span class="variable">length =</span> <span class="number">10</span>| <span class="variable">TS =</span> <span class="number">4</span>B | TS <span class="variable">echo =</span> <span class="number">4</span>B |  
</code></pre><p>书中较大的篇幅介绍了TCP的ACK机制，这里正常的ACK就不展开了，而是更关注书中提到的Delayed ACK和Nagle算法.前者通过在ACK包中携带数据避免small ack packet，后者是为了进一步避免发送数据太少导致small packet。  </p>
<pre><code>Nagle<span class="attribute">'s</span> algorithm: <span class="keyword">all</span> the data that need <span class="keyword">to</span> be sent <span class="keyword">out</span> are  
collected <span class="keyword">until</span> the <span class="typename">time</span> we receive an ACK <span class="keyword">for</span> the last sent data.  
</code></pre><p>Sliding Window 机制就是rwnd的限制导致的，rwnd的存在是为了做flow control。另外cwnd的存在则是为了做congestion control。  </p>
<p>TCP Timers是一个很重要的部分，常见的计时器有一下几种：  </p>
<pre><code><span class="number">1.</span> Retransmission <span class="built_in">Timer</span>: 如果一个包在该计时器超时之前都没有收到ACK，则触发超时重传  
<span class="number">2.</span> Persistent <span class="built_in">Timer</span>: 为了应对rwnd=<span class="number">0</span>后，接收方发送通知rwnd&gt;<span class="number">0</span>的包丢失的情况。  
    具体就是发送发使用指数规避的方式增加persistent <span class="built_in">timer</span>，  
    每次<span class="built_in">timer</span>结束的时候发送一个不带数据的包试探对方的rwnd.  
<span class="number">3.</span> Keepalive <span class="built_in">Timer</span>: 看名字就理解了，不解释  
<span class="number">4.</span> TIME_WAIT <span class="built_in">Timer</span>: TCP状态转换机制中的一个重要结束状态  
</code></pre><p>FACK如果启用，则认为SACK数据块之间空隙的包都丢失了，默认开启；DSACK是SACK的一个扩展。  </p>
<pre><code>DSACK is generated when both <span class="operator">the</span> original <span class="operator">and</span> retransmission   
reach <span class="operator">the</span> receiver. This gives us <span class="operator">an</span> indication that we have   
falsely entered <span class="keyword">into</span> <span class="operator">the</span> fast retransmission <span class="operator">and</span> fast recovery   
phase because <span class="operator">the</span> packet got delayed <span class="operator">in</span> <span class="operator">the</span> network <span class="operator">or</span> because   
<span class="operator">of</span> excessive reordering.  
</code></pre><p>IP及以下层相关的内容暂忽略。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这章主要还是基础知识的介绍，更加详细的介绍TCP/IP相关协议。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(1): Introduction]]></title>
    <link href="http://perthcharles.github.com/2014/10/22/tcp-design-and-implementation/"/>
    <id>http://perthcharles.github.com/2014/10/22/tcp-design-and-implementation/</id>
    <published>2014-10-22T09:29:08.000Z</published>
    <updated>2014-11-03T14:36:37.000Z</updated>
    <content type="html"><![CDATA[<p>今天开始好好研究TCP/IP的Linux实现，结合书和代码希望自己能对TCP这块更加的熟悉。读Kernel代码还是功利性强一点比较好，比如这次我是由于毕设相关才来仔细研究TCP这块的具体实现的。没有目的性的看这种大块头项目，效率比较难保障。Anyway，这个系列也是看到那块记录哪块，用以加强自己的理解。题目中的ADI分别是Architecture, Design, Implementation。书就是下面这一本了，英文的比较带劲，:)  </p>
<pre><code>《TCP/IP ARCHITECTURE, DESIGN, <span class="keyword">AND</span> <span class="keyword">IMPLEMENTATION</span> <span class="keyword">IN</span> LINUX》 <span class="keyword">by</span> Sameer Seth   
</code></pre><a id="more"></a>

<h2 id="Introduction">Introduction</h2>
<hr>
<p>读这种大块头的项目时，首先应该首先熟悉代码的框架，而不是立马dive into source code。这方面有许多优秀的工具能帮助我们了解代码的框架，这里推荐<a href="https://scitools.com/" target="_blank" rel="external">understand</a>. 顺带吐槽一下，个人觉得这款软件远没有<a href="http://www.sourceinsight.com/" target="_blank" rel="external">source insight</a>闻名的主要原因就是这软件的名字。  </p>
<pre><code>Once we know how <span class="operator">the</span> code is distributed, <span class="keyword">it</span> becomes  
easier <span class="built_in">to</span> find out <span class="operator">the</span> relevant code <span class="operator">in</span> which we are interested.  
</code></pre><p>几乎所有的网络应用都是基于基础的client-server框架的，后续的优化主要是为了做到更好地安全性，负载均衡等。  </p>
<p>在Linux中，sk_buff结构体包含一个packet的所有相关信息，把sk_buff理解为TCP packet在Linux中的表示也不为过。  </p>
<p>1.1.1 Moving Down the Stack是一个很好了解TCP/IP栈发包过程的简要描述  </p>
<p>1.1.2 Moving Up the Stack则是收包过程的简要描述  </p>
<p>Linux的设计上，user-space is preemptible, kernel is non-preemptible.  </p>
<p>关于Linux基础知识的介绍，这里就不再解释了。比如system_call, process &amp; thread, user space &amp; kernel space，以及各种锁。  </p>
<p>1.7给出了一个典型的client-server程序例子，主要就是需要了解那几个重要函数的用法：socket(), bind(), listen(), accept(), connect() 以及setsockopt()和getsockopt()。这里有一个不错的资料：<a href="http://man.chinaunix.net/develop/c&amp;c++/linux_c/default.htm" target="_blank" rel="external">Linux C function参考手册</a>。  </p>
<p>socket I/O有blocking和non-blocking之分，I/O复用有select(), poll(), epoll()之分，不熟悉的请移步Google.  </p>
<p>TCP状态转换机制可以看TCP/IP详解的卷一中的插图，正常流程没什么好说的。关键在于一些特殊情况的分析，比如TIME_WAIT。  </p>
<pre><code>设置TIME_WAIT状态的原因：  
<span class="bullet">1. </span>如果最后一个ACK丢失了，需要接受对方重新发送的FIN包并确认；  
<span class="bullet">2. </span>防止两个完全一样的流overlap。  
</code></pre><h4 id="总结">总结</h4>
<p>这章主要介绍一些理解与TCP相关的一些Linux机制和基础知识，读下来还是比较顺利的。OK，what’s next ?  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天开始好好研究TCP/IP的Linux实现，结合书和代码希望自己能对TCP这块更加的熟悉。读Kernel代码还是功利性强一点比较好，比如这次我是由于毕设相关才来仔细研究TCP这块的具体实现的。没有目的性的看这种大块头项目，效率比较难保障。Anyway，这个系列也是看到那块记录哪块，用以加强自己的理解。题目中的ADI分别是Architecture, Design, Implementation。书就是下面这一本了，英文的比较带劲，:)  </p>
<pre><code>《TCP/IP ARCHITECTURE, DESIGN, <span class="keyword">AND</span> <span class="keyword">IMPLEMENTATION</span> <span class="keyword">IN</span> LINUX》 <span class="keyword">by</span> Sameer Seth   
</code></pre>]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Install windows 7 into a ubuntu server]]></title>
    <link href="http://perthcharles.github.com/2014/06/18/double-boot-win7-and-ubuntu/"/>
    <id>http://perthcharles.github.com/2014/06/18/double-boot-win7-and-ubuntu/</id>
    <published>2014-06-18T04:00:00.000Z</published>
    <updated>2014-11-04T06:47:15.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Backgrounds">Backgrounds</h2>
<p>As a windows client is needed for my testbed, I have to install windows system into a server which is runing a ubuntu os already.<br>This post is mainly a remainder for the encountered problems while I was installing win7.  </p>
<a id="more"></a>

<h2 id="Problems">Problems</h2>
<ul>
<li><a href="#nic">[win7]Unrecognized NIC</a>  </li>
<li><a href="#net">[win7]Network connection</a>  </li>
<li><a href="#cygwin">[win7]Cygwin and ssh</a>  </li>
<li><a href="#lvm">[ubuntu]LVM</a>  </li>
<li><a href="#grub">restore grub2</a>  </li>
<li><a href="#setup">grub setup</a>  </li>
</ul>
<hr>
<p><h3 id="nic">[win7]Unrecognized NIC</h3><br>The unrecognized NICs are mainly caused by missed drivers.<br>So this problem can easily fixed via installations of missed drivers.<br>If you needs to find out the info for the NICs, the following commands are what you are looking for.  </p>
<pre><code><span class="variable">$ethtool</span> eth<span class="number">0</span>
<span class="variable">$lspci</span> |<span class="keyword">grep</span> -i ether
<span class="variable">$dmesg</span> |<span class="keyword">grep</span> -i eth
</code></pre><p><h3 id="net">Network  connection</h3><br>As four NICs are used in my server, some for internets and some for inter-connections, DNS and IPs need to be configured manually.<br>The related info can be found in the following files:  </p>
<pre><code>$vim <span class="regexp">/etc/</span>resolv.conf   <span class="comment">//DNS server</span>
$vim <span class="regexp">/etc/</span>sysconfig<span class="regexp">/network-scripts/i</span>fcfg-eth0  <span class="comment">//CentOS</span>
$vim <span class="regexp">/etc/</span>network<span class="regexp">/interfaces /</span><span class="regexp">/Ubuntu</span>
</code></pre><p><h3 id="cygwin">Cygwin and ssh</h3><br>In my testbed, all the tasks supposed to be executed automaticly. Therefore a command-line workspace is required in win7 and I choose Cygwin in here.<br>Here are some excellent tutorials which helps me a lot.  </p>
<ul>
<li><a href="https://cygwin.com/install.html" target="_blank" rel="external">Cygwin Homepage</a>  </li>
<li><a href="https://code.google.com/p/apt-cyg/" target="_blank" rel="external">apt-cyg: A command-line software installer for Cygwin</a>  </li>
<li><a href="http://www.howtogeek.com/howto/41382/" target="_blank" rel="external">How to use linux commands in windows with Cygwin</a>  </li>
<li><p><a href="http://www.howtogeek.com/howto/41560/" target="_blank" rel="external">How to get ssh command-line access to windows 7 using Cygwin</a><br>Because the ssh key in Cygwin is different with the original key in ubuntu, I choose to disable the host key checking for my server.  </p>
<p>  $vim ~/.ssh/config  // if this file doesn’t exist, create it<br>  $cat ~/.ssh/config<br>  Host ip-of-my-server</p>
<pre><code>  <span class="title">StrictHostKeyChecking</span> <span class="built_in">no</span>
</code></pre></li>
</ul>
<p><h3 id="lvm">LVM</h3><br>When trying to restore grub after the win7 installed,<br>There are several methods mentioned in this <a href="https://help.ubuntu.com/community/Grub2/Installing#Reinstalling_GRUB_2" target="_blank" rel="external">document</a> from ubuntu community. But I still cann’t restore the grub until I find this <a href="http://typethinker.blogspot.com/2009/12/reinstalling-grub-with-lvm-from-ubuntu.html" target="_blank" rel="external">post</a>. The main reason is that my ubuntu is install inside a <a href="http://en.wikipedia.org/wiki/Logical_Volume_Manager_(Linux\" target="_blank" rel="external">LVM</a>) partition.<br>Here are some relative commands.  </p>
<pre><code><span class="variable">$lvdisplay</span>  // <span class="literal">show</span> logical volumes
<span class="variable">$vgdisplay</span>  // <span class="literal">show</span> volume groups
<span class="variable">$pvdisplay</span>  // <span class="literal">show</span> physical volumes
</code></pre><p><h3 id="grub">Restore grub2</h3><br>Here is my steps to restore grub2:  </p>
<pre><code>1. Boot the ubuntu LiveCD, <span class="operator"><span class="keyword">select</span> <span class="string">"Try it"</span>, <span class="keyword">and</span> <span class="keyword">open</span> a terminal  
<span class="number">2.</span> <span class="keyword">Use</span> fdisk <span class="keyword">to</span> <span class="keyword">help</span> determine the <span class="keyword">partition</span> <span class="keyword">on</span> which ubuntu <span class="keyword">is</span> installed  
    #fdisk -l
<span class="number">3.</span> <span class="keyword">Install</span> LVM
    $apt-<span class="keyword">get</span> <span class="keyword">install</span> lvm2
    $vgdisplay                // find name <span class="keyword">of</span> volume <span class="keyword">group</span>
    $vgchange -ay name-<span class="keyword">of</span>-vg  // make volume <span class="keyword">group</span> available
<span class="number">4.</span> Mount root <span class="keyword">and</span> boot file systems
    $mount /dev/name-<span class="keyword">of</span>-vg/name-<span class="keyword">of</span>-root-lv /mnt
    $mount /dev/name-<span class="keyword">of</span>-boot-<span class="keyword">partition</span> /mnt/boot
<span class="number">5.</span> <span class="keyword">Install</span> grub2
    $grub-<span class="keyword">install</span> <span class="comment">--boot-directory=/mnt/boot /dev/name-of-root-device</span>
<span class="number">6.</span> Reboot <span class="keyword">and</span> <span class="keyword">update</span>-grub
    $reboot
    $<span class="keyword">update</span>-grub</span>
</code></pre><p>Until now the grub for ubuntu is restore.  </p>
<p><h3 id="setup">Grub setup</h3><br>Q: How to boot into into win7 from ubuntu for only once ?<br>A: grub-reboot is the tool you are looking for. <a href="http://askubuntu.com/questions/18170/how-to-reboot-into-windows-from-ubuntu" target="_blank" rel="external">This post</a> is a related question in askubuntu.com. Here are the configuration steps:  </p>
<pre><code>$vim /etc/default/grub
    modify GRUB_DEFAULT=0 to GRUB_DEFAULT=saved
$<span class="operator"><span class="keyword">update</span>-grub
$grub-reboot X
    X <span class="keyword">is</span> the menuentry <span class="keyword">position</span> <span class="keyword">of</span> the OS you want <span class="keyword">to</span> boot <span class="keyword">into</span> <span class="keyword">for</span> the <span class="keyword">next</span> <span class="keyword">time</span> <span class="keyword">and</span> the <span class="keyword">next</span> <span class="keyword">time</span> <span class="keyword">only</span>.
$reboot</span>
</code></pre><p>There is a little bug in my grub that the timeout isn’t working properly.<br>My solution is modify the grub.cfg file according to <a href="http://askubuntu.com/questions/202309/cannot-get-grub-menu-to-timeout-or-go-away" target="_blank" rel="external">this-post</a> and <a href="http://dietrichschroff.blogspot.com/2014/03/ubuntu-upgrade-to-1204-grub-timeout.html" target="_blank" rel="external">this-post</a>.  </p>
<p>Until now, the server has become a perfect double-boot server. Cheers! :)  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Backgrounds">Backgrounds</h2>
<p>As a windows client is needed for my testbed, I have to install windows system into a server which is runing a ubuntu os already.<br>This post is mainly a remainder for the encountered problems while I was installing win7.  </p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="ubuntu" scheme="http://perthcharles.github.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Analysis tools for network traces]]></title>
    <link href="http://perthcharles.github.com/2014/06/16/tcpdump-tcptrace-tshark/"/>
    <id>http://perthcharles.github.com/2014/06/16/tcpdump-tcptrace-tshark/</id>
    <published>2014-06-16T04:00:00.000Z</published>
    <updated>2014-11-04T06:48:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Overview">Overview</h2>
<p><a href="http://www.tcpdump.org/" target="_blank" rel="external">tcpdump</a>: capture network packets by specific filters<br><a href="http://www.tcptrace.org/" target="_blank" rel="external">tcptrace</a>: a tool for analysis of tcp dump files, like <a href="http://www.tcpdump.org/manpages/pcap.3pcap.html" target="_blank" rel="external">pcap</a><br><a href="http://tcptrace.org/jPlot/" target="_blank" rel="external">jplot</a>: a java version of <a href="http://www.xplot.org/" target="_blank" rel="external">xplot</a><br>补充一下tshark也是一个不错的工具，是wireshark的terminal版本，功能同样强大。  </p>
<a id="more"></a>

<h2 id="Install_&amp;_Usage">Install &amp; Usage</h2>
<h3 id="TCPDUMP">TCPDUMP</h3>
<pre><code><span class="variable">$yum</span> install tcpdump  <span class="comment">// My OS is CentOS 6.5</span>
<span class="variable">$tcpdump</span> -w example.pcap -i eth0 -n  
</code></pre><p><a href="http://www.tcpdump.org/manpages/tcpdump.1.html" target="_blank" rel="external">Here</a> is the manpage of tcpdump with lots of examples.  </p>
<h3 id="TCPTRACE">TCPTRACE</h3>
<pre><code><span class="variable">$yum</span> install tcptrace
<span class="variable">$tcptrace</span> -R example.pcap  // produce data <span class="keyword">for</span> RTT graph
</code></pre><p><a href="http://www.tcptrace.org/manual/index.html" target="_blank" rel="external">Here</a> is the manpage of tcptrace.  </p>
<h3 id="JPLOT">JPLOT</h3>
<p>Install  </p>
<pre><code><span class="variable">$wget</span> http:<span class="comment">//www.tcptrace.org/jPlot/download/jPlot-1.0.2.tar.gz</span>
<span class="variable">$tar</span> zxvf jPlot-<span class="number">1.0</span><span class="number">.2</span>.tar.gz
<span class="variable">$cd</span> jPlot-<span class="number">1.0</span><span class="number">.2</span>
<span class="variable">$yum</span> install java-devel   <span class="comment">// install javac</span>
<span class="variable">$.</span>/configure
<span class="variable">$make</span>
</code></pre><p>Usage  </p>
<pre><code><span class="variable">$java</span> jPlot a2b_rtt.xpl
</code></pre><p><a href="http://tcptrace.org/jPlot/" target="_blank" rel="external">Here</a> is the manpage of jPlot.  </p>
<h2 id="Others">Others</h2>
<p>If you are familiar with <a href="http://www.gnuplot.info/" target="_blank" rel="external">gnuplot</a>, I think <a href="http://tcptrace.org/xpl2gpl/" target="_blank" rel="external">xpl2gpt</a> is a good shell scripts for you.  </p>
<h3 id="Examples">Examples</h3>
<pre><code><span class="variable">$tcpdump</span> -w example.pcap -i eth0 -n
<span class="variable">$tcptrace</span> -R example.pcap
<span class="variable">$xpl2gpl</span> a2b_rtt.xpl
<span class="variable">$gnuplot</span> a2b_rtt.gpl
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Overview">Overview</h2>
<p><a href="http://www.tcpdump.org/" target="_blank" rel="external">tcpdump</a>: capture network packets by specific filters<br><a href="http://www.tcptrace.org/" target="_blank" rel="external">tcptrace</a>: a tool for analysis of tcp dump files, like <a href="http://www.tcpdump.org/manpages/pcap.3pcap.html" target="_blank" rel="external">pcap</a><br><a href="http://tcptrace.org/jPlot/" target="_blank" rel="external">jplot</a>: a java version of <a href="http://www.xplot.org/" target="_blank" rel="external">xplot</a><br>补充一下tshark也是一个不错的工具，是wireshark的terminal版本，功能同样强大。  </p>
]]>
    
    </summary>
    
      <category term="tshark" scheme="http://perthcharles.github.com/tags/tshark/"/>
    
      <category term="tcpdump" scheme="http://perthcharles.github.com/tags/tcpdump/"/>
    
      <category term="tcptrace" scheme="http://perthcharles.github.com/tags/tcptrace/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Setup Nginx server in linux]]></title>
    <link href="http://perthcharles.github.com/2014/06/05/setup-nginx-sever/"/>
    <id>http://perthcharles.github.com/2014/06/05/setup-nginx-sever/</id>
    <published>2014-06-05T05:00:00.000Z</published>
    <updated>2014-11-04T06:41:45.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Installation">Installation</h3>
<p>By default, Nginx will be installed in /usr/local/nginx.  </p>
<pre><code>./configure  
<span class="keyword">make</span>  
<span class="keyword">make</span> install  
</code></pre><h3 id="Configuration">Configuration</h3>
<p>The configuration file is /usr/local/nginx/conf/nginx.conf.<br><a href="http://blog.martinfjordvald.com/2010/07/nginx-primer/" target="_blank" rel="external">Here</a> is an<br>excellent simple tutorial, and <a href="http://wiki.nginx.org/FullExample" target="_blank" rel="external">here</a><br>is a full example.<br>If you want to show all the files in the root directory, you can turn<br>on autoindex like this:  </p>
<pre><code><span class="title">location</span> / {  
    <span class="title">autoindex</span> <span class="built_in">on</span>;  
    <span class="title">root</span> /home;  
}  
</code></pre><h3 id="Running_Nginx">Running Nginx</h3>
<pre><code>/usr/<span class="built_in">local</span>/nginx/sbin/nginx         <span class="comment"> //start nginx  </span>
/usr/<span class="built_in">local</span>/nginx/sbin/nginx -q quit <span class="comment"> //stop nginx  </span>
</code></pre><h3 id="References">References</h3>
<p><a href="http://wiki.nginx.org/Install" target="_blank" rel="external">Install - Nginx Community</a><br><a href="http://blog.martinfjordvald.com/2010/07/nginx-primer/" target="_blank" rel="external">Nginx Configuration Primer</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Installation">Installation</h3>
<p>By default, Nginx will be installed in /usr/local/nginx.  </p>
<pre><code>./configure  
<span cla]]>
    </summary>
    
      <category term="nginx" scheme="http://perthcharles.github.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[知识积累]]></title>
    <link href="http://perthcharles.github.com/2014/04/26/make-progress-everyday/"/>
    <id>http://perthcharles.github.com/2014/04/26/make-progress-everyday/</id>
    <published>2014-04-26T04:00:00.000Z</published>
    <updated>2014-11-04T06:39:13.000Z</updated>
    <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<ul>
<li><a href="#blogger">优秀博主</a>  </li>
<li><a href="#views">百家争鸣</a>  </li>
<li><a href="#coding">编程与算法</a>  </li>
<li><a href="#network">网络</a>  </li>
<li><a href="#tools">实用工具</a>  </li>
<li><a href="#bigdata">大数据</a>  </li>
<li><a href="#linux">UNIX/Linux相关</a>  </li>
<li><a href="#projects">优秀项目主页</a>  </li>
<li><a href="#reference">参考手册</a>  </li>
<li><a href="#online-books">在线图书</a>  </li>
<li><a href="#others">其它</a>  </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注：此文所有链接均是外链</div></pre></td></tr></table></figure>

<a id="more"></a>

<hr>
<p><h3 id="blogger">优秀博主</h3></p>
<ul>
<li><a href="http://www.vimer.cn/" target="_blank" rel="external">Vimer的程序世界</a>  </li>
<li><a href="http://blog.csdn.net/caopengcs" target="_blank" rel="external">曹鹏博士</a>  </li>
<li><a href="http://blog.csdn.net/v_july_v" target="_blank" rel="external">July</a>  </li>
<li><a href="http://www.matrix67.com/blog/" target="_blank" rel="external">matrix67</a>  </li>
<li><a href="http://blog.chinaunix.net/uid-20940095-id-373614.html" target="_blank" rel="external">少帅的天空</a>  </li>
<li><a href="http://blog.csdn.net/aimingoo/" target="_blank" rel="external">周爱民CSDN专栏</a>  </li>
<li><a href="http://blog.csdn.net/dgq8211" target="_blank" rel="external">nyist_xiaod</a>  </li>
<li><a href="http://hawstein.com/" target="_blank" rel="external">Hawstein</a>  </li>
<li><a href="http://coolshell.cn/" target="_blank" rel="external">CoolShell</a>  </li>
<li><a href="http://zhedahht.blog.163.com/" target="_blank" rel="external">何海涛</a>  </li>
<li><a href="http://blog.csdn.net/hackbuteer1" target="_blank" rel="external">Hackbuterr1</a>  </li>
<li><a href="http://blog.csdn.net/Solstice" target="_blank" rel="external">陈硕的Blog</a>  </li>
<li><a href="http://www.cnblogs.com/graphics/" target="_blank" rel="external">Graphics:关注DirectX</a>  </li>
<li><a href="http://www.cnblogs.com/promise6522/" target="_blank" rel="external">One Step Further</a>  </li>
<li><a href="https://www.centos.bz/" target="_blank" rel="external">LINUX服务器运维日志</a>  </li>
<li><a href="http://zh.lucida.me/" target="_blank" rel="external">Lucida: Life Love Tech</a>  </li>
</ul>
<hr>
<p><h3 id="views">百家争鸣</h3></p>
<ul>
<li><a href="http://blog.jobbole.com/821/" target="_blank" rel="external">程序员的本质</a>  </li>
</ul>
<hr>
<p><h3 id="coding">编程与算法</h3></p>
<ul>
<li><a href="http://cloud.github.com/downloads/chenshuo/documents/LearningNetworkProgramming.pdf" target="_blank" rel="external">谈一谈网络编程学习经验</a>  </li>
<li><a href="http://blog.jobbole.com/28219/" target="_blank" rel="external">为什么转置512<em>512矩阵，会比513</em>513慢很多</a>  </li>
<li><a href="http://zh.lucida.me/blog/on-learning-algorithms/" target="_blank" rel="external">Lucida:我的算法学习之路</a>  </li>
<li><a href="http://www.m5sim.org/Coding_Style" target="_blank" rel="external">Coding Style for gem5</a>  </li>
<li><a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external">Google C++ Style Guide</a>  </li>
<li><a href="http://coolshell.cn/articles/27.html" target="_blank" rel="external">如何自己写一个网络爬虫</a>  </li>
<li><a href="http://blog.csdn.net/zhl1224/article/details/5735747" target="_blank" rel="external">段间跳转指令jmpi和实模式寻址</a>  </li>
<li><a href="http://www.cnblogs.com/jffifa/archive/2011/12/17/2291072.html" target="_blank" rel="external">n个骰子得到点数和的概率分布</a>  </li>
<li><a href="http://hrinterviews.blogspot.com/" target="_blank" rel="external">HR Interviews</a>  </li>
<li><a href="http://www.felix021.com/blog/read.php?2040" target="_blank" rel="external">Manacher算法：O(n)时间求字符串的最长回文子串</a>  </li>
<li><a href="http://blog.csdn.net/superdiablo/article/details/6173001" target="_blank" rel="external">Prim算法与Dijkstra算法的区别</a>  </li>
<li><a href="http://www.cnblogs.com/skynet/archive/2010/10/30/1865267.html" target="_blank" rel="external">Linux多线程编程举例</a>  </li>
<li><a href="http://www.topcoder.com/" target="_blank" rel="external">TopCoder</a>  </li>
<li><a href="http://www.codechef.com/" target="_blank" rel="external">CodeChef</a>  </li>
<li><a href="https://codility.com/train/" target="_blank" rel="external">Codility</a>  </li>
<li><a href="http://www.nocow.cn/index.php/%E9%A6%96%E9%A1%B5" target="_blank" rel="external">NOCOW: A Nest Of Coding Wisdom</a>  </li>
<li><a href="http://leetcode.com/" target="_blank" rel="external">LeetCode</a>  </li>
<li><a href="http://www.cs.cmu.edu/~gilpin/tutorial/" target="_blank" rel="external">Debugging Under Unix: gdb Tutorial</a>    </li>
<li><a href="http://www.cnblogs.com/promise6522/archive/2012/03/03/2377935.html" target="_blank" rel="external">浅谈TCP/IP网络编程中socket的行为</a>  </li>
<li><a href="http://publib.boulder.ibm.com/infocenter/macxhelp/v6v81/index.jsp?topic=%2Fcom.ibm.vacpp6m.doc%2Fproguide%2Fref%2Ftvopi_o.htm" target="_blank" rel="external">Coding Your Application to Improve Performance</a>  </li>
<li><a href="http://nlp.stanford.edu/IR-book/html/htmledition/web-crawling-and-indexes-1.html" target="_blank" rel="external">Web crawling and indexes</a>  </li>
<li><a href="http://dingdongsheng.cool.blog.163.com/blog/static/1186187552009431405995/" target="_blank" rel="external">二分匹配总结:匈牙利算法+最大权+最小权</a>  </li>
<li><a href="http://dongxicheng.org/knowledges-carding/" target="_blank" rel="external">面试基础知识整理</a>  </li>
</ul>
<hr>
<p><h3 id="network">网络</h3></p>
<ul>
<li><a href="http://www.beej.us/guide/bgnet/output/html/multipage/index.html" target="_blank" rel="external">Guide to Network Programming Using Internet Sockets</a>  </li>
<li><a href="http://www.cnblogs.com/aixingfou/archive/2011/07/29/2120956.html" target="_blank" rel="external">关于send(),recv()函数的理解</a>  </li>
<li><a href="http://blog.csdn.net/shanshanpt/article/category/1926563" target="_blank" rel="external">Linux 内核之网络协议栈</a> </li>
</ul>
<hr>
<p><h3 id="tools">实用工具</h3></p>
<ul>
<li><a href="http://daringfireball.net/projects/markdown/syntax#precode" target="_blank" rel="external">Markdown: syntax</a>  </li>
<li><a href="http://www.upanok.com/" target="_blank" rel="external">U盘装系统工具</a>  </li>
<li><a href="http://www.upanok.com/help.html" target="_blank" rel="external">U盘装系统教程</a>  </li>
<li><a href="http://www.vimer.cn/2010/06/%E6%9C%AC%E5%8D%9A%E4%BD%BF%E7%94%A8%E7%9A%84vimgvim%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E6%95%B4%E7%90%86.html" target="_blank" rel="external">Vim 插件</a>  </li>
<li><a href="https://github.com/wklken/k-vim" target="_blank" rel="external">Vim 插件2</a>  </li>
<li><a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="external">Vim插件管理:Vundle</a>  </li>
<li><a href="http://blog.sina.com.cn/s/blog_4cbfbaa30100ioy2.html" target="_blank" rel="external">Matlab中plot用法</a>  </li>
<li><a href="http://blog.csdn.net/ww2000e/article/details/6609657" target="_blank" rel="external">让source insight支持AT&amp;T汇编语法高亮</a>  </li>
<li><a href="http://www.atmos.albany.edu/deas/atmclasses/atm350/vi_cheat_sheet.pdf" target="_blank" rel="external">vi Editor Cheat Sheet</a>  </li>
<li><a href="http://wgkgood.blog.51cto.com/1192594/917632" target="_blank" rel="external">GCC升级</a>  </li>
</ul>
<hr>
<p><h3 id="bigdata">大数据</h3></p>
<ul>
<li><a href="http://hadooptutorial.wikispaces.com/Hadoop" target="_blank" rel="external">Hadoop tutorial</a>  </li>
</ul>
<hr>
<p><h3 id="linux">UNIX/Linux相关</h3></p>
<ul>
<li><a href="http://www.pixelbeat.org/cmdline_zh_CN.html" target="_blank" rel="external">linux常见命令的列表</a>  </li>
<li><a href="http://www.linux-tutorial.info/" target="_blank" rel="external">Linux Knowledge Base and Tutorial</a>  </li>
<li><a href="http://www.92csz.com/study/linux/11.htm" target="_blank" rel="external">安装RPM包或者安装源码包</a>  </li>
<li><a href="http://linux-mm.org/LinuxMM" target="_blank" rel="external">Linux Memory Management</a>  </li>
<li><a href="http://blog.csdn.net/emtribe/article/details/8915884" target="_blank" rel="external">git获取linux内核源码及分支管理</a>  </li>
<li><a href="http://www.linux-tutorial.info/index.php" target="_blank" rel="external">Linux Knowledge Base and Tutorial</a>  </li>
<li><a href="http://linux.die.net/man/" target="_blank" rel="external">Linux Man pages:可查询命令、函数或文件</a>  </li>
<li><a href="http://www.linuxjournal.com/article/6345?page=0,0" target="_blank" rel="external">Zero Copy I: User-Mode Perspective</a>  </li>
<li><a href="http://baruch.siach.name/blog/posts/linux_kernel_module_parameters/" target="_blank" rel="external">Setting Linux kernel module parameters</a>  </li>
<li><a href="http://www.cyberciti.biz/howto/question/linux/linux-rpm-cheat-sheet.php" target="_blank" rel="external">rpm command examples</a>  </li>
<li><a href="http://blog.csdn.net/hansel/article/details/5097262" target="_blank" rel="external">Linux下二进制文件的查看和编辑</a>  </li>
<li><a href="http://www.cnblogs.com/killkill/archive/2010/06/23/1763785.html" target="_blank" rel="external">在Linux下使用vim配合xxd查看并编辑二进制文件</a>  </li>
<li><a href="http://www.qycn.com/news/11669.html" target="_blank" rel="external">CentOS 6安装JDK及系统配置</a>  </li>
<li><a href="http://noops.me/?p=271" target="_blank" rel="external">centos kvm部署和常用命令</a>  </li>
<li><a href="http://dbanotes.net/tech-memo/shell_shortcut.html" target="_blank" rel="external">Bash Shell 快捷键的学习使用</a>  </li>
<li><a href="http://www.lishiming.net/thread-3624-1-1.html" target="_blank" rel="external">iptables 实现centos内网机器访问外网</a>  </li>
<li><a href="http://wiki.centos.org/zh/HowTos/JavaOnCentOS" target="_blank" rel="external">如何在 CentOS 4 及 CentOS 5 上安装 Java</a>  </li>
<li><a href="http://ohyeahbbs.blog.51cto.com/1775490/865107" target="_blank" rel="external">CentOS 6.2 挂载 NTFS格式的硬盘</a>  </li>
<li><a href="http://blog.csdn.net/yayong/article/details/139983" target="_blank" rel="external">Linux AT&amp;T 汇编语言开发指南</a>  </li>
<li><a href="http://iso.linuxquestions.org/" target="_blank" rel="external">Linux ISO 镜像列表</a>  </li>
<li><a href="http://www.rpmfind.net/" target="_blank" rel="external">查找RPM包1</a>  </li>
<li><a href="http://rpm.pbone.net/" target="_blank" rel="external">查找RPM包2：推荐</a>  </li>
<li><a href="http://tldp.org/LDP/tlk/tlk.html" target="_blank" rel="external">在线文档：The linux kernel</a>  </li>
</ul>
<hr>
<p><h3 id="projects">优秀项目主页</h3></p>
<ul>
<li><a href="http://www.gnu.org/software/wget/" target="_blank" rel="external">GNU Wget</a>  </li>
<li><a href="http://www.latex-project.org/" target="_blank" rel="external">Latex</a>  </li>
<li><a href="http://www.tldp.org/" target="_blank" rel="external">The Linux Documentation Project</a>  </li>
<li><a href="http://www.linux-kvm.org/page/Main_Page" target="_blank" rel="external">KVM</a>  </li>
</ul>
<hr>
<p><h3 id="reference">参考手册</h3></p>
<ul>
<li><a href="http://man.chinaunix.net/develop/c&amp;c++/linux_c/default.htm" target="_blank" rel="external">Linux 常用C函数</a>  </li>
<li><a href="http://man.chinaunix.net/" target="_blank" rel="external">ChinaUnix.net 手册中心</a>  </li>
<li><a href="http://www.x.org/releases/X11R7.5/doc/man/man3/" target="_blank" rel="external">X11R7.5 Manual Pages: Section 3: Library Functions</a>  </li>
<li><a href="http://people.cs.nctu.edu.tw/~yslin/library/linuxc/main.htm" target="_blank" rel="external">Linux 常用C函数</a>  </li>
<li><a href="http://www.cplusplus.com/reference/" target="_blank" rel="external">C++ Reference</a>  </li>
<li><a href="http://clc-wiki.net/wiki/C_standard_library" target="_blank" rel="external">C standard library</a>  </li>
<li><a href="http://www.gnu.org/software/libc/manual/html_mono/libc.html" target="_blank" rel="external">The GNU C Library</a>  </li>
<li><a href="http://cursuri.cs.pub.ro/~apc/2003/resources/pthreads/uguide/document.htm" target="_blank" rel="external">Pthreads APIs</a>  </li>
<li><a href="http://vimcdoc.sourceforge.net/doc/usr_toc.html#usr_toc.txt" target="_blank" rel="external">VIM User Manual</a>  </li>
<li><a href="http://blog.51yip.com/manual/shell/" target="_blank" rel="external">Shell在线手册</a>  </li>
<li><a href="https://computing.llnl.gov/tutorials/pthreads/" target="_blank" rel="external">POSIX Threads Programming</a>  </li>
<li><a href="http://tldp.org/HOWTO/Program-Library-HOWTO/" target="_blank" rel="external">Program Library HOWTO</a>  </li>
<li><a href="http://capone.mtsu.edu/csdept/FacilitiesAndResources/make.htm" target="_blank" rel="external">An Introduction to the UNIX Make Utility</a>  </li>
<li><a href="http://fanqiang.chinaunix.net/a4/b8/20010601/170400310_b.html" target="_blank" rel="external">X Window 程式設計入門</a>  </li>
</ul>
<hr>
<p><h3 id="online-books">在线图书</h3></p>
<ul>
<li><a href="http://www.ibiblio.org/g2swap/byteofpython/read/index.html" target="_blank" rel="external">A Byte of Python</a>  </li>
<li><a href="http://www.diveintopython.net/toc/index.html" target="_blank" rel="external">Dive Into Python</a>  </li>
<li><a href="http://idns.blog.163.com/blog/static/2004533772011111945928615/" target="_blank" rel="external">C++ Primer, Fourth Edition</a>  </li>
<li><a href="http://www.makelinux.net/ldd3/" target="_blank" rel="external">Linux Device Drivers, 3th Edition</a>  </li>
</ul>
<hr>
<p><h3 id="others">其它</h3></p>
<ul>
<li><a href="http://archive.org/web/web.php" target="_blank" rel="external">Internet Archive</a>  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="目录">目录</h2>
<ul>
<li><a href="#blogger">优秀博主</a>  </li>
<li><a href="#views">百家争鸣</a>  </li>
<li><a href="#coding">编程与算法</a>  </li>
<li><a href="#network">网络</a>  </li>
<li><a href="#tools">实用工具</a>  </li>
<li><a href="#bigdata">大数据</a>  </li>
<li><a href="#linux">UNIX/Linux相关</a>  </li>
<li><a href="#projects">优秀项目主页</a>  </li>
<li><a href="#reference">参考手册</a>  </li>
<li><a href="#online-books">在线图书</a>  </li>
<li><a href="#others">其它</a>  </li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">注：此文所有链接均是外链</div></pre></td></tr></table></figure>

]]>
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[The Art of Readable Code]]></title>
    <link href="http://perthcharles.github.com/2014/04/20/the-art-of-readable-code/"/>
    <id>http://perthcharles.github.com/2014/04/20/the-art-of-readable-code/</id>
    <published>2014-04-20T04:00:00.000Z</published>
    <updated>2014-11-04T06:31:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2>
<p>短小精悍的编程建议，常读常新。  </p>
<h3 id="第一章：代码应当易于理解">第一章：代码应当易于理解</h3>
<p>1.代码的写法应当使别人理解它所需的时间最小化<br>理解的要求就是别人看完你的代码后，能够动手改动或优化你的代码。<br>写代码的时候应该以能够像自然语言一样易于理解为目标。  </p>
<p>2.代码并不是行数越少就越容易理解  </p>
<a id="more"></a>

<h2 id="第一部分：表面层次的改进">第一部分：表面层次的改进</h2>
<h3 id="第二章：把信息装到名字里">第二章：把信息装到名字里</h3>
<p>1.选择专业的词<br>举例：<br>    int size()     =&gt;  int Height()/NumNodes()/MemoryBytes()<br>简单的使用size不能直接反应出返回值使什么的size。<br>如果可以的话选用更具体、更符合情景的专业词汇对于可读性有较大的帮助。  </p>
<p>2.避免使用tmp和retval这样泛泛的变量/函数名<br>除非有十分好的理由，比如常见的swap函数中的tmp。  </p>
<p>3.用具体的名字代替抽象的名字<br>书中有一个插图很好的阐释了这点：动物和危险动物  </p>
<p>4.给变量带上重要的细节<br>比如添加单位等，可以参考微软的“匈牙利表示法”  </p>
<h3 id="第三章：不要误解的名字">第三章：不要误解的名字</h3>
<p>1.推荐用min和max来表示（包含）极限<br>2.推荐用first和last来表示包含的范围<br>3.推荐用begin和end来表示包含／排除范围<br>4.要小心用户对特定词的期望。例如，用户会期望get（）<br>或者size（）是轻量的方法。  </p>
<p>这章讲的内容感觉需要有较多的实践应验才能区分哪些名字会产生误解<br>所以这里仅列出了书中强调的几条经验  </p>
<h3 id="第四章：审美">第四章：审美</h3>
<p>1.三条大原则：<br><em>使用一致的布局，让读者很快就习惯这种风格  
</em>让相似的代码看上去相似<br>*把相关的代码行分组，形成代码块  </p>
<p>2.如果代码中存在大量的重复代码，或许该考虑添加一个函数了。<br>一个合适的小函数能有效提高代码的视觉美感  </p>
<p>3.在需要时使用列对齐  </p>
<p>4.选一个有意思的顺序，始终一致地使用它<br>常见的顺序：重要性、字母序  </p>
<p>5.把声明按块组织起来<br>这点对于类或者较大的结构体尤为重要  </p>
<p>6.个人风格与一致性<br>一个人的代码风格如果能够保持一致，这比“正确”的风格更重要。<br>最好的学习代码风格的资料就是Linux源码！<br>推荐一些我了解的一些代码风格的资料：<br><a href="http://www.m5sim.org/Coding_Style" target="_blank" rel="external">Gem5 Coding Style</a><br><a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml" target="_blank" rel="external">Google C++ Style Guide</a>  </p>
<h3 id="第五章：该写什么样的注释">第五章：该写什么样的注释</h3>
<p>1.关键思想：注释的目的时尽量帮助读者了解得和作者一样多  </p>
<p>2.最好的注释就是代码本身，不要为了注释而注释<br>自解释的代码比任何的注释都要好，好代码&gt;坏代码＋好注释  </p>
<p>3.不要给不好的名字加注释—应该把名字改好  </p>
<p>4.为代码的瑕疵写注释<br>如果阅读过Linux源码会发现里面有很多’TODO’的注释，这点很值得学习<br>很多时候第一版的代码是想尽快的完成某个功能，在实现过程中想到的一些可能<br>的优化如果暂时不便实现，加上一个’TODO’的注释或许是一个不错的选择。<br>书中列出了一些流行的标记类的注释。  </p>
<p>5.给常量加注释<br>常量的值往往不是重点，而为什么常量被设置为这个值才是重点。<br>添加合适的注释解释这些信息，对代码的可读性有较大的帮助。  </p>
<p>6.站在读者的角度<br>这点比较有意思，这类注释更像是对于某个问题的解答。<br>对于一些意料之中的问题，添加注释进行回答能节省许多不必要的时间  </p>
<p>7.公布可能的陷阱<br>这点的出发点与第6条类似  </p>
<p>8.全局观的注释：用注释来总结代码块，使读者不致迷失在细节中。<br>注释的目的是帮助读者更好更快的理解你的代码，<br>给出一些总结性的注释能够省去读者很多的时间。<br>对于一个较复杂的函数，如果能一针见血的指出函数完成的功能、输入和输出，<br>读者就可以根据需要要选择性的阅读你的代码。这点对于复杂的大项目尤为重要。  </p>
<h3 id="第6章：写出言简意赅的注释">第6章：写出言简意赅的注释</h3>
<p>这章的内容看下章首的插图就能一目了然，就不多解释了。  </p>
<h2 id="第二部分：简化循环和逻辑">第二部分：简化循环和逻辑</h2>
<p>用更加清晰的方式来实现代码的逻辑至关重要，<br>对于一段时候后重新来阅读或调试这段代码尤其重要。  </p>
<h3 id="第7章：把控制流变得易读">第7章：把控制流变得易读</h3>
<p>关键思想：把条件、循环以及其他对控制流的改变做的越自然越好。<br>运用一种方式使读者不用停下来重读你的代码。  </p>
<p>1.条件语句中参数的顺序<br>代码同样需要符合人阅读的习惯<br>指导原则：<br><em>比较的左侧：“被问询的”表达式，它的值更倾向于不断变化  
</em>比较的右侧：用来做比较的表达式，它的值更倾向于常量  </p>
<p>2.if/else的顺序<br><em>首先处理正逻辑而不是负逻辑的情况，例如：用if(debug)而不用if(!debug)  
</em>先处理掉简单的情况。这种方式可能还会使得if和else在屏幕之内都可见，这很好<br>*先处理有趣或者是可以的情况  </p>
<p>3.代码行数越少不一定越好，更好的度量方法是最小化人们理解它所需要的时间  </p>
<p>4.尽量减少代码的嵌套层数<br>嵌套的层次越多，之后代码的优化和修改就越复杂。<br>书中提到了一些有效的方法避免过多的嵌套，如提前从函数中返回或使用break  </p>
<h3 id="第8章：拆分超长的表达式">第8章：拆分超长的表达式</h3>
<p>关键思想：把你的超长表达式拆分成更容易理解的小块<br>人脑能同时处理的信息量有限，就好比巨星乌贼一次吃多了就容易伤到大脑  </p>
<p>1.拆分表达式最简单的方法就是引入一个额外的变量，让它来表示一个小一点<br>的子表达式。这个额外的变量有时叫做“解释变量”，因为它可以帮助解释<br>子表达式的含义。  </p>
<p>2.使用德摩根定理对复杂的逻辑表达式简化<br>如果使用此方法简化了逻辑表达式，那么最好添加相应的注释。<br>因为转换过后的表达式理解起来没那么直接。  </p>
<p>3.找到更优雅的方式<br>一个复杂的逻辑，如果考虑它的反面或许就没有那么复杂了。<br>书中的例子就是两个区间的重叠的判断，值得一读  </p>
<h3 id="第9章：变量与可读性">第9章：变量与可读性</h3>
<p>1.减少没有价值的临时变量<br>至于判断是否存在价值，这需要常年的积累。  </p>
<p>2.减少控制流变量<br>还是那个理由：人脑同时能够处理的事情有限  </p>
<p>3.缩小变量的作用域<br>缩小了变量的作用域，同样减少了读代码时需要记在脑海中的信息<br>同时还避免了变量冲突  </p>
<p>4.只写一次的变量更好<br>基于的思想：操作一个变量的地方越多，越难确定它的当前值  </p>
<h2 id="第三部分：重新组织代码">第三部分：重新组织代码</h2>
<h3 id="第10章：抽取不相关的子问题">第10章：抽取不相关的子问题</h3>
<p>核心思想：把一般代码和项目专有的代码分开<br>书中指出 ：大部分的代码都是一般代码。通过建立一个大组库和辅助函数来<br>解决一般问题，剩下的只是让你的程序与众不同的核心部分。    </p>
<p>1.创建大量通用代码<br>如果字符串需要以某种格式输出，而这种格式经常被用到，那么你该考虑<br>用一个类似format_pretty()的函数专门负责将字符串转换成特定格式。  </p>
<h3 id="第11章：一次只做一件事">第11章：一次只做一件事</h3>
<p>关键思想：应该把代码组织得一次只做一件事  </p>
<p>下面是用于使代码“一次只做一件事”所用到的流程：<br><em>列出代码所做的所有“任务”。这里的任务没有很严格的定义—它可以很小  
</em>尽量把这些任务拆分到不同的函数中，或者至少是代码中不同的段落中  </p>
<h3 id="第12章：把想法变成代码">第12章：把想法变成代码</h3>
<p>1.清晰地描述逻辑<br>把一个想法用“自然语言”解释是一个很有价值的能力<br>代码不仅仅是写给机器执行的，更多的时候是写给人读的，所以代码的逻辑<br>能够像“自然语言”那般的描述出来，对于代码的理解有莫大的帮助  </p>
<p>2.了解库函数很有帮助和必要<br>了解库函数避免重复造轮子，不仅能够提高效率，而且库函数的使用很大程度<br>的保障了正确性。<br>当然要想完全了解库函数每个函数的具体用法，将是一个十分巨大的工程。<br>我们能够做的就是常常翻翻主要库的文档，在实现某项功能的时候能够想到<br>库函数中好像有类似的实现就可以了  </p>
<p>3.在动手写代码之前，先尝试用自然语言描述解决方法是一个很好的习惯  </p>
<h3 id="第13章：少写代码">第13章：少写代码</h3>
<p>1.在项目开始时写的代码只有很少的代码留到最终版本中  </p>
<p>2.写代码前，需要反复考虑和质疑的你需求<br>很多时候你认为需要的功能，到最后都没有实现的必要  </p>
<p>3.用最合适的方式实现你的需求<br>书中有一个关于缓存的例子。如果数据的重复访问只处在一行，那么没有必要<br>实现一个复杂的LRU策略。  </p>
<p>4.使用UNIX工具而非编写代码<br>这点我的体会最深。跑实验的时候处理数据，如果每次都要写代码的话，<br>就不用跑实验了。使用一些常用的文本处理命令能有效地提高效率，<br>比如cat、awk、cut等。  </p>
<h2 id="第四部分：精选话题">第四部分：精选话题</h2>
<p>这部分主要是一些关于测试和一个小功能的具体实现举例，具体还是看书比较好。  </p>
<h2 id="总结">总结</h2>
<p>本书很多的内容都需要通过大量的实践才能透彻的领悟，常读常新。<br>本书的可读性也很强，书中又有许多有趣的插图，<br>能够让你一下子就体会到整个一章的精髓。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="简介">简介</h2>
<p>短小精悍的编程建议，常读常新。  </p>
<h3 id="第一章：代码应当易于理解">第一章：代码应当易于理解</h3>
<p>1.代码的写法应当使别人理解它所需的时间最小化<br>理解的要求就是别人看完你的代码后，能够动手改动或优化你的代码。<br>写代码的时候应该以能够像自然语言一样易于理解为目标。  </p>
<p>2.代码并不是行数越少就越容易理解  </p>
]]>
    
    </summary>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Markdown中插入Latex代码]]></title>
    <link href="http://perthcharles.github.com/2013/12/22/insert-latex-to-markdown/"/>
    <id>http://perthcharles.github.com/2013/12/22/insert-latex-to-markdown/</id>
    <published>2013-12-22T04:00:01.000Z</published>
    <updated>2014-11-04T06:29:45.000Z</updated>
    <content type="html"><![CDATA[<h2 id="配置">配置</h2>
<p>Markdown解析器：rdiscount  </p>
<h2 id="举例">举例</h2>
<p>1.行内代码<br>效果:<code>$W_{i}$</code>在行内。  </p>
<p>2.独占一行代码<br>效果:<code>$$W_{i}$$</code>独占一行。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="配置">配置</h2>
<p>Markdown解析器：rdiscount  </p>
<h2 id="举例">举例</h2>
<p>1.行内代码<br>效果:<code>$W_{i}$</code>在行内。  </p>
<p>2.独占一行代码<br>效果:<cod]]>
    </summary>
    
      <category term="markdown" scheme="http://perthcharles.github.com/tags/markdown/"/>
    
      <category term="latex" scheme="http://perthcharles.github.com/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数学之美[吴军 著]]]></title>
    <link href="http://perthcharles.github.com/2013/12/14/beauty-of-mathematics/"/>
    <id>http://perthcharles.github.com/2013/12/14/beauty-of-mathematics/</id>
    <published>2013-12-14T04:00:00.000Z</published>
    <updated>2014-11-04T06:27:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="作者寄语">作者寄语</h1>
<p>愿科学之精神在国民中得到普及，愿中国年轻的一代涌现更多的杰出专业人才。  </p>
<a id="more"></a>

<h1 id="名人语录">名人语录</h1>
<p>除那些真实而已足够说明其现象者外，不必去寻找自然界事物的其他原因。<br>—牛顿  </p>
<p>简单性和模块化是软件工程的基石；分布式和容错性是互联网的声明。<br>—蒂姆 伯纳斯 李  </p>
<p>纯数学使我们能够发现概念和联系这些概念的规律，这些概念和规律给了我们了解自然<br>现象的钥匙。<br>—爱因斯坦  </p>
<h1 id="相关读物">相关读物</h1>
<p>《从一到无穷大》  — 乔治 伽莫夫 (George Gamow)  </p>
<h2 id="第一章：文字和语言_vs_数字的信息">第一章：文字和语言 vs 数字的信息</h2>
<p>1.信息的冗余是信息安全的保障。罗塞塔石碑上的内容是同一信息重复三次  </p>
<p>2.阿拉伯数字的发明人是古印度人，只不过这种计数方式是由阿拉伯人传入欧洲的  </p>
<p>3.关于古文与白话文的信息论解释：<br>如果信道较宽，信息不必压缩就可以直接传递；如果信道很窄，信息在传递前需要尽可<br>能的压缩，然后在接收端解压缩。<br>在古代，两个人讲话说得快，是一个宽信道，无需压缩；书写则是一个慢而代价昂贵的<br>窄信道，需要压缩。  </p>
<p>4.这章主要是帮助读者感受语言和数学天然、内在的联系。  </p>
<h2 id="第二章：自然语言处理_—_从规律到统计">第二章：自然语言处理 — 从规律到统计</h2>
<p>1.今天，机器翻译和语音识别已经做得不错，并且有上亿人使用过，但是大部分这个领<br>域之外的人依然错误地认为这两个应用是靠计算机理解自然语言完成的。事实上，他们<br>全部都都靠的是数学，更准确的说是靠统计。  </p>
<p>2.描述自然语言的文法和计算机高级程序语言的文法不同。自然语言在演变的过程中，<br>产生了词义和上下文相关的特性。因此，它的文法是比较复杂的上下文有关文法，而程<br>序语言是我们认为设计的，为了便于计算机解码的上下文无关文法，相比自然语言而言<br>简单的多。对于上下文无关文法，算法的复杂度基本上是语句长度的二次方，而对于上<br>下文有关文法，计算复杂度基本上是语句长度的六次方。  </p>
<p>3.基于统计的自然语言处理方法，在数学模型上和通信是相通的，甚至就是相通的。因<br>此，在数学意义上自然语言处理又和语言的初衷 — 通信联系在一起了。但是，科学家<br>们认识到这个联系却花了几十年的时间。  </p>
<h2 id="第三章：统计语言模型">第三章：统计语言模型</h2>
<p>1.19世纪到20世纪初，俄罗斯有个数学家叫马尔科夫，他给了个偷懒但还颇为有效的方<br>法，也就是每当遇到这种情况时，就假设任意一个词<code>$W_{i}$</code>出现的概率只同它前面的<br>词<code>$W_{i-1}$</code>有关，于是问题就变简单了。这种假设在数学上成为马尔科夫假设。  </p>
<p>2.也可以假设一个词由前面N-1个词决定，对应的模型稍微复杂些，被称为N元模型。  </p>
<p>3.在实际工程中，还需要考虑零概率问题和平滑的方法，细节可参考原书。  </p>
<h2 id="第四章：谈谈中文分词">第四章：谈谈中文分词</h2>
<p>1.利用统计语言模型进行自然语言处理是建立在<em>词</em>的基础上的，因为词是表达语义的<br>最小单位。对于西方拼音语言来讲，词之间有明确的分界符(Delimit)，统计和使用语言<br>模型非常直接。而对于中、日、韩、泰等语言，需要首先对句子进行分词，才能做进一<br>步的自然语言处理。  </p>
<p>2.最容易想到的分词方法，也是最简单的办法，就是查字典(最早由北航的梁南元教授提<br>出)。”查字典”的办法，其实就是把一个句子扫描一遍，遇到字典里有的词就标识出来，<br>遇到复合词就找最长的词匹配，遇到不认识的字串就分割成单字词。  </p>
<p>3.利用统计语言模型分词的方法，基本的想法就是：最好的一种分词方法应该保证分完词<br>后这个句子出现的概率最大。  </p>
<p>4.中文分词以统计语言模型为基础，通过几十年的发展和完善，今天基本可以看做是一个<br>已经解决的问题。当然不同的人做的分词器有好有坏，这里面的差别主要在于数据的使用<br>和工程实现的精度。  </p>
<h2 id="第五章：隐含马尔科夫模型">第五章：隐含马尔科夫模型</h2>
<p>1.马尔科夫假设：随机过程中各个状态<code>$S_{t}$</code>的概率分布，只与它的前一个状态<code>$S_{t-1}$</code><br>有关。  </p>
<p>2.隐含马尔科夫模型是上述马尔科夫链的一个扩展：任一时刻t的状态<code>$S_{t}$</code>是不可见<br>的。所以观察者无法通过观察到一个状态序列<code>$S_{1}, S_{2}, S_{3}, ..., S_{T}$</code>来<br>推测转移概率等参数。但是隐含马尔科夫模型在每个时刻t会输出一个符号<code>$O_{t}$</code>，而<br>且<code>$O_{t}$</code>和<code>$S_{t}$</code>相关且仅和<code>$S_{t}$</code>相关。这个被称为独立输出假设。其中隐<br>含的状态是一个典型的马尔科夫链。  </p>
<p>3.围绕着隐含马尔科夫模型有三个基本问题：<br>a.给定一个模型，如何计算某个特定的输出序列的概率；<br>Forward-Backward算法<br>b.给定一个模型和某个特定的输出序列，如何找到最可能产生这个输出的状态序列；<br>解码算法：维特比算法<br>c.给定足够的观测数据，如何估计隐含马尔科夫模型的参数。<br>训练算法：鲍姆-韦尔奇算法  </p>
<h2 id="第六章：信息的度量和作用">第六章：信息的度量和作用</h2>
<p>1.信息量就等于不确定性的多少。  </p>
<p>2.<a href="http://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E7%86%B5" target="_blank" rel="external">WIKI：信息熵</a>  </p>
<p>3.变量的不确定越大，熵也就越大，把它搞清楚所需要的信息量也就越大。  </p>
<p>4.合理利用信息，而不是玩弄什么公式和机器学习算法，是做好搜索的关键。  </p>
<h2 id="第七章：贾里尼克和现代语言处理">第七章：贾里尼克和现代语言处理</h2>
<p>1.每当弗莱德和我谈起我们各自少年时的教育，我们都同意这样几个观点(博主也很同意)：  </p>
<p>a.小学生和中学生其实没有必要花那么多时间读书，而他们的社会经验、生活能力以及在<br>那时树立起的志向将帮助他们一生。<br>b.中学阶段化很多时间比同伴多读的课程，在大学以后用非常短的时间就可以读完，因为<br>在大学阶段，人的理解力要强的多。<br>c.学习和教育是一个人一辈子的过程，很多中学成绩好的亚裔学生进入名校后表现明显不<br>如那些因为兴趣而读书的美国同伴，因为前者不断读书的动力不足。<br>d.书本的内容可以早学，也可以晚学，但是错过了成长阶段却是无法补回来的。  </p>
<p>2.贾里尼克最初的理想在他十来岁时就建立起来了，他原本想成为一个律师，为他父亲那<br>样的冤屈者辩护，但是到美国后，他很快意识到他那弄弄的外国口音将使他在法庭上的辩<br>护很吃力。贾里尼克的第二个理想是成为医生，也算是子承父业。他想进哈弗大学医学院，<br>但他无力承担医学院8年高昂的学费。而恰恰此时麻省理工学院给了他一份为东欧一名设的<br>全额奖学金。贾里尼克决定到麻省理工学电机工程。贾里尼克的理想在不断的改变，但是<br>他通过努力走向成功的志向一直没有改变。  </p>
<h2 id="第八章：简单之美_—_布尔代数和搜索引擎的索引">第八章：简单之美 — 布尔代数和搜索引擎的索引</h2>
<p>1.布尔代数非常简单，但是对数学和计算机发展的意义重大，它不仅把逻辑和数学合二为<br>一，而且给了我们一个全新的视角看待世界，开创了今天数字化的时代。</p>
<p>2.Truth is ever to be found in simplicity, and not in the multiplicity and<br>confusion of things.    —by Sir Isaac Newton(艾萨克 牛顿爵士)  </p>
<h2 id="第九章：图论和网络爬虫">第九章：图论和网络爬虫</h2>
<p>1.欧拉七桥问题  </p>
<p>2.网路爬虫在工程实现上要考虑的细节非常多，其中大的方面有这样几点：<br>a.用BFS还是DFS<br>从理论上讲，这两个算法能够在大致相同的时间里，爬下整个<em>静态</em>互联网的内容。<br>但是互联网是动态更新的，所以网络爬虫问题更应该定义成：如何在有限时间里最多的爬<br>下最重要的网页。<br>显然各个网站最重要的网页是它的首页。<br>如果爬虫非常小，只能下载非常有限的网页，那么应该下载的是所有网页的首页。BFS  </p>
<p>但是互联网又是分布式的，BFS必然导致大量的各个网站直接的跳转与跳回，效率会降低。<br>而且爬虫器基本也是分布式的，所以更好的方式是总体上选用BFS，然而针对某个网站，<br>某个爬虫服务器应该尽量一次爬完所有的页面，这样就是DFS的策略。  </p>
<h2 id="第十章：PageRank_—_Google的民主表决式网页排名技术">第十章：PageRank — Google的民主表决式网页排名技术</h2>
<p>1.<a href="http://en.wikipedia.org/wiki/PageRank" target="_blank" rel="external">WIKI: PageRank</a>  </p>
<h2 id="第十一章：如何确定网页和查询的相关性">第十一章：如何确定网页和查询的相关性</h2>
<p>1.<a href="http://en.wikipedia.org/wiki/Tf%E2%80%93idf" target="_blank" rel="external">WIKI: TF-IDF</a>  </p>
<p>2.TF: Term Frequency  IDF: Iverse Document Frequency  </p>
<p>3.词的权重：如果一个关键词只在很少的网页中出现，通过它就容易确定搜索目标，它的<br>权重也就应该大。反之，如果一个词在大量网页中出现，看到它依然不清楚要找什么内容，<br>因此它的权重就应该小。  </p>
<p>4.IDF就是一个词的权重的指标。公式：<code>$\log \left( \dfrac {D}{D_{w}}\right)$</code><br>其中D是全部网页数，关键词w在<code>$D_{w}$</code>个网页中出现过。  那么<code>$D_{w}$</code>越大，IDF<br>就会越小。  </p>
<h2 id="第十二章：地图和本地搜索的最基本技术_—_有限状态机和动态规划">第十二章：地图和本地搜索的最基本技术 — 有限状态机和动态规划</h2>
<p>1.地址分析用到有限状态机  </p>
<p>2.导航路线用到动态规划  </p>
<h2 id="第十三章：Google_AK-47的设计者_—_阿米特_辛格博士">第十三章：Google AK-47的设计者 — 阿米特 辛格博士</h2>
<p>1.许多失败并不是因为人不优秀，而是做事情的方法不对，一开始追求大而全的解决方案，<br>之后长时间不能完成，最后不了了之。  </p>
<p>2.在Google里，辛格一直坚持寻找简单有效的解决方案。  </p>
<p>3.当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运，这首<br>先是靠他丰富的研究经验。辛格早年师从于搜索大师萨尔顿(Salton)教授，毕业后就职于<br>AT&amp;T实验室。  </p>
<h2 id="第十四章：余弦定理和新闻的分类">第十四章：余弦定理和新闻的分类</h2>
<p>1.首先找到一组来描述新闻主题的数字：对于一篇新闻中的所有诗词，计算出他们的TF-IDF<br>值，把这些值按照对应的实词在词汇表的位置一次排序，就得到一个向量。  </p>
<p>2.余弦定理就是计算两个向量夹角的方法。运用到新闻分类问题中，就可以认为夹角越小，<br>新闻越相似，反之则越不同。  </p>
<h2 id="第十五章：矩阵运算和文本处理中的两个分类问题">第十五章：矩阵运算和文本处理中的两个分类问题</h2>
<p>1.<a href="http://zh.wikipedia.org/wiki/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3" target="_blank" rel="external">WIKI: 奇异值分解</a>  </p>
<p>2.相比上一章介绍的利用文本特征向量余弦的举例自底向上的分类方法，奇异值分解的<br>优点是能较快地得到结果，因为它不需要一次次地迭代。但是用这种方法得到的分类结果<br>略显粗略，因此，它适合处理超大规模文本的粗分类。在实际工作中，先使用奇异值分解<br>进行粗分类，然后使用向量余弦得到比较精确的结果。  </p>
<h2 id="第十六章：信息指纹及其应用">第十六章：信息指纹及其应用</h2>
<p>1.产生信息指纹的关键算法：伪随机数产生器算法(Pseudo-Random Number Generator, PRNG),<br>通过它将任意很长的整数转换成特定长度的伪随机数。  </p>
<p>2.现在常用的梅森旋转算法(Mersenne Twister)要好得多。  </p>
<p>3.信息指纹的用途远不止网址的消重，它的孪生兄弟是密码。信息指纹的一个特征是其不<br>可逆性。  </p>
<h2 id="第十七章：由电视剧《暗算》所想到的_—_谈谈密码学的数学原理">第十七章：由电视剧《暗算》所想到的 — 谈谈密码学的数学原理</h2>
<p>1.类似凯撒大帝式的加密方式，使用统计学的方法能够轻松解密。  </p>
<p>2.信息论时代的密码学，就我现在的简单理解就是倒腾大素数的过程。  </p>
<h2 id="第十八章：闪光的不一定是金子_—_谈谈搜索引擎反作弊问题">第十八章：闪光的不一定是金子 — 谈谈搜索引擎反作弊问题</h2>
<p>1.网页搜索反作弊对于搜索引擎公司来讲是一项长期的任务。作弊的本质是在网页排名信<br>号中加入噪音，因此反作弊的关键是去噪音。沿着这个思路可以从根本上提高搜索算法抗<br>作弊的能力，事半功倍。而如果只是根据作弊的具体特征头痛医头，脚痛医脚，则很容易<br>被作弊者牵着鼻子走。  </p>
<h2 id="第十九章：谈谈数学模型的重要性">第十九章：谈谈数学模型的重要性</h2>
<p>1.一个正确的数学模型应该在形式上是简单的。  </p>
<p>2.一个正确的模型一开始可能还不如一个精雕细琢的错误模型来的准确，但是，如果我们<br>认定大方向是对的，就应该坚持下去。  </p>
<p>3.大量准确的数据对研发很重要。  </p>
<p>4.正确的模型也可能受噪音干扰，而显得不准确；这时不应该用一种凑合的修正方法来弥<br>补它，而是要找到噪音的根源，这也许能通往重大的发现。  </p>
<h2 id="第二十章：不要把鸡蛋放到一个篮子里_—_谈谈最大熵模型">第二十章：不要把鸡蛋放到一个篮子里 — 谈谈最大熵模型</h2>
<p>1.最大熵模型说白了，就是要保留全部的不确定性，将风险降到最小。  </p>
<p>2.最大熵原理指出，需要对一个随机事件的概率分布进行预测时，我们的预测应当满足全<br>部已知的条件，而对未知的情况不要做任何主观假设。在这种情况下，概率分布最均匀，<br>预测的风险最小。因为这是概率分布的信息熵最大，所以人们称这种模型叫：最大熵模型。  </p>
<p>3.最原始的最大熵模型的训练方法是一种称为通用迭代算法GIS(Generalized Iterative<br>Scaling)的迭代算法。GIS的原理并不复杂，大致可以概括为一下几个步骤：<br>a.假定第零次迭代的初始模型为等概率的均匀分布<br>b.通过第N次迭代的模型来估算每种信息特征在训练数据中的分布。如果超过了实际的，<br>就把相应的模型参数变小。否则，将他们变大。<br>c.重复步骤2直到收敛  </p>
<p>4.达拉皮垂孪生兄弟在IBM对GIS算法做了两方面的改进，提出了改进迭代算法IIS(Improved<br>Iterative Scaling)。  </p>
<h2 id="第二十一章：拼音输入法的数学原理">第二十一章：拼音输入法的数学原理</h2>
<p>1.和任何事物的发展一样，螺旋式的回归不是简单的重复，而是一种升华。  </p>
<p>2.香农第一定理：对于一个信息，任何编码的长度都不小于它的信息熵。  </p>
<h2 id="第二十二章：自然语言处理的教父马库斯和他的优秀弟子们">第二十二章：自然语言处理的教父马库斯和他的优秀弟子们</h2>
<p>1.宾夕法尼亚大学LDC语料库以及他的优秀弟子是马库斯对自然语言处理领域的重大贡献。  </p>
<p>2.柯林斯：追求完美  </p>
<p>3.布莱尔：简单才美  </p>
<h2 id="第二十三章：布隆过滤器">第二十三章：布隆过滤器</h2>
<p>1.基本流程：对于一个需要处理的元素，使用多个随机数产生器产生多个数，将各个数对<br>应的位标为1。在使用时，使用同样的随机数产生器得到多个数，然后判断响应位是否为1<br>即可。布隆过滤器的优点是快速和节省空间，确定就是有一定的误识别率。常见的补救方<br>法是再建立一个小的白名单，存储哪些可能被误判的元素。  </p>
<p>2.布隆过滤器背后的数学原理在于两个完全随机的数字冲突的概率很小，因此，可以在很<br>小的误识别率的条件下，用很好的空间存储大量信息。  </p>
<h2 id="第二十四章：马尔科夫链的扩展_—_贝叶斯网络">第二十四章：马尔科夫链的扩展 — 贝叶斯网络</h2>
<p>1.假定在这个图中马尔科夫假设成立，即每个状态只和它直接相连的状态有关，而和它间<br>接相连的状态没有直接关系，那么它就是贝叶斯网络。  </p>
<h2 id="后几章由于技术层次较高，还是看原书比较好。">后几章由于技术层次较高，还是看原书比较好。</h2>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="作者寄语">作者寄语</h1>
<p>愿科学之精神在国民中得到普及，愿中国年轻的一代涌现更多的杰出专业人才。  </p>
]]>
    
    </summary>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[YUI 学习笔记]]></title>
    <link href="http://perthcharles.github.com/2013/10/05/yui-learning/"/>
    <id>http://perthcharles.github.com/2013/10/05/yui-learning/</id>
    <published>2013-10-05T04:00:00.000Z</published>
    <updated>2014-11-04T06:26:39.000Z</updated>
    <content type="html"><![CDATA[<h3 id="工具简介">工具简介</h3>
<p>YUI是一个免费、开源的JacaScript和CSS库，能够方便的开发出交互性良好的web applications.<br>我用到的版本是YUI 3.12.0  </p>
<h3 id="Core">Core</h3>
<p>1.event<a href="http://perthcharles.github.io/yql_test/YUI_text.html#demo-1" target="_blank" rel="external">示例</a><br>提供API处理DOM event。当用户执行某些操作时，出发相应的event。常见的有click, close, keydown等。<br>这里是所有支持的<a href="http://yuilibrary.com/yui/docs/event/#event-whitelist" target="_blank" rel="external">Whitelisted DOM events</a>  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://yuilibrary.com/yui/docs/" target="_blank" rel="external">YUI documentation</a><br><a href="http://yuilibrary.com/yui/docs/guides/" target="_blank" rel="external">YUI User Guides</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="工具简介">工具简介</h3>
<p>YUI是一个免费、开源的JacaScript和CSS库，能够方便的开发出交互性良好的web applications.<br>我用到的版本是YUI 3.12.0  </p>
<h3 id="Core">Core</h3>
<p]]>
    </summary>
    
      <category term="YUI" scheme="http://perthcharles.github.com/tags/YUI/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[YQL学习笔记]]></title>
    <link href="http://perthcharles.github.com/2013/09/28/yahoo-yql/"/>
    <id>http://perthcharles.github.com/2013/09/28/yahoo-yql/</id>
    <published>2013-09-28T04:00:00.000Z</published>
    <updated>2014-11-04T06:25:46.000Z</updated>
    <content type="html"><![CDATA[<h3 id="简介">简介</h3>
<p>YQL是雅虎提供的一种类似SQL的数据查询服务。<br>设计出发点是把整个Web当成一个巨大的数据库供开发者使用。  </p>
<a id="more"></a>

<h3 id="YQL语法">YQL语法</h3>
<p>1.select语句<br>select 字段名 from 表名 where 过滤条件 [| 方法]<br>    字段名：对应于后台服务返回结果中的XML元素或是JSON对象中的属性。<br>            “*”表示选择全部的字段；多个字段名用逗号分隔<br>    表名：后台服务的名称<br>    过滤条件：声明结果中的记录应该满足的条件<br>    方法：用来对结果进行附加的处理，如排序和去重等</p>
<p>关于select的上限：<br>最大返回数量上限为5000，最长执行时间为30秒<br>对于大部分表格，默认的返回数量为10，除非在select语句中指定limit  </p>
<p>2.子select语句<br>举例：<br>    select * from flickr.photos.info<br>        where photo_id in (select id from flickr.photos.recent)</p>
<p>3.分页<br>YQL服务的返回结果的记录总数往往比较大。为了提高性能，YQL服务提供了分页功能<br>可以限制每次查询返回的记录数<br>举例：<br>    //仅获取前20个结果<br>    SELECT <em> FROM flickr.photos.search(0, 20) WHERE text=”beijing”<br>    //返回整个结果集的第11到20条记录<br>    SELECT </em> FROM flickr.photos.search WHERE text=”bei” LIMIT 10 OFFSET 10</p>
<p>4.排序和其它方法<br>可以用类似linux管道的思路来理解这些方法<br>    //sort title<br>    SELECT * FROM flickr.photos.search WHERE text=”bei” | sort(field=”title”)<br>其它方法可以查看手册  </p>
<p>5.使用功能：抽取HTML文件<br>虽然YQL服务访问的后台Web服务返回的一般是XML和JSON等结构化数据<br>YQL服务也可以用来从HTML文档中抽取数据。<br>只需要指定 HTML 页面的URL以及抽取数据所用的XPath语句YQL服务就可以完成抽取。<br>这其实就相当于能完成网页抽取的工作，不用自己写代码去获取了。 Cheers!<br>如果需要抽取的html5网页文件，则加入兼容选项，如：<br>    select * from html where url=”<a href="http://groups.yahoo.com/search?query=surfing&amp;sort=relevance" target="_blank" rel="external">http://groups.yahoo.com/search?query=surfing&amp;sort=relevance</a>“ and compat=”html5”</p>
<h3 id="使用YQL访问开方数据表格">使用YQL访问开方数据表格</h3>
<p>YQL 服务已经提供了许多内置的开放数据表格，可以直接使用。<br>通过在 YQL 控制台输入 show tables就可以查看所有内置数据表格的列表。<br>对于其它 Web 服务，如果想在 YQL 中使用，只需要提供一个描述文件即可。<br>该描述文件用来告诉 YQL 如何对该 Web 服务进行操作。  </p>
<h3 id="创建自己的YQL开方表格">创建自己的YQL开方表格</h3>
<h3 id="更多YQL">更多YQL</h3>
<p>1.使用上限<br>    YQL endpoint    /v1/public/<em>        /v1/yql/</em><br>    Hourly Cap        2,000 per IP        20,000 per IP<br>    Daily Cap        None                100,000 per day per API key</p>
<p>2.YQL语句总结<br>    select：        //retrieves data from the specified table<br>        select <em> from social.profile where guid=xyz<br>    insert:            //insert data into specified table<br>        insert into table (key1, key2) values (‘value1’, ‘value2’)<br>    update:            //updates data in the specified table<br>        update (table) set field1=value where filter<br>    delete:            //deletes data in the specified table<br>        delete from (table) where filter<br>    show tables:    //gets a list of the tables available in YQL<br>        show tables<br>    desc:            //gets a description of the table<br>        desc social.connections<br>    use:            //maps a table name to the url of an open data table<br>        use “<a href="http://myserver.com/mytable.xml" target="_blank" rel="external">http://myserver.com/mytable.xml</a>“ as mytable; select </em> from mytable where …<br>    set:            //allows you to set up key values for use within open data tables<br>        set (name)=(value);  select * from mytable where …</p>
<p>3.条件查询where<br>条件查询分为远端条件过滤和本地条件过滤<br>远端条件过滤指的是条件被back-end的Web-Service执行，远端条件查询支持：”=”和 IN 操作符<br>语法类似：input_key IN [list of one or more literals]<br>本地条件查询的过程是先从back-end的Wev-Service获取数据，然后执行条件匹配判断<br>语法类似：field comparison_operator literal  </p>
<p>举例：<br>    //单条件选择<br>    select <em> from flickr.photos.info where photo_id=’2323453235’<br>    //单条件，多匹配条件<br>    select </em> from geo.palces where text in (“asss”, “dfdfd”)<br>    //多条件选择<br>    select <em> from local.search where zip=’94085’ and query=’pizza’<br>    select </em> from local.search where zip=’94085’ or query=’pizza’<br>    //模糊查询，返回以Chinese或CHINESE开头的结果<br>    select <em> from flickr.photos.interestingness where title like ‘Chinese%’<br>    //正则表达式<br>    select </em> from flickr.photos.interestingness where title matches ‘.<em>blue.</em>‘</p>
<h3 id="xpath学习">xpath学习</h3>
<p><a href="http://www.w3school.com.cn/xpath/xpath_intro.asp" target="_blank" rel="external">XPath是一门在XML文档中查找信息的语言。XPath用于在XML文档中通过元素和属性进行导航。</a>  </p>
<p>1.XPath节点<br>在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。<br>XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。  </p>
<p><em>基本值</em>：无父或无子的节点<br><em>项目</em>：基本值或者节点  </p>
<p>节点关系包括：父节点、子节点、同胞节点、先辈节点和后代节点。这些概念类似图论中的概念。  </p>
<p>2.XPath语法<br>XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的。  </p>
<p>常用路径表达式：<br>    nodename    选取此节点的所有子节点<br>    /            从根节点选取<br>    //            从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置<br>    .            选取当前节点<br>    ..            选取当前节点的父节点<br>    @            选取属性</p>
<p>谓语（Predicates）<br>    谓语用来查找某个特定的节点或者包含某个指定的值的节点。<br>    谓语被嵌套在方括号中</p>
<p>语法支持以下通配符：  </p>
<pre><code>*        匹配任何元素节点
<span class="at_rule">@<span class="keyword">*</span>        匹配任何属性的节点
<span class="function">node</span>()    匹配任何类型的节点</span>
</code></pre><p>选取若干路径<br>通过在路径表达式中使用”|”运算符，可以选取多个路径  </p>
<p>3.XPath轴<br>轴可以用于选取特定的节点集，具体用法可以查手册  </p>
<h3 id="YQL练习">YQL练习</h3>
<p><a href="http://perthcharles.github.io/yql_test/" target="_blank" rel="external">这里</a>有几个YQL使用的实例<br>建议使用chrome浏览器查看源码并调试输出结果  </p>
<h3 id="小注：">小注：</h3>
<p>YQL服务有时候会无法正常返回查询结果，等一会再刷新就好了  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.ibm.com/developerworks/cn/web/1011_chengfu_yql/" target="_blank" rel="external">YQL - 将 Web 作为数据库来使用的查询语言</a><br><a href="http://developer.yahoo.com/yql/console/" target="_blank" rel="external">Yahoo YQL console</a><br><a href="http://www.w3school.com.cn/xpath/index.asp" target="_blank" rel="external">XPath 教程</a><br><a href="http://www.w3school.com.cn/xpath/xpath_functions.asp#accessor" target="_blank" rel="external">XPath、XQuery 以及 XSLT 函数</a><br><a href="http://oauth.net/" target="_blank" rel="external">OAuth:如果对授权机制不熟悉</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="简介">简介</h3>
<p>YQL是雅虎提供的一种类似SQL的数据查询服务。<br>设计出发点是把整个Web当成一个巨大的数据库供开发者使用。  </p>
]]>
    
    </summary>
    
      <category term="YQL" scheme="http://perthcharles.github.com/tags/YQL/"/>
    
  </entry>
  
</feed>
