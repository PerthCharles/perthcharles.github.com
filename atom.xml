<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天赋  无与伦比的坚持]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://perthcharles.github.com/"/>
  <updated>2015-08-30T13:32:45.135Z</updated>
  <id>http://perthcharles.github.com/</id>
  
  <author>
    <name><![CDATA[Perth Charles]]></name>
    <email><![CDATA[zhongbincharles@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[TCP timestamp]]></title>
    <link href="http://perthcharles.github.com/2015/08/27/timestamp-intro/"/>
    <id>http://perthcharles.github.com/2015/08/27/timestamp-intro/</id>
    <published>2015-08-27T13:00:35.000Z</published>
    <updated>2015-08-30T13:31:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>tcp_timestamps是在<a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323</a>中定义的一个TCP选项。<br>这篇wiki介绍一下timestamps的设计目的和相关原理，尤其强调一些比较tricky的地方。<br><a id="more"></a>  </p>
<hr>
<h3 id="关于RFC1323">关于RFC1323</h3>
<p>这是一篇介绍针对High-bandwidth, Long delay链路设计的一些TCP扩展选项的资料。强烈推荐阅读！<br>但这篇RFC其实已经被<a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC7323</a>所取代，不过RFC1323对于了解timestamp相关的基本概念来说还是足够了的。关于RFC7323也会在后续的wiki中详细的介绍。  </p>
<p>High-bandiwidth, Long delay链路面临的性能问题  </p>
<pre><code>a. Window Size limit  
TCP头部仅16字节用于存放receive window，这在高BDP的链路中往往是不够用的  
解决办法就是引入window scale选项，然后real<span class="emphasis">_rcv_</span>wnd = rcv<span class="emphasis">_wnd_</span>in<span class="emphasis">_tcp_</span>header * (2^win_scale)  

b. Recovery from Losses  
当BDP很大时，意味着需要更大的cwnd来充分利用带宽。如果发生网络丢包，则对这类链路的影响是巨大的。  
优化办法(真的不能说解决T_T)就是引入[<span class="link_label">SACK</span>](<span class="link_url">https://tools.ietf.org/html/rfc2018</span>)机制，来为发送方重传提供更加准确的信息。  

c. Round-Trip Measurement  
TCP作为可靠的传输协议，一个重要的机制就是超时重传。因此如何计算一个准确(合适)的
RTO对于TCP性能有着重要的影响。而tcp_timestamp选项正是<span class="emphasis">*主要*</span>为此而设计的。  
</code></pre><p>上一句话强调”主要”是因为tcp_timestamp还被用于PAWS机制，而这一重要用途却时常被忽略。<br>作为一个可靠的传输协议，TCP除了考虑如何应对性能问题，还需要考虑可靠性问题。<br>即使这些问题发生的概率较低，PAWS就是其中一个例子。<br>PAWS(Protect Against Wrapped Sequence numbers)一句话解释如下，后面会详细介绍  </p>
<pre><code>在高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped)
就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包！
</code></pre><p>补充一句：什么用wrapped形容序列号被重复使用？因为压圈了呀 :)  </p>
<hr>
<h3 id="tcp_timestamps_的设计">tcp_timestamps 的设计</h3>
<p>tcp_timestamps的本质是记录数据包的发送时间。基本的步骤如下  </p>
<pre><code><span class="bullet">1. </span>发送方在发送数据时，将一个timestamp(表示发送时间)放在包里面
<span class="bullet">2. </span>接收方在收到数据包后，在对应的ACK包中将收到的timestamp返回给发送方(echo back)
<span class="bullet">3. </span>发送发收到ACK包后，用当前时刻now - ACK包中的timestamp就能得到准确的RTT
</code></pre><p>当然实际运用中要考虑到RTT的波动，因此有了后续的(Round-Trip Time Measurement)RTTM机制</p>
<p>TCP Timestamps Option (TSopt)具体设计如下  </p>
<pre><code>Kind: 8             // 标记唯一的选项类型，比如window scale是3
<span class="header">Length: 10 bytes    // 标记Timestamps选项的字节数
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="header">| Kind=8 | Length=10 | TS Value (TSval) | TS ECho Reply (TSecr) |
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="code">    1          1             4                       4</span>
</code></pre><p>timestamps一个双向的选项，当一方不开启时，两方都将停用timestamps。<br>比如client端发送的SYN包中带有timestamp选项，但server端并没有开启该选项。<br>则回复的SYN-ACK将不带timestamp选项，同时client后续回复的ACK也不会带有timestamp选项。<br>当然，如果client发送的SYN包中就不带timestamp，双向都将停用timestamp。  </p>
<hr>
<h3 id="为什么需要timestamp">为什么需要timestamp</h3>
<p>如果没有timestamp，RTT的计算会怎样？  </p>
<pre><code><span class="number">1</span>. <span class="constant">TCP层</span>在发送出一个<span class="constant">SKB时</span>，使用skb-&gt;<span class="keyword">when</span>记录发送出去的时间
<span class="number">2</span>. <span class="constant">TCP层</span>在收到<span class="constant">SKB数</span>据包的确认时，使用now - skb-&gt;<span class="keyword">when</span>来计算<span class="constant">RTT</span>
</code></pre><p>但上面的机制在丢包发生时会有问题，比如</p>
<pre><code><span class="bullet">1. </span>TCP层第一次发送SKB的时间是send<span class="emphasis">_time1, TCP层重传一个数据包的时间是send_</span>time2
<span class="bullet">2. </span>当TCP层收到SKB的确认包的时间是recv_time
</code></pre><p>但是RTT应该是 (recv_time - send_time1)呢，还是(recv_time - send_time2)呢？  </p>
<p>以上两种方式都不可取！因为无法判断出recv_time对应的ACK是确认第一次数据包的发送还是确认<br>重传数据包。因此TCP协议栈只能选择非重传数据包进行RTT采样。但是当出现严重丢包(比如整个窗口全部丢失)时，就完全没有数据包可以用于RTT采样。这样后续计算SRTT和RTO就会出现较大的偏差。  </p>
<p>timestamp选项很好的解决了上述问题，因为ACK包里面带的TSecr值，一定是触发这个ACK的数据包在发送端发送的时间。不管数据包是否重传都能准确的计算RTT(前提是TSecr遵循RTTM中的计算原则)。  </p>
<p>当然timestamp不仅解决了RTT计算的问题，还很好的为PAWS机制提供的信息依据。  </p>
<hr>
<h3 id="开启timestamp会有什么负面影响?">开启timestamp会有什么负面影响?</h3>
<p>这部分内容以后会根据更多的实际经验来补充。目前列举一些找到的分析。  </p>
<pre><code><span class="number">1.</span> <span class="number">10</span>字节的TCP header开销

<span class="number">2.</span> The TCP Timestamp when enabled will allow you <span class="built_in">to</span> guess <span class="operator">the</span> uptime
   <span class="operator">of</span> <span class="operator">a</span> target <span class="keyword">system</span> (nmap v -O . Knowing how <span class="keyword">long</span> <span class="operator">a</span> <span class="keyword">system</span> has been
   up will enable you <span class="built_in">to</span> determine whether security patches that <span class="built_in">require</span>
   reboot has been applied <span class="operator">or</span> <span class="operator">not</span>.
        引自：<span class="keyword">http</span>://stackoverflow.com/questions/<span class="number">7880383</span>/what-benefit-is-conferred-<span class="keyword">by</span>-tcp-timestamp
        注：如果通过热补丁修复bug，是否就能够避免这个问题？  
</code></pre><hr>
<h3 id="什么是RTTM">什么是RTTM</h3>
<p>RTTM规定了一些使用TSecr计算RTT的原则，具体如下<br>(英文水平有限，为保持原意就使用RFC中的原话了)  </p>
<pre><code><span class="operator">a</span>.  A TSecr <span class="built_in">value</span> received <span class="operator">in</span> <span class="operator">a</span> segment is used <span class="built_in">to</span> update <span class="operator">the</span>
    averaged RTT measurement only <span class="keyword">if</span> <span class="operator">the</span> segment acknowledges
    some <span class="built_in">new</span> data
b.  The data-sender TCP must measure <span class="operator">the</span> <span class="keyword">effective</span> RTT, including <span class="operator">the</span> additional
    <span class="built_in">time</span> due <span class="built_in">to</span> delayed ACKs. Thus, when delayed ACKs are <span class="operator">in</span> use, <span class="operator">the</span> receiver should
    reply <span class="operator">with</span> <span class="operator">the</span> TSval field <span class="built_in">from</span> <span class="operator">the</span> earliest
c.  An ACK <span class="keyword">for</span> <span class="operator">an</span> out-<span class="operator">of</span>-order segment should therefore contain <span class="operator">the</span> 
    timestamp <span class="built_in">from</span> <span class="operator">the</span> most recent segment that advanced <span class="operator">the</span> window
d.  The timestamp <span class="built_in">from</span> <span class="operator">the</span> latest segment (which filled <span class="operator">the</span> hole) must be echoed
        在ACK被重传的数据时，应该使用重传数据包中的TSval进行回复
</code></pre><p>如果对以上的特殊情况有疑问，还请直接去看RFC，里面有example解释。  </p>
<p>最后，实际上计算RTO除了以上使用TSecr的原则外，还有一些更复杂的计算方法<a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC 7323</a>。<br>比如对于每一个RTT采样R，  </p>
<pre><code><span class="constant">RTTVAR</span> = (<span class="number">1</span> - beta) * RTTVAR + beta * |SRTT - R|
<span class="constant">SRTT</span> = (<span class="number">1</span> - alpha) * SRTT + alpha * R
</code></pre><hr>
<h3 id="什么是PAWS">什么是PAWS</h3>
<p>PAWS — Protect Againest Wrapped Sequence numbers<br>目的是解决在高带宽下，TCP序号可能被重复使用而带来的问题。  </p>
<p>PAWS同样依赖于timestamp，并且假设在一个TCP流中，<em>按序</em>收到的所有TCP包的timestamp值<br>都是线性递增的。而在正常情况下，每条TCP流<em>按序</em>发送的数据包所带的timestamp值<br>也确实是线性增加的。<br>至于为什么要强调<em>按序</em>，请先自行思考。:)  </p>
<p>首先给出几个变量的定义，之后具体介绍PAWS的工作过程  </p>
<pre><code>Per-Connection State Variables
<span class="label">    TS.Recent:</span>       Latest received Timestamp
<span class="label">    Last.ACK.sent:</span>   Last ACK field sent

<span class="preprocessor">Option</span> Fields <span class="keyword">in</span> Current <span class="built_in">Segment</span>
<span class="label">    SEG.TSval:</span>   TSval field from TSopt <span class="keyword">in</span> current <span class="built_in">segment</span>.
<span class="label">    SEG.TSecr:</span>   TSecr field from TSopt <span class="keyword">in</span> current <span class="built_in">segment</span>.
</code></pre><p>TS.Recent存放着<em>按序</em>达到的所有TCP数据包的最晚的一个时间戳，即只有在<br><code>SEG.SEQ &lt;= Last.ACK.sent &lt; SEG.SEG + SEG.LEN</code>(有新的数据被按序确认了)时，<br>才会去更新TS.Recent的值。  </p>
<pre><code>假设三个数据包的*第一次*发送时间分别是<span class="literal">A</span>，B和C(<span class="literal">A</span> &lt; B &lt; C)，但<span class="literal">A</span>和C含有相同的序列号。
而<span class="literal">A</span>数据包由于某种原因，在阻塞在了网络中，因此发送方进行了重传，重传时间为A2

PAWS要解决的主要问题就是：
    当接收端在接收到A2后，又接着确认到了数据包B，下一个想接收的数据是数据包C
    此时如果收到了数据包<span class="literal">A</span>(<span class="literal">A</span>从阻塞中恢复过来了，但并未真的丢失)，
    由于<span class="literal">A</span>与C的序列号是相同的。如果没有别的保护措施就会出现数据紊乱，没有做到可靠传输

PAWS的做法就是，如果收到的一个TCP数据包的timestamp值小于TS.Recnt，则会丢弃该数据包。  
因此数据包<span class="literal">A</span>到达接收方后，接收方的TS.Recent应该是数据包B中的timestamp
而<span class="literal">A</span> &lt; B，故<span class="literal">A</span>包就会被丢弃。而真正有效的数据C到达接收后，由于B &lt; C，因此能被正常接收
</code></pre><p>PAWS的更多细节  </p>
<pre><code><span class="number">1.</span> It is recommended that RST segments NOT carry timestamps, <span class="operator">and</span> that
RST segments be acceptable regardless <span class="operator">of</span> their timestamp.

<span class="number">2.</span> PAWS is defined strictly <span class="operator">within</span> <span class="operator">a</span> single connection; <span class="operator">the</span> <span class="keyword">last</span> timestamp is
TS.Recent is kept <span class="operator">in</span> <span class="operator">the</span> connection control block, <span class="operator">and</span>
discarded when <span class="operator">a</span> connection is closed.

<span class="number">3.</span> An additional mechanism could be added <span class="built_in">to</span> <span class="operator">the</span> TCP, <span class="operator">a</span> per-host
cache <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">last</span> timestamp received <span class="built_in">from</span> <span class="keyword">any</span> connection.
This <span class="built_in">value</span> could <span class="keyword">then</span> be used <span class="operator">in</span> <span class="operator">the</span> PAWS mechanism <span class="built_in">to</span> reject
old duplicate segments <span class="built_in">from</span> earlier incarnations <span class="operator">of</span> <span class="operator">the</span>
connection, <span class="keyword">if</span> <span class="operator">the</span> timestamp clock can be guaranteed <span class="built_in">to</span> have
ticked <span class="keyword">at</span> least once since <span class="operator">the</span> old connection was <span class="built_in">open</span>.
</code></pre><p>从第三点可以看到，如果针对per-host的使用PAWS中的机制，则会解决TIME-WAIT中考虑的上一个流<br>的数据包在下一条流中被当做有效数据包的情况，这样就没有必要等待2*MSL来结束TIME-WAIT了。<br>只要等待足够的RTO，解决好需要重传最后一个ACK的情况就可以了。<br>因此Linux就实现了这样一种机制：</p>
<pre><code>当timestamp和tw_recycle两个选项同时开启的情况下，开启per-host的PAWS机制。
从而能快速回收处于<span class="typename">TIME</span>-<span class="keyword">WAIT</span>状态的TCP流。
</code></pre><p>但这样真的就能完美的解决令无数人头疼的TIME-WAIT吗？答案是否定的！<br>因为公网中存在太多的NAT设置，当使用per-host的PAWS机制时，是无法保证timestamp是线性递增这一假设的。因为使用同一个NAT地址的两个真实的机器，他们的timestamp是不能保证同步的(其实一致也没有用，NAT就是per-host PAWS机制的死敌)。<br>关于这个问题也会在以后的一篇介绍TIME-WAIT的wiki中进一步详细介绍。  </p>
<hr>
<h3 id="总结">总结</h3>
<pre><code>timestamp为TCP/IP协议栈提供了两个功能：  
    <span class="operator">a</span>. 更加准确的RTT测量数据，尤其是有丢包时  <span class="comment">-- RTTM  </span>
    b. 保证了在极端情况下，TCP的可靠性        <span class="comment">-- PAWS  </span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">Documentation: ip-sysctl.txt</a><br><a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323: TCP Extensions for High Performance</a><br><a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC 7323: TCP Extensions for High Performance</a><br><a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="external">SACK</a><br><a href="http://stackoverflow.com/questions/7880383/what-benefit-is-conferred-by-tcp-timestamp" target="_blank" rel="external">What benefit is conferred by TCP timestamp?</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>tcp_timestamps是在<a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323</a>中定义的一个TCP选项。<br>这篇wiki介绍一下timestamps的设计目的和相关原理，尤其强调一些比较tricky的地方。<br>]]>
    
    </summary>
    
      <category term="timestamp" scheme="http://perthcharles.github.com/tags/timestamp/"/>
    
      <category term="RTTM" scheme="http://perthcharles.github.com/tags/RTTM/"/>
    
      <category term="PAWS" scheme="http://perthcharles.github.com/tags/PAWS/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列五：小知识点及FAQ]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/git-faq/"/>
    <id>http://perthcharles.github.com/2015/08/25/git-faq/</id>
    <published>2015-08-25T07:38:40.000Z</published>
    <updated>2015-08-25T14:32:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>git作为一个强大的工具，也就意味着它也同样的复杂。<br>长期使用下来难免会遇到很多奇奇怪怪的问题和一些小的知识点，<br>这个帖子就用来记录一下那些年某人踩过的的坑T_T  </p>
<p>这篇会慢慢更新，当某个点内容较多后，会独立出去成为一篇独立的wiki<br><a id="more"></a>  </p>
<hr>
<h3 id="小知识点">小知识点</h3>
<hr>
<h4 id="Fast_forward_merge">Fast forward merge</h4>
<p>直接上图例，不多解释  </p>
<pre><code>            <span class="comment">master</span>
               <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span>        <span class="comment">issue03</span>
                <span class="comment">\</span>          <span class="comment">↓</span>
                 <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span>

                            <span class="comment">master</span>
                              <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span>
                              <span class="comment">↑</span>
                            <span class="comment">issue03</span>
</code></pre><p>以上就是一个fast forward merge，那什么不是fast forward merge呢？请看下图  </p>
<pre><code>            <span class="comment">master</span>
               <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span>        <span class="comment">issue03</span>
           <span class="comment">\</span>               <span class="comment">↓</span>
            <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">H</span>

                              <span class="comment">master</span>
                              <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">I</span>
           <span class="comment">\</span>                <span class="comment">/</span> <span class="comment">↑</span>
            <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">H</span>  <span class="comment">issue03</span>
</code></pre><h4 id="Three-way_merge">Three-way merge</h4>
<p>two-way merge只用两个档案进行合并(svn默认是 two-way merge)<br>three-way merge 处理要合并的两个档案，还会奖赏两个档案的共同祖先。如此可大大减少人为处理conflict的情况。<br>为什么能减少人为处理conflict的情况呢？一图胜千言。<br><img src="/resources/three-way-merge.png" alt="Three-way merge">  </p>
<h4 id="实用alias">实用alias</h4>
<pre><code>// 每个commit显示一行，显示图形化的commit history，显示简短的SHA1
alias <span class="keyword">log</span>=<span class="string">"git log --oneline --graph --decorate --color=always"</span>
// 显示所有branch的commit history
alias logg=<span class="string">"git log --graph --all --format=format:'<span class="variable">%C</span>(bold blue)<span class="variable">%h</span><span class="variable">%C</span>(reset) - <span class="variable">%C</span>(bold green)(<span class="variable">%ar</span>)<span class="variable">%C</span>(reset) <span class="variable">%C</span>(white)<span class="variable">%s</span><span class="variable">%C</span>(reset) <span class="variable">%C</span>(bold white)—     <span class="variable">%an</span><span class="variable">%C</span>(reset)<span class="variable">%C</span>(bold yellow)<span class="variable">%d</span><span class="variable">%C</span>(reset)' --abbrev-commit --date=relative"</span>
</code></pre><h4 id="坚持新开branch进行开发需要遵循的原则">坚持新开branch进行开发需要遵循的原则</h4>
<pre><code>1. 不要直接在任何已经与远端建立track关系的branch中进行修改  
    目的：便于维护整洁的<span class="operator"><span class="keyword">commit</span> history

<span class="number">2.</span> feature branch的周期越短越好，不要同时开太多feature branch

<span class="number">3.</span> 在push之前先将本地分支与远端分支同步，推荐使用rebase的方式<span class="keyword">merge</span>

<span class="number">4.</span> 只有在需要push时（如，完成一个功能开发），才将开发分支与主干分支进行合并  
    目的：便于识别<span class="keyword">commit</span>是否push到远端，便于维护整洁的主干<span class="keyword">commit</span> history

<span class="number">5.</span> 分支命名规则
    与远端同步的分支，名字与远端分支一样。如dev -&gt; origin/dev
    进行开发的分支命名不严格限制，但不得与上一类分支重名。
        通过git <span class="keyword">log</span> <span class="comment">--graph即可看出开发分支与主干分支的关系</span></span>
</code></pre><hr>
<h3 id="FAQ">FAQ</h3>
<hr>
<h4 id="如何在git中添加空文件夹">如何在git中添加空文件夹</h4>
<p>git木人的情况下空目录是不会commit出去的，这在某些情况下会遇到问题（比如Rails如果少了log或tmp目录会不能启动）。<br>解决办法就是在空目录下面touch一个空的档案，一般是.gitkeep。  </p>
<h4 id="为什么说懂图论对理解git很有帮助">为什么说懂图论对理解git很有帮助</h4>
<p>理解Git最好的办法，就是用图论中的节点和指针来思考，所有的git的指令操作，<br>都是操作这些节点，新增、修改、删除、变更。<br>首先Git对于所有的内容管理可以理解为一张有向无环图，<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out" target="_blank" rel="external">这是一篇很好解释文章</a>。<br>同时就自身体会而言，rebase中的base可以理解为两个branch的最小公共祖先。<br>而Fast forward merge可以理解为两个branch合并时，有一个branch是指向这个<br>base节点的。  </p>
<h4 id="如何撤销merge操作">如何撤销merge操作</h4>
<p>如果是刚刚merge完，则可以直接<code>git reset --hard HEAD~</code><br>如果已经添加了很多commit后，才想起来撤销merge，那就该好好反省了。  </p>
<h4 id="如何合理的操作处理分支">如何合理的操作处理分支</h4>
<pre><code><span class="comment">// push 操作</span>
<span class="array"># git push origin b</span>1:rb1    <span class="comment">// 将本地的b1分支推送到远端分支rb1，当前分支不需要一定是b1</span>
<span class="array"># git push origin b</span>1        <span class="comment">// 将本地的b1分支推送到远端分支b1，如果远端不存在b1则新建一个</span>
<span class="array"># git push </span>-u origin b1     <span class="comment">// 第一次push时指定好track，之后就可以直接git push了</span>
<span class="array"># git push                  </span><span class="comment">// 如果是在一个已经建立了track关系的local branch，则可直接push</span>
<span class="array"># git push origin </span>:rb1      <span class="comment">// 删除远端分支rb1</span>

<span class="comment">// fetch 操作</span>
<span class="array"># git fetch </span>-a                  <span class="comment">// 获取远端所有分支</span>
<span class="array"># git fetch origin b</span>2           <span class="comment">// 获取远端分支b2</span>
<span class="array"># git branch b</span>2 origin/b2       <span class="comment">// 随后创建一个本地的b2分支与远端分支建立联系，最好名字一样，否则push时要手动指定</span>
<span class="array"># git checkout </span>--track -b b2 origin/b2  <span class="comment">// 或者直接checkout到一个新建的b2分支   </span>

<span class="comment">// merge 操作</span>
<span class="array"># git cherry</span>-pick <span class="number">332</span>sd3f3      <span class="comment">// 仅将选定的commit apply/patch进入当前分支，相当于首先将332sd3fs打包成一个git格式的patch，然后apply进来。很干净的一种用法</span>
<span class="array"># git merge b</span>1                  <span class="comment">// 将b1分支与current分支合并</span>

<span class="comment">// pull 操作 = fetch + merge</span>
<span class="array"># git pull origin b</span>10   <span class="comment">// 将远端的b10分支与当前分支进行合并，等价于下面两句</span>
    <span class="array"># git fetch origin b</span>10
    <span class="array"># git merge origin</span>/b10
<span class="array"># git pull </span>--rebase origin b10  <span class="comment">// 推荐使用rebase方式合并：本地分支及它track的远端分支</span>

<span class="comment">// remote 操作</span>
<span class="array"># git remote prune origin   </span><span class="comment">// 删除不存在远端仓库的分支</span>
</code></pre><h4 id="如何为一个新建的git添加remote">如何为一个新建的git添加remote</h4>
<pre><code><span class="comment">// 添加remote的仓库地址，origin是名字</span>
<span class="array"># git remote add origin git</span>:<span class="comment">//example.com/a.git    </span>
</code></pre><h4 id="如何恢复某个被修改过的文件">如何恢复某个被修改过的文件</h4>
<pre><code><span class="preprocessor"># git checkout file-name    </span>
</code></pre><h4 id="如何整理git_working_area文件">如何整理git working area文件</h4>
<pre><code><span class="array"># git clean </span>-f          <span class="comment">// 删除未被git管理的文件</span>
<span class="array"># git clean </span>-f -d       <span class="comment">// 同时将未被git管理的目录也删除</span>
<span class="array"># git clean </span>-f -X       <span class="comment">// 仅删除被.gitignore忽略的文件</span>
<span class="array"># git clean </span>-f -x       <span class="comment">// 同时删除被.gitignore忽略的文件和未被管理的文件</span>
<span class="array"># git clean </span>-f -x -d    <span class="comment">// 删除所有未被git管理的文件和目录</span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://liujin.me/blog/2015/05/25/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">Git 常用命令</a><br><a href="http://www.slideshare.net/epatey/perforce-convergence-vs-divergence/10" target="_blank" rel="external">The essence of a three-way merge</a><br><a href="https://ihower.tw/blog/archives/2620" target="_blank" rel="external">開branch 分支和操作遠端repo</a><br><a href=""></a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>git作为一个强大的工具，也就意味着它也同样的复杂。<br>长期使用下来难免会遇到很多奇奇怪怪的问题和一些小的知识点，<br>这个帖子就用来记录一下那些年某人踩过的的坑T_T  </p>
<p>这篇会慢慢更新，当某个点内容较多后，会独立出去成为一篇独立的wiki<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列四：在push之前对本地commit进行整理]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/clean-commit-log-before-push/"/>
    <id>http://perthcharles.github.com/2015/08/25/clean-commit-log-before-push/</id>
    <published>2015-08-25T03:58:42.000Z</published>
    <updated>2015-08-25T08:12:34.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在系列三中描述了commit消息的规范，但在实际操作中很难时刻做到那么严格的<br>控制，尤其是在本地做一些实验性的工作的时候。<br>但是如果需要push到远端去，则就必须保证commit消息的规范和commit的独立性。<br>因此就有了这样一个需求：在执行git push之前对本地的commit日志进行整理。<br><a id="more"></a>  </p>
<hr>
<h3 id="一个好习惯">一个好习惯</h3>
<p>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>重要的事情说三遍。<br>那为什么在git push之后不宜使用这些命令呢？<br>主要是因为本文设计到的命令都会重新提交commit，尽管有commit msg有时候不会变，但commit对应的SHA1哈希值会被改变。如果是已经push了的commit被改变了SHA1，则会造成比较严重的混乱。    </p>
<p>所以这里推荐一个好习惯  </p>
<pre><code>保持重要分支(如master)与远端的同步，开发一定要新开分支。  
</code></pre><p>这样一来就能够快速的识别那些属于还未push的本地commit。<br>接下来就详细介绍整理本地commit的几个重要命令：amemd, reset和rebase  </p>
<hr>
<h3 id="amend">amend</h3>
<p>amend会使用一个新的commit去替换最近的一次commit。<br>amend适用于：<br>a. 在提交commit后，才发现漏掉了某些修改，文件的情况<br>b. 修正一些typo  </p>
<pre><code><span class="comment">// 先进行一些修改，然后使用--amend选项重新提交一次commit</span>
<span class="array"># git commit </span>-a --amend             <span class="comment">// 弹出编辑窗口，重新提交新commit</span>
<span class="array"># git commit </span>-a --amend -C HEAD     <span class="comment">// 直接上一个commit消息</span>
</code></pre><hr>
<h3 id="reset">reset</h3>
<p>amend仅能替换最近一次commit，功能不够强大。比如想要快速的将working tree的修改和最近的两次commit合并得到一个新的commit则需要用到reset啦。<br>reset适用于：<br>a. 需要修改多个commit的情况，但也受限于修改从HEAD~开始连续的多个commit<br>b. 完全的删除前几个commit  </p>
<pre><code><span class="array"># git reset </span>--soft HEAD~<span class="number">2</span>       <span class="comment">// 删掉前两个commit，并保留文件更改</span>
<span class="array"># git reset </span>--hard HEAD~<span class="number">2</span>       <span class="comment">// 删掉前两个commit，并删除文件更改</span>
</code></pre><p>另外，万一如果需要修改的commit已经push出去了（是否应该避免？），又最好不要reset，那么该怎么做呢？<br>那就需要使用revert命令，revert命令会接着重新提交一个新的commit，用以回滚上一个commit的修改。有点负负得正的感觉。  </p>
<hr>
<h3 id="rebase">rebase</h3>
<p>reset受限于只能将从HEAD~开始的连续多个commit删除或(人工)合并。也还是不够强大。比如想要合并HEAD~2到HEAD~3的commit，删除HEAD~4的commit，则需要使用到rebase命令。<br>那到底什么是rebase呢？  </p>
<pre><code>rebase的核心含义就是重新设定基准！  
</code></pre><p>什么意思呢？<br>git对于commit的管理可以理解为一个有向无环图，你的某个branch一定是从另一个分支的某个节点开始分离出来的。比如下面情况下的dev分支的base就可以理解是B节点。<br>更专业的说法应该是：B是E(dev)和C(master)的最小公共祖先。    </p>
<pre><code><span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span>   &lt;<span class="comment">=</span> <span class="comment">master</span>
      <span class="comment">\</span>
       <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">E</span> &lt;<span class="comment">=</span> <span class="comment">dev</span>
</code></pre><p>rebase可以用于干什么？<br>a. 仅修改某些commit的msg<br>b. 变更commit顺序<br>c. 删掉某一个commit<br>d. 修改某一个commit对应的内容</p>
<p>rebase的基本命令就是<code>git rebase -i HEAD~n</code>啦，具体的操作流程在执行的时候都有详细的引导，这里就不再重复。想了解细节的推荐看<a href="https://help.github.com/articles/using-git-rebase/" target="_blank" rel="external">这篇tutorial</a> — 其实更推荐找个git仓库实践一把。</p>
<p>下面来介绍一下怎样处理常见的rebas冲突，至于rebase进阶用法，将在后续的wiki上介绍。  </p>
<h4 id="解决rebase冲突">解决rebase冲突</h4>
<p>当发生rebase无法顺利进行的时候，有以下几种选择：  </p>
<pre><code><span class="comment">// a. 放弃rebase  </span>
<span class="preprocessor"># git rebase --abort</span>
<span class="comment">// b. 忽视冲突  -- 一般很少用</span>
<span class="preprocessor"># git rebase --skip</span>

<span class="comment">// c. 解决冲突</span>
<span class="preprocessor"># git status                // 查看冲突类型，常见的是编辑冲突</span>
<span class="preprocessor"># vim conflict-file.md      // 编辑冲突文件</span>
<span class="preprocessor"># git add conflict-file.md  // 重新添加冲突文件</span>
<span class="preprocessor"># git rebase --continue     // 继续rebase</span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html" target="_blank" rel="external">rolling back changes with revert</a><br><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="external">Git 版本控制系統3 - 還沒 push 前可以做的事</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在系列三中描述了commit消息的规范，但在实际操作中很难时刻做到那么严格的<br>控制，尤其是在本地做一些实验性的工作的时候。<br>但是如果需要push到远端去，则就必须保证commit消息的规范和commit的独立性。<br>因此就有了这样一个需求：在执行git push之前对本地的commit日志进行整理。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列三：commit消息规范]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/git-commit-log-format/"/>
    <id>http://perthcharles.github.com/2015/08/25/git-commit-log-format/</id>
    <published>2015-08-25T03:24:27.000Z</published>
    <updated>2015-08-25T03:52:57.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>维护一个良好的commit消息格式和规范，是一个优秀项目的重要前提。<br>本文就先来谈谈commit消息到底该怎么提交。<br><a id="more"></a>  </p>
<hr>
<h3 id="提交commit的基本原则">提交commit的基本原则</h3>
<pre><code><span class="bullet">1. </span>以一个小功能、小改进或一个bug fixed为单位
<span class="bullet">2. </span>对应的unit test 程序放在同一个commit中
<span class="bullet">3. </span>不相关的代码修改不要放在同一个commit
<span class="bullet">4. </span>语法错误的半成品程序不能commit
</code></pre><hr>
<h3 id="commit消息格式">commit消息格式</h3>
<p>这部分内容已经在具体的例子：<a href="http://perthcharles.github.io/2015/08/14/manage-project-code-like-linux-kernel/" target="_blank" rel="external">像linux kernel一样管理你的项目</a>描述过。<br>这里算是正式的整理进入wiki页面了。<br>至于如何保证做到这么干净利落的commit消息日志，则请移步后续对于rebase等命令的分析。commit的消息格式如下  </p>
<pre><code>第一行用一句简短的话总结这个<span class="operator"><span class="keyword">commit</span>  

第一行最好用一个描述性的前缀开始，比如  
  <span class="string">"net:"</span>表示针对net子系统的修改  
  <span class="string">"fix:"</span>表示这是一个bug fix  

第二行为空行

最后可以增加一些详细的描述，用以解释<span class="keyword">commit</span>具体干了什么，为什么这么干  </span>
</code></pre><p>commit message格式的一个模板如下，为保持原文含义，直接贴上英文版。  </p>
<pre><code>Short (<span class="number">50</span> <span class="keyword">chars</span> <span class="operator">or</span> less) summary <span class="operator">of</span> changes

More <span class="keyword">detailed</span> explanatory <span class="keyword">text</span>, <span class="keyword">if</span> necessary.  Wrap <span class="keyword">it</span> <span class="built_in">to</span>
about <span class="number">72</span> <span class="keyword">characters</span> <span class="operator">or</span> so.  In some contexts, <span class="operator">the</span> <span class="keyword">first</span>
<span class="built_in">line</span> is treated <span class="keyword">as</span> <span class="operator">the</span> subject <span class="operator">of</span> <span class="operator">an</span> email <span class="operator">and</span> <span class="operator">the</span> rest <span class="operator">of</span>
<span class="operator">the</span> <span class="keyword">text</span> <span class="keyword">as</span> <span class="operator">the</span> body.  The blank <span class="built_in">line</span> separating <span class="operator">the</span>
summary <span class="built_in">from</span> <span class="operator">the</span> body is critical (unless you omit <span class="operator">the</span> body
entirely); tools like rebase can <span class="built_in">get</span> confused <span class="keyword">if</span> you run
<span class="operator">the</span> <span class="constant">two</span> together.

Further paragraphs come <span class="keyword">after</span> blank <span class="keyword">lines</span>.

  - Bullet points are okay, too

  - Typically <span class="operator">a</span> hyphen <span class="operator">or</span> asterisk is used <span class="keyword">for</span> <span class="operator">the</span> bullet,
    preceded <span class="keyword">by</span> <span class="operator">a</span> single <span class="constant">space</span>, <span class="operator">with</span> blank <span class="keyword">lines</span> <span class="operator">in</span>
    between, but conventions vary here
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>维护一个良好的commit消息格式和规范，是一个优秀项目的重要前提。<br>本文就先来谈谈commit消息到底该怎么提交。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列二：手动提交一个commit]]></title>
    <link href="http://perthcharles.github.com/2015/08/24/commit-a-simple-manually/"/>
    <id>http://perthcharles.github.com/2015/08/24/commit-a-simple-manually/</id>
    <published>2015-08-24T13:04:02.000Z</published>
    <updated>2015-08-25T03:01:40.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>想要深入的了解一个工具，就必须完一些比较hack的用法。<br>为了更好的了解git内部的工作机制，本文就试图通过手动的编辑.git目录下的<br>文件，来完成一次commit的提交。  </p>
<a id="more"></a>  

<hr>
<h3 id="-git目录下面的文件">.git目录下面的文件</h3>
<pre><code><span class="comment"># git --version  // 当前git版本</span>
    git version 2.3.2 (Apple Git-55)
<span class="comment"># ls -1 .git</span>
<span class="constant">objects</span>     &lt;= 
branches    description info    refs

<span class="constant">HEAD</span>            &lt;= 存放当前branch的HEAD指针
<span class="constant">branches</span>        &lt;= 新版git没有使用该目录
<span class="constant">config</span>          &lt;= 本地git仓库的配置文件
<span class="constant">description</span>     &lt;= 仅用于gitweb程序
<span class="constant">hooks</span>           &lt;= 一定在特定时间发生后被调用的脚本，可理解为钩子函数
<span class="constant">index</span>           &lt;= 文件暂存区信息
info/exclude    &lt;= 功能类似.gitignore的全局性排除文件
<span class="constant">objects</span>         &lt;= 存放真实的数据文件的地方，文件名是SHA1哈希值
refs/heads      &lt;= 存放各个分支的HEAD指针
refs/tags       &lt;= 存放各个tag的commit指针
refs/remotes    &lt;= 存放remote分支的HEAD指针
</code></pre><p>通过分析可以看到，对于一个普通的commit而言，比较相关的应该是objects和HEAD指针  </p>
<hr>
<h3 id="正常的commit过程">正常的commit过程</h3>
<pre><code><span class="preprocessor"># echo "hello world" &gt; hello</span>
<span class="preprocessor"># git add hello</span>
<span class="preprocessor"># git commit -am "add file"</span>
</code></pre><p>在接下来的内容中，将介绍如何在直接编辑.git目录文件的情况下达到与上面命令一样的效果。  </p>
<hr>
<h3 id="手动提交一个commit的步骤">手动提交一个commit的步骤</h3>
<p>git存储内容时，会有一个头部信息一并被保存。<br>比如如果是要存储”hello world\n”字符串，可以通过以下ruby脚本得到  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/ruby</span></div><div class="line"></div><div class="line"><span class="built_in">require</span> <span class="string">'digest/sha1'</span></div><div class="line"><span class="built_in">require</span> <span class="string">'zlib'</span></div><div class="line"><span class="built_in">require</span> <span class="string">'fileutils'</span></div><div class="line"></div><div class="line">content = <span class="string">"hello world\n"</span></div><div class="line">header = <span class="string">"blob #{content.length}\0"</span></div><div class="line">store = header + content</div><div class="line"></div><div class="line">sha1 = Digest::SHA1.hexdigest(store)</div><div class="line">puts <span class="string">"sha1:"</span> + sha1</div><div class="line"></div><div class="line">zlib_content = Zlib::Deflate.deflate(store)</div><div class="line">puts <span class="string">"zlib_contet:"</span> + zlib_content</div><div class="line"></div><div class="line">path = <span class="string">'.git/objects/'</span> + sha1[<span class="number">0</span>,<span class="number">2</span>] + <span class="string">'/'</span> + sha1[<span class="number">2</span>,<span class="number">38</span>]</div><div class="line">FileUtils.mkdir_p(File.dirname(path))</div><div class="line">File.<span class="built_in">open</span>(path, <span class="string">'w'</span>) { |f| f.<span class="built_in">write</span> zlib_content}</div></pre></td></tr></table></figure>



<p>由于hello文件的内容是”hello world\n”，因此可以通过以上脚本首先生成<br>hello文件内容对应的object文件，文件类型是blob。可以通过一下命令判断生成的文件内容是否正确  </p>
<pre><code># git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad  
# git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">t</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad
</code></pre><p>以上的object也可以通过一下一条命令得到  </p>
<pre><code># echo <span class="string">"hello world"</span> | git hash-<span class="class"><span class="keyword">object</span> -<span class="title">w</span> --<span class="title">stdin</span></span>
</code></pre><p>随后更新生成.git/index文件  </p>
<pre><code># git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad hello
</code></pre><p>以上步骤仅是生成了”hello world” 对应的blob文件，但并没有制定这个内容对应的<br>文件名叫什么，也就是少了tree类型的object。接着执行一下命令  </p>
<pre><code><span class="preprocessor"># git write-tree        // 生成指向3b18e5的tree文件，可以用下面两条命令验证</span>
<span class="preprocessor"># git cat-file -p 7604755fe13e27f5327d6d13dc6663d44847562d</span>
<span class="preprocessor"># git cat-file -t 7604755fe13e27f5327d6d13dc6663d44847562d</span>
</code></pre><p>一个真正的commit还需要创建一个commit类型的object指向一个特定的tree节点  </p>
<pre><code><span class="preprocessor"># git commit-tree 7604755fe -m "add file"</span>
<span class="preprocessor"># git cat-file -p df36f6b4884ecf2ec519ddec85f959a83b4adec8</span>
<span class="preprocessor"># git cat-file -t df36f6b4884ecf2ec519ddec85f959a83b4adec8</span>
</code></pre><p>接着更新master的HEAD指针  </p>
<pre><code># git <span class="operator"><span class="keyword">update</span>-ref refs/heads/<span class="keyword">master</span> df36f6b4884ecf2ec519ddec85f959a83b4adec8
# git <span class="keyword">log</span>  &lt;= 至此就能看到一个完整的<span class="keyword">commit</span> <span class="keyword">log</span>
# git checkout hello  &lt;= 将hello文件从.git库checkout出来，就算彻底的完成了一个<span class="keyword">commit</span>了</span>
</code></pre><hr>
<h3 id="总的来说">总的来说</h3>
<pre><code><span class="comment">// 第一部分是完成git add的操作  </span>
<span class="preprocessor"># echo "hello world" | git hash-object -w --stdin</span>
    <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad    <span class="comment">// 生成blob文件</span>
<span class="preprocessor"># git update-index --add --cacheinfo 100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello</span>

<span class="comment">// 第二部分是完成git  commit的操作</span>
<span class="preprocessor"># git write-tree</span>
    <span class="number">7604755</span>fe13e27f5327d6d13dc6663d44847562d    <span class="comment">// 生成tree文件</span>
<span class="preprocessor"># git commit-tree 7604755fe -m "add file"</span>
    df36f6b4884ecf2ec519ddec85f959a83b4adec8    <span class="comment">// 生成commit</span>
</code></pre><p>可以看出一个commit对应会有三种object文件生成，每种object文件的命名都是以sha1哈希值为依据的。<br>除了commit文件由于带有日期信息所以hash值会变化之外，其他两个文件的hash值都是固定不变的。  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://ihower.tw/git/files/ihower-git-internal.pdf" target="_blank" rel="external">Git internal</a><br><a href="http://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">Git 内部原理 - Git 对象</a><br><a href="https://gist.github.com/ihower/6132576" target="_blank" rel="external">Git commit without commit</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>想要深入的了解一个工具，就必须完一些比较hack的用法。<br>为了更好的了解git内部的工作机制，本文就试图通过手动的编辑.git目录下的<br>文件，来完成一次commit的提交。  </p>
]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列一：使用gitolite搭建git仓库管理服务]]></title>
    <link href="http://perthcharles.github.com/2015/08/24/setup-gitolite-service-git-1/"/>
    <id>http://perthcharles.github.com/2015/08/24/setup-gitolite-service-git-1/</id>
    <published>2015-08-24T01:40:40.000Z</published>
    <updated>2015-08-25T03:55:11.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>当在工程实践中需要频繁使用git后发现，要达到真正的熟练掌握git并不是学会几个简单的git commit, git push 就能搞得定的。<br>因此开了这样一个系列，来集中梳理各种正确运用git及相关服务的要点。<br>不过既然是梳理，像那种直接man就能查到的简单用法就不会再赘述。重点在于梳理那些在使用git时会遇到的坑。<br>作为git工程实践系列的开篇，则是介绍如何使用gitolite在自己的机器上搭建git仓库管理服务。<br>只有在搭建好了一个良好的后台管理服务，才能为后续的git使用保驾护航。  </p>
<pre><code>如果是想了解git基本操作，这是一个不错的开始：[<span class="link_label">Try git</span>](<span class="link_url">https://www.codeschool.com/courses/try-git</span>)  
</code></pre><a id="more"></a>  

<hr>
<h3 id="安装gitolite">安装gitolite</h3>
<pre><code><span class="comment">// 创建专用账号</span>
@<span class="keyword">server</span> <span class="preprocessor"># adduser -m git -s /bin/bash</span>

<span class="comment">// 将客户端公钥上传服务器</span>
@admin-<span class="keyword">client</span> <span class="preprocessor"># scp ~/.ssh/id_ras.pub git@gitolite-server-ip:/home/git/admin.pub</span>

<span class="comment">// 切换到专用账号git，然后安装gitolite</span>
<span class="preprocessor"># sudo su git</span>
$ mkdir -p ~/bin
$ cd /home/git
$ git clone git:<span class="comment">//github.com/sitaramc/gitolite    // 获取gitolite</span>
$ git checkout -b newest-release v3<span class="number">.6</span><span class="number">.3</span>           <span class="comment">// 换到最新的一次release</span>
$ gitolite/install -ln ~/bin             <span class="comment">// 安装gitolite到指定目录</span>

<span class="comment">// 配置管理员公钥</span>
$ bin/gitolite setup -pk admin.pub
</code></pre><hr>
<h3 id="克隆gitolite">克隆gitolite</h3>
<p>至此可在admin-client克隆gitolite管理仓库</p>
<pre><code>@admin-<span class="keyword">client</span> <span class="preprocessor"># git clone git@gitolite-server-ip:gitolite-admin</span>

    <span class="comment">// MAC电脑下如果是新生成的id_ras.pub，则需要添加管理</span>
    @admin-<span class="keyword">client</span> <span class="preprocessor"># ssh-add -K ~/.ssh/id_ras.pub</span>

<span class="preprocessor"># cd gitolite-admin</span>
<span class="preprocessor"># ls</span>
conf    keydir        <span class="comment">// conf用于配置git项目权限，keydir用于存放git用户公钥</span>
</code></pre><hr>
<h3 id="新建GIT项目">新建GIT项目</h3>
<pre><code><span class="comment">// 回到客户端，在gitolite的配置中，增加project项目，并设置admin访问权限</span>
<span class="preprocessor"># cat conf/gitolite.conf</span>
repo gitolite-admin
    RW+     =   admin

repo testing
    RW+     =   @all

repo git-learning
    RW+     =   admin

<span class="preprocessor"># 提交对gitolite配置文件的修改</span>
<span class="preprocessor"># git commit -am 'add git project'</span>
<span class="preprocessor"># git push origin master    // 至此，管理员可在客户端克隆git@gitolite-server-ip:project</span>

<span class="comment">// 新的project.git会在执行git push自动创建，默认的目录是：/home/git/repositories</span>
</code></pre><hr>
<h3 id="新增GIT用户">新增GIT用户</h3>
<pre><code>// 将要添加的用户的公钥上传到gitolite-admin/kerdir目录下
$ <span class="keyword">ls</span> kerdir/
admin.pub <span class="keyword">new</span>.pub

// 配置用户<span class="keyword">new</span>的权限
$ <span class="keyword">cat</span> <span class="keyword">conf</span>/gitolite.<span class="keyword">conf</span>
repo gitolite-admin
    RW+     =   admin

repo testing
    RW+     =   @all

repo git-learning
    RW+     =   admin
    RW        =    <span class="keyword">new</span>

// 然后提交
$ git <span class="built_in">add</span> kerdir/<span class="keyword">new</span>.pub
$ git commit -<span class="keyword">am</span> <span class="string">'add user new for project'</span>
$ git push origin master
</code></pre><hr>
<h3 id="权限控制管理">权限控制管理</h3>
<pre><code><span class="comment">/* 实例1 */</span>  
repo project
    RW+        =    admin    <span class="comment">// admin 有读，写，强制写的权限</span>
    R        =    <span class="keyword">new</span>        <span class="comment">// new 仅有读权限，如果尝试提交会报错</span>

<span class="comment">/* 实例2 */</span> 
repo project
    RW+            =    admin    <span class="comment">// admin 有读，写，强制写的权限</span>
    <span class="comment">// new 对所有以dev开始的分支都有读写权限。即可以新建dev3，修改dev2分支 </span>
    RW    dev        =    <span class="keyword">new</span>        

<span class="comment">/* 实例3 */</span>
repo project
    RW+            =    admin
    <span class="comment">// new 仅对dev分支有写权限，$表示精确匹配</span>
    RW    dev$    =    <span class="keyword">new</span>

<span class="comment">/* 实例4 */</span>
repo project
    ...
    -    refs/tags/v[<span class="number">0</span>-<span class="number">9</span>]    = <span class="keyword">new</span>    <span class="comment">// new用户仅能创建除了以v加上数字开头之外的其他tag</span>

<span class="comment">/* 实例5 */</span>
repo project
    ...
    <span class="comment">// 除了根目录的Makefile文件外，new对其他文件都具有写权限</span>
    -    NAME/Makefile    = <span class="keyword">new</span>
    RW    Name/            = <span class="keyword">new</span>

<span class="comment">/* 推荐用法 */</span>
repo project
    <span class="comment">// 有效防止误操作：</span>
    <span class="comment">//     指定admin对branch的读写权限，防止误操作将本地的临时性branch推送到服务器端</span>
    <span class="comment">//     如果确定需要新增一个branch，则在下面新增一行，例如新增dev分支</span>
    RW+ master$     =   admin   <span class="comment">// admin 有读，写，强制写master分支的权限</span>
    RW+ dev$        =   admin   <span class="comment">// admin 有读，写，强制写dev分支的权限</span>

    RW  dev$             =  dev1 dev2     <span class="comment">// 普通developer仅能读写dev分支，且不能强制写</span>
    -   refs/tags/v[<span class="number">0</span>-<span class="number">9</span>] =  dev2 dev2     <span class="comment">// 限制普通用户不能创建以v加上数字开头的release tag</span>
    <span class="comment">// 如果不同的用户(组)分别负责完全独立的两个子系统，则可通过类似以下这种方式排除互相干扰</span>
    -   NAME/net/        =  dev1    <span class="comment">// dev1 不能修改net子系统下的文件</span>
    -   NAME/arch/       =  dev2    <span class="comment">// dev2 不能修改arch子系统下的文件</span>
</code></pre><hr>
<h3 id="配置gitweb">配置gitweb</h3>
<p>本节主要参考<a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="external">配置Gitolite+Gitweb+Nginx</a>  </p>
<pre><code><span class="comment">// 安装gitweb 和用于代码高亮的highlight</span>
$ sudo apt-get install -y gitweb highlight

<span class="comment">// 修改文件权限，用于gitweb读取</span>
$ chmod <span class="number">0027</span> /home/git.gitolite.rc
$ sudo usermod -a -G git www-data   <span class="comment">// www-data 是运行nginx服务的用户</span>
$ sudo chmod g+r    /home/git/projects.<span class="keyword">list</span>
$ sudo chmod -R g+rx /home/git/repositories

<span class="comment">// 将要显示的repo写入projects.list文件</span>
$ cat projects.<span class="keyword">list</span>
    testing.git

<span class="comment">// 修改/etc/gitweb.conf，修改以下几个关键值</span>
$ cat /etc/gitweb.conf
    <span class="comment"># path to git projects (&lt;project&gt;.git)</span>
    <span class="variable">$projectroot</span> = <span class="string">"/home/git/repositories/"</span>;

    <span class="comment"># directory to use for temp files</span>
    <span class="variable">$git_temp</span> = <span class="string">"/tmp"</span>;

    <span class="comment"># target of the home link on top of all pages</span>
    <span class="comment">#$home_link = $my_uri || "/";</span>

    <span class="comment"># html text to include at home page</span>
    <span class="comment">#$home_text = "indextext.html";</span>

    <span class="comment"># file with project list; by default, simply scan the projectroot dir.</span>
    <span class="variable">$projects_list</span> = <span class="string">"/home/git/projects.list"</span>;
    <span class="variable">$strict_export</span> = <span class="number">1</span>;

    <span class="comment"># stylesheet to use</span>
    <span class="comment">#@stylesheets = ("static/gitweb.css");</span>

    <span class="comment"># javascript code for gitweb</span>
    <span class="variable">$javascript</span> = <span class="string">"static/gitweb.js"</span>;

    <span class="comment"># logo to use</span>
    <span class="variable">$logo</span> = <span class="string">"static/git-logo.png"</span>;

    <span class="comment"># the 'favicon'</span>
    <span class="comment">#$favicon = "static/git-favicon.png";</span>

    <span class="comment"># git-diff-tree(1) options to use for generated patches</span>
    <span class="comment">#@diff_opts = ("-M");</span>
    @diff_opts = ();

    <span class="variable">$feature</span> {<span class="string">'blame'</span>}{<span class="string">'default'</span>} = [<span class="number">1</span>];
    <span class="variable">$feature</span> {<span class="string">'blame'</span>}{<span class="string">'override'</span>} = <span class="number">1</span>;

    <span class="variable">$feature</span> {<span class="string">'snapshot'</span>}{<span class="string">'default'</span>} = [<span class="string">'zip'</span>, <span class="string">'tgz'</span>];
    <span class="variable">$feature</span> {<span class="string">'snapshot'</span>}{<span class="string">'override'</span>} = <span class="number">1</span>;

    <span class="variable">$feature</span>{<span class="string">'highlight'</span>}{<span class="string">'default'</span>} = [<span class="number">1</span>];

<span class="comment">// 配置nginx</span>
$ sudo apt-get install spawn-fcgi fcgiwrap
<span class="comment">// 修改/etc/init/d/fcgi.fcgiwrap,将FCGI_USER FCGI_GROUP FCGI_SOCKET_OWNER FCGI_SOCKET_GROUP 都修改为运行web服务的用户</span>
<span class="comment">// 在nginx的配置文件中添加一个新的server段</span>
    server {
        listen <span class="number">80</span>;
        server_name gitweb.example.com;
        access_log  /home/wwwlogs/access.log  main;

        location / {
            root /usr/share/gitweb;
            index index.cgi;
            <span class="keyword">include</span> fastcgi_params;
            gzip off;
            fastcgi_param GITWEB_CONFIG /etc/gitweb.conf;

            <span class="keyword">if</span> (<span class="variable">$uri</span> ~ <span class="string">"/index.cgi"</span>) {
                fastcgi_pass unix:/<span class="keyword">var</span>/run/fcgiwrap.socket;
            }
        }
    }

<span class="comment">// 重启fcgiwrap和nginx</span>
$ sudo service fcgiwrap restart
$ sudo nginx -s reload
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.ossxp.com/doc/git/gitolite.html" target="_blank" rel="external">Gitolite 构建 Git 服务器</a><br><a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="external">配置Gitolite+Gitweb+Nginx</a><br><a href="http://gitolite.com/gitolite/gitolite.html" target="_blank" rel="external">gitolite all-in-one page</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>当在工程实践中需要频繁使用git后发现，要达到真正的熟练掌握git并不是学会几个简单的git commit, git push 就能搞得定的。<br>因此开了这样一个系列，来集中梳理各种正确运用git及相关服务的要点。<br>不过既然是梳理，像那种直接man就能查到的简单用法就不会再赘述。重点在于梳理那些在使用git时会遇到的坑。<br>作为git工程实践系列的开篇，则是介绍如何使用gitolite在自己的机器上搭建git仓库管理服务。<br>只有在搭建好了一个良好的后台管理服务，才能为后续的git使用保驾护航。  </p>
<pre><code>如果是想了解git基本操作，这是一个不错的开始：[<span class="link_label">Try git</span>](<span class="link_url">https://www.codeschool.com/courses/try-git</span>)  
</code></pre>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[个人git使用规范总结(持续更新)]]></title>
    <link href="http://perthcharles.github.com/2015/08/20/git-specification/"/>
    <id>http://perthcharles.github.com/2015/08/20/git-specification/</id>
    <published>2015-08-20T12:24:58.000Z</published>
    <updated>2015-08-25T03:24:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>一个工具的强大往往体现在它的灵活上，但在团队中必须制定一定的规范才能<br>进行高效的合作。<br>GIT就是这样一个强大到不行的工具，本文由于记录在实践中选择的一些实用技巧<br>和规范。<br>纪念那些年掉的坑T_T   </p>
<a id="more"></a>  

<hr>
<h3 id="1-_实用alias">1. 实用alias</h3>
<p>这个可以根据个人使用最频繁的命令来设置，然后保存到/etc/rc.local文件。    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># <span class="keyword">alias</span> gl=<span class="string">'git pull'</span></div><div class="line"># <span class="keyword">alias</span> gf=<span class="string">'git fetch'</span></div><div class="line"># <span class="keyword">alias</span> gb=<span class="string">'git branch'</span></div><div class="line"># <span class="keyword">alias</span> gco=<span class="string">'git checkout'</span></div><div class="line"># <span class="keyword">alias</span> gamend=<span class="string">'git commit --amend -C HEAD'</span></div><div class="line"># <span class="keyword">alias</span> gst=<span class="string">'git status'</span></div><div class="line"># <span class="keyword">alias</span> <span class="keyword">log</span>=<span class="string">'git log --oneline --graph --decorate --color=always'</span></div><div class="line"># <span class="keyword">alias</span> logg=<span class="string">'git log --graph --all --format=format:'</span>\<span class="string">''</span><span class="variable">%C</span>(bold blue)<span class="variable">%h</span><span class="variable">%C</span>(reset) - <span class="variable">%C</span>(bold green)(<span class="variable">%ar</span>)<span class="variable">%C</span>(reset) <span class="variable">%C</span>(white)<span class="variable">%s</span><span class="variable">%C</span>(reset) <span class="variable">%C</span>(bold white)—     <span class="variable">%an</span><span class="variable">%C</span>(reset)<span class="variable">%C</span>(bold yellow)<span class="variable">%d</span><span class="variable">%C</span>(reset)<span class="string">'\''</span> --abbrev-commit --<span class="keyword">date</span>=relative<span class="string">'</span></div></pre></td></tr></table></figure>



<hr>
<h3 id="2-_配置git">2. 配置git</h3>
<p>这部分很简单，但是很重要。尤其是git配置中的name和email会出现在后续所有<br>用于标注身份的地方。<br>如果实在不放心，或者忘记了有没有做过user.name等配置，最直接的方法就是上config文件里面亲眼看一下。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="array"># git config </span>-l                       <span class="comment">// 查看当前配置  </span></div><div class="line"><span class="array"># git config user.name </span><span class="string">"your-name"</span>    <span class="comment">// 配置你的名字</span></div><div class="line"><span class="array"># git config user.email </span><span class="string">"your-email"</span>  <span class="comment">// 配置你的邮箱</span></div><div class="line"><span class="array"># vim .git</span>/config                     <span class="comment">// 也可以直接在config文件中进行修改</span></div><div class="line"></div><div class="line"><span class="array"># vim .gitignore                      </span><span class="comment">// 添加.gitignore配置是一个好习惯  </span></div><div class="line">    比如常见的*.o  TODO tmp TMP文件</div><div class="line"></div><div class="line"><span class="array">#git checkout </span>-b your-feature-branch  <span class="comment">// 立即创建一个新分支使用，保持master分支整洁</span></div></pre></td></tr></table></figure>



<hr>
<h3 id="-_合并远端master">. 合并远端master</h3>
<p>在开始修改和准备提交之前，<em>规范</em>的合并远端master和本地master显得非常重要。<br>这里的<em>规范</em>选用fetch + rebase的方式。至于为什么请参考<a href="http://www.cnblogs.com/iammatthew/archive/2011/12/06/2277383.html" target="_blank" rel="external">1</a>。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="preprocessor"># git checkout master</span></div><div class="line"><span class="preprocessor"># git fetch</span></div><div class="line"><span class="preprocessor"># git rebase origin/master</span></div></pre></td></tr></table></figure>

<h3 id="-_解决冲突">. 解决冲突</h3>
<h3 id="-_关于amend/reset/rebase">. 关于amend/reset/rebase</h3>
<p>在这一节不打算详细解释这几个命令的用法，仅谈谈对这几个命令的理解和功能。<br>至于具体的用法和注意事项，<a href="https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history" target="_blank" rel="external">这是一篇很好的说明文章</a>。  </p>
<p>关键切入点：把一个commit理解为一个规范的patch。  </p>
<p>尽管这几个命令使用时需要比较谨慎，但是熟悉了rewrite git history才算是真的熟悉了git啊。  </p>
<h3 id="-_清理本地仓库">. 清理本地仓库</h3>
<p>长期使用下来，如果远端有些分支已经删除了，则需要清理本地repo。<br>否则git branch -a就会看到很多无用的分支。  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="array"># git remote prune origin  </span><span class="comment">// prune会删除任何不存在于远端仓库的分支</span></div></pre></td></tr></table></figure>



<hr>
<h3 id="为什么使用git_format-patch生成patch至关重要">为什么使用git format-patch生成patch至关重要</h3>
<hr>
<h3 id="常用命令">常用命令</h3>
<pre><code>git branch <span class="keyword">new</span>-branch-name origin/branch-name    <span class="comment">// 新建一个本地branch指向远端指定branch</span>
</code></pre><hr>
<h3 id="总结">总结</h3>
<p>多看git help <command>，一些你认为git不支持的功能，可能加个选项就能实现了。  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://liujin.me/blog/2015/05/25/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">Git 常用命令</a><br><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="external">Git 使用规范流程</a><br><a href="https://github.com/thoughtbot/guides/tree/master/protocol/git" target="_blank" rel="external">Git Protocol</a><br><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="external">Git 版本控制系統3: 還沒 push 前可以做的事</a><br><a href="https://ihower.tw/git/" target="_blank" rel="external">Git 版本控制系統</a><br><a href="https://blog.yorkxin.org/posts/2011/07/29/git-rebase/" target="_blank" rel="external">Git-rebase 小筆記</a><br><a href="http://www.cnblogs.com/iammatthew/archive/2011/12/06/2277383.html" target="_blank" rel="external">从git merge 和 git rebase想到</a><br><a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">Git分支管理策略</a><br><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">A successful Git branching model</a><br><a href="https://robots.thoughtbot.com/git-interactive-rebase-squash-amend-rewriting-history" target="_blank" rel="external">Git Interactive Rebase, Squash, Amend and Other Ways of Rewriting History</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>一个工具的强大往往体现在它的灵活上，但在团队中必须制定一定的规范才能<br>进行高效的合作。<br>GIT就是这样一个强大到不行的工具，本文由于记录在实践中选择的一些实用技巧<br>和规范。<br>纪念那些年掉的坑T_T   </p>
]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[像linux kernel一样管理你的项目]]></title>
    <link href="http://perthcharles.github.com/2015/08/14/manage-project-code-like-linux-kernel/"/>
    <id>http://perthcharles.github.com/2015/08/14/manage-project-code-like-linux-kernel/</id>
    <published>2015-08-14T02:34:06.000Z</published>
    <updated>2015-08-14T09:47:29.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>坚持良好的代码管理习惯，将极大的帮助我们做出更好的项目。<br>本文用于记录如何有效的使用git进行代码管理，像诸多优秀的项目一样。<br>本文尤其适合需要向其他项目提交patch的情形。不懂这句话的请参考标题，哈哈。  </p>
<a id="more"></a>  

<hr>
<h3 id="1-_如何正确的对待commit_？">1. 如何正确的对待commit ？</h3>
<p>commit是一个项目的变更史，如何维持一个高质量的commit log对于项目的质量<br>至关重要。<br>那么什么样的commit log是合格的呢？  </p>
<h4 id="1-1_避免初级的错误">1.1 避免初级的错误</h4>
<pre><code><span class="array"># git diff </span>--check   <span class="comment">// identifies possible whitespace errors  </span>
</code></pre><h4 id="1-2_坚持一个commit对应一个功能">1.2 坚持一个commit对应一个功能</h4>
<p>这点在实践的过程中可能很难满足，但是git提供了其他的方式让你可以在事后<br>进行弥补<a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external">[1]</a>。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。  </p>
<pre><code>// 方式1：修改最近的一次<span class="operator"><span class="keyword">commit</span>信息  
// 同时也会将已进行的更改添加进入修改后的<span class="keyword">commit</span>  
// 典型应用场景：<span class="keyword">commit</span>后才发现遗漏了某个文件  
# git <span class="keyword">commit</span> <span class="comment">--amend  </span>

// 方式<span class="number">2</span>：修改最近的多次<span class="keyword">commit</span>信息  
// 正式使用该方法前，最好用一个测试分支先体验一下。  
# git rebase -i HEAD~n    // 修改最近的n个<span class="keyword">commit</span>  
&lt;&lt; 将需要被修改的<span class="keyword">commit</span>信息对应行的<span class="string">"pick"</span>改为<span class="string">"edit"</span>  
# git <span class="keyword">commit</span> <span class="comment">--amend      // 真实的修改选择的commit信息  </span>
# git rebase <span class="comment">--continue   // 让rebase自动完成后续(未修改)的commit  </span>

// 方式<span class="number">3</span>：将最近的多个<span class="keyword">commit</span>替换为一个<span class="keyword">commit</span>
# git rebase -i HEAD~n  
&lt;&lt; 将需要被合并的前n-<span class="number">1</span>个<span class="keyword">commit</span>对应行的<span class="string">"pick"</span>改为<span class="string">"squash"</span>  
&lt;&lt; 之后会自动进入修改<span class="keyword">commit</span>的文本编辑页面，让你编辑新的<span class="keyword">commit</span> message  

// 方式<span class="number">4</span>：使用相对人工的方式合并多个<span class="keyword">commit</span>  
# git <span class="keyword">reset</span> <span class="comment">--soft HEAD~n  // 使用soft选项，仅将commit log回退n个记录  </span>
# git <span class="keyword">commit</span> -a // 提交正式的<span class="keyword">commit</span> message  </span>
</code></pre><h4 id="1-3_使用更规范的commit_message格式">1.3 使用更规范的commit message格式</h4>
<p>在确保了一个commit对应一个功能后，最后就是确保commit message的规范性了。<br>首先贴一下写一个合格commit message的规则，最后贴一下Tim Pope给出来的一个<br>模板<a href="http://git-scm.com/book/ch5-2.html" target="_blank" rel="external">[2]</a>。  </p>
<pre><code>第一行用一句简短的话总结这个<span class="operator"><span class="keyword">commit</span>  

第一行最好用一个描述性的前缀开始，比如  
  <span class="string">"net:"</span>表示针对net子系统的修改  
  <span class="string">"fix:"</span>表示这是一个bug fix  

第二行为空行

最后可以增加一些详细的描述，用以解释<span class="keyword">commit</span>具体干了什么，为什么这么干  </span>
</code></pre><p>commit message格式的一个模板如下，为保持原文含义，直接贴上英文版。  </p>
<pre><code>Short (<span class="number">50</span> <span class="keyword">chars</span> <span class="operator">or</span> less) summary <span class="operator">of</span> changes

More <span class="keyword">detailed</span> explanatory <span class="keyword">text</span>, <span class="keyword">if</span> necessary.  Wrap <span class="keyword">it</span> <span class="built_in">to</span>
about <span class="number">72</span> <span class="keyword">characters</span> <span class="operator">or</span> so.  In some contexts, <span class="operator">the</span> <span class="keyword">first</span>
<span class="built_in">line</span> is treated <span class="keyword">as</span> <span class="operator">the</span> subject <span class="operator">of</span> <span class="operator">an</span> email <span class="operator">and</span> <span class="operator">the</span> rest <span class="operator">of</span>
<span class="operator">the</span> <span class="keyword">text</span> <span class="keyword">as</span> <span class="operator">the</span> body.  The blank <span class="built_in">line</span> separating <span class="operator">the</span>
summary <span class="built_in">from</span> <span class="operator">the</span> body is critical (unless you omit <span class="operator">the</span> body
entirely); tools like rebase can <span class="built_in">get</span> confused <span class="keyword">if</span> you run
<span class="operator">the</span> <span class="constant">two</span> together.

Further paragraphs come <span class="keyword">after</span> blank <span class="keyword">lines</span>.

  - Bullet points are okay, too

  - Typically <span class="operator">a</span> hyphen <span class="operator">or</span> asterisk is used <span class="keyword">for</span> <span class="operator">the</span> bullet,
    preceded <span class="keyword">by</span> <span class="operator">a</span> single <span class="constant">space</span>, <span class="operator">with</span> blank <span class="keyword">lines</span> <span class="operator">in</span>
    between, but conventions vary here
</code></pre><hr>
<h3 id="2-_如何通过commit生成patch_？">2. 如何通过commit生成patch ？</h3>
<p>在得到合格的commit log后，则可以通过commit log直接得到想要的patch。<br>这里推荐使用format-patch格式的，理由自行理解。  </p>
<pre><code><span class="comment">// 生成前两个commit对应的patch，一个commit生成一个patch  </span>
<span class="comment">//     -s 表示添加签名</span>
<span class="comment">//     -n 表示patch里面会有[patch n/m]类似的标记 </span>
<span class="preprocessor"># git format-patch -sn -2</span>
<span class="comment">// 与上一条命令含义相同</span>
<span class="preprocessor"># git format-patch -sn HEAD HEAD~2..HEAD  </span>
<span class="comment">// 忽略掉diff里面的prefix  </span>
<span class="preprocessor"># git format-patch -sn --no-prefix -1  </span>
</code></pre><p>由于git format-patch会将每一个commit单独生成一个patch，这也就更加依赖<br>在上一步中是否严格控制好commit log的风格了。  </p>
<hr>
<h3 id="3-_如何检查patch的代码风格？">3. 如何检查patch的代码风格？</h3>
<p>坚持良好的代码风格是长久做项目的基石，所以在提交patch前最好自行检查好<br>代码是否符合目标项目的代码风格。<br>以Linux kernel为例，它提供了scripts/checkpatch.pl脚本用于检查代码风格。  </p>
<pre><code><span class="preprocessor"># scripts/checkpatch.pl PATCH-NAME</span>
<span class="preprocessor"># scripts/checkpatch.pl --terse PATCH-NAME   // 生成简单的报告  </span>
</code></pre><hr>
<h3 id="4-_如何使用tag管理重要的发行版？">4. 如何使用tag管理重要的发行版？</h3>
<p>项目在进行到一定阶段后，可能需要对外进行发布。长久下来，实际作业环境下<br>可能同时使用着不同的发布版本。但是项目本身的git管理肯定不会同时维护多<br>个分支。当然要求项目的所有开发人员都凭脑力记住特定发型版本对应的commit<br>也不太现实。这就是我理解的tag的用途：通过tag标识诸多发行版本与git仓库<br>某个时期状态的关系。<br>git中tag分为lightweight tag和annotated tag，建议仅使用annotated tag。<br>以下便是tag常见的用法：  </p>
<pre><code><span class="array"># git tag                </span><span class="comment">// 显示当前所有的tag  </span>
<span class="array"># git tag </span>-l <span class="string">'v1.0.*'</span>    <span class="comment">// 仅显示满足特定pattern的tag  </span>

<span class="array"># git tag </span>-a v1<span class="number">.5</span> -m <span class="string">'my version 1.5'</span>   <span class="comment">// 创建一个带标签的tag  </span>
<span class="array"># git tag </span>-a v1<span class="number">.6</span>        <span class="comment">// 如果不适用-m，则会进入文本编辑器进行编辑  </span>

<span class="array"># git show v</span>1<span class="number">.5</span>          <span class="comment">// 查看v1.5的信息  </span>

<span class="array"># git log </span>--pretty=oneline      <span class="comment">// 查看commit log  </span>
<span class="array"># git tag </span>-a v1<span class="number">.7</span> abcdef        <span class="comment">// 为特定的commit添加tag</span>

<span class="array"># git push origin v</span>1<span class="number">.7</span>   <span class="comment">// 提交tag v1.7  </span>
<span class="array"># git push origin </span>--tags <span class="comment">// 提交所有的tag</span>

<span class="array"># git checkout </span>-b version <span class="number">2.0</span> v2<span class="number">.0</span>   <span class="comment">// 新建一个branch查看v2.0源码  </span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="external">A Note About Git Commit Messages</a><br><a href="http://git-scm.com/book/ch5-2.html" target="_blank" rel="external">Distributed Git - Contributing to a Project</a><br><a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external">Git Tools - Rewriting History</a><br><a href="http://linux.koolsolutions.com/2011/02/26/howto-create-and-submit-your-first-linux-kernel-patch/" target="_blank" rel="external">HOWTO: Create and submit your first Linux kernel patch using GIT</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>坚持良好的代码管理习惯，将极大的帮助我们做出更好的项目。<br>本文用于记录如何有效的使用git进行代码管理，像诸多优秀的项目一样。<br>本文尤其适合需要向其他项目提交patch的情形。不懂这句话的请参考标题，哈哈。  </p>
]]>
    
    </summary>
    
      <category term="Git" scheme="http://perthcharles.github.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ISO镜像配置yum源]]></title>
    <link href="http://perthcharles.github.com/2015/07/08/iso-yum/"/>
    <id>http://perthcharles.github.com/2015/07/08/iso-yum/</id>
    <published>2015-07-08T01:28:18.000Z</published>
    <updated>2015-07-08T01:47:57.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="问题">问题</h2>
<hr>
<p>在无网络连接时，需要安装常见的工具软件。如果每次都先下好然后拷贝到这台机器，则太繁琐。何况很多常见的工具看似简单，但却有许多依赖，从源码安装太麻烦而且易出错。最典型的例子就是GCC（不要问我是怎么知道的T_T）  </p>
<a id="more"></a>  

<h2 id="解决方法">解决方法</h2>
<hr>
<p>目前常见的Linux发行版本的ISO镜像都可以在挂载后配置为yum源。这样就能直接从ISO镜像中带的rpm包中安装到大部分常用的软件。以下以CentOS 6.5为例进行说明：  </p>
<p>第一步：下载CentOS6.5的ISO镜像<br>第二步：挂载ISO镜像  </p>
<pre><code><span class="preprocessor"># mkdir -p /cdrom/iso  </span>
<span class="preprocessor"># mount -o loop ISO-FILE-PATH /cdrom/iso</span>
</code></pre><p>第三步：配置yum源  </p>
<pre><code><span class="comment"># cd /etc/yum.repos.d</span>
<span class="comment"># mkdir BAK; mv *.repo BAK  // 备份现有yum源配置  </span>
<span class="comment"># vim ISO.repo  </span>
  [base]
  <span class="variable">name=</span>CentOS-ISO1
  <span class="variable">baseurl=</span>file:///cdrom/iso
  <span class="variable">enabled=</span><span class="number">1</span>
  <span class="variable">gpgcheck=</span><span class="number">1</span>
  <span class="variable">gpgkey=</span>file:///cdrom/iso/RPM-GPG-KEY-CentOS-<span class="number">6</span>
</code></pre><p>第四步：检查yum源配置  </p>
<pre><code><span class="preprocessor"># yum list  </span>
</code></pre><p>至此应该能看到ISO镜像中RPM包已经配置好了yum源。对于CentOS6.5来说，可以看到它有repodata文件夹，这意味着它的ISO镜像能够直接配置为yum源而不用额外的动作。<br>而如果ISO没有repodata文件夹或手头仅有RPM包时，则需要借助辅助工具createrepo来创建正确的yum源。<br>在安装好createrepo后，仅需在RPM包所在的目录执行以下命令就可以创建一个可用的yum源。  </p>
<pre><code><span class="preprocessor"># createrepo .</span>
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://blog.csdn.net/gzh0222/article/details/6724142" target="_blank" rel="external">如何使用yum工具从iso镜像文件上安装</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="问题">问题</h2>
<hr>
<p>在无网络连接时，需要安装常见的工具软件。如果每次都先下好然后拷贝到这台机器，则太繁琐。何况很多常见的工具看似简单，但却有许多依赖，从源码安装太麻烦而且易出错。最典型的例子就是GCC（不要问我是怎么知道的T_T）  </p>
]]>
    
    </summary>
    
      <category term="yum" scheme="http://perthcharles.github.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Random early detection]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/</id>
    <published>2015-06-18T09:05:52.000Z</published>
    <updated>2015-06-18T10:03:06.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resources/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikipedia.org/?title=Random_early_detection" target="_blank" rel="external">Random Early Detection: wiki</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resources/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikipe]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Understand the Performance of Pacing]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/</id>
    <published>2015-06-18T05:20:22.000Z</published>
    <updated>2015-06-18T09:56:26.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br><a id="more"></a>  </p>
<h2 id="1-_What_is_Pacing_?">1. What is Pacing ?</h2>
<hr>
<p>TCP的数据发送目前有三种策略：<br>a. ACK-Clocking: 这是Linux TCP/IP协议栈现有的实现策略。每一个数据包的发送<br>都是由收到的确认包触发的。当数据确认包ACK由于网络拥塞无法及时达到发送端时，<br>发送方是不会发送数据的，除非timeout。总的来说就是，ack控制数据发送的时机，<br>min(cwnd, rwnd)控制发送数据的多少。  </p>
<p>b. Rate-based: pure的rate-based的方法使用一个估计的瓶颈链路带宽rate来控制<br>数据发送的多少和时机。  </p>
<p>c. Pacing: pacing算是以上两种方法的一个hybrid。pure的rate-based的方法最大的<br>缺点就是可能造成瓶颈链路的over-subscribed，而不能及时的发现。而在Pacing方法<br>中，发送数据量的多少还是由min(cwnd, rwnd)控制，而数据的发送时机则由timer控制。<br>timer控制的目的就是保证在一个RTT内，数据是比较平滑的发送出去的。  </p>
<h2 id="why_needs_pacing_?">why needs pacing ?</h2>
<hr>
<p>Pacing的提出主要是为了解决传统协议栈中存在的bursty transmission的情况。<br>文章总结的TCP中可能产生burst的情况有：  </p>
<pre><code><span class="tag">a</span>. <span class="tag">Slow</span> <span class="tag">Start</span>：慢启动阶段<span class="tag">cwnd</span>的增长是指数级的  
<span class="tag">b</span>. <span class="tag">Losses</span>: 当<span class="tag">rwnd</span>用完后，在丢包发生时无法发送新数据，重传结束后会引发<span class="tag">burst</span>。  
  <span class="tag">Note</span>: 这种<span class="tag">burst</span>可以用<span class="tag">opportunistic</span> <span class="tag">retransmission</span> 解决 <span class="pseudo">:)</span>  
<span class="tag">c</span>. <span class="tag">ACK</span> <span class="tag">Compression</span>: 当存在双向的数据流时，<span class="tag">ACK</span>包可能会在瓶颈链路中排队，破坏<span class="tag">ack-clocking</span>机制。  
<span class="tag">d</span>. <span class="tag">Multiplexing</span>: 当多条流共享一个高速瓶颈链路时，尽管同一条流数据包可能到达瓶颈链路的时间不同(细小的维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>)，但当数据包经历在瓶颈链路排队后，维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>被完全的破坏了。最终导致的结果就是数据包的发送都是突发性的。  
</code></pre><h2 id="Results">Results</h2>
<hr>
<p>Pacing的实现：  </p>
<pre><code>Timeouts are scheduled <span class="keyword">at</span> regular intervals <span class="operator">of</span> duration RTT/window.  
A packet is transmitted <span class="built_in">from</span> <span class="operator">the</span> window whenever <span class="operator">the</span> timer fires.  
</code></pre><p>单条流的情况：  </p>
<pre><code>a. 当瓶颈链路<span class="keyword">buffer</span>小于BDP时，reno会更早的遭遇丢包，因此pacing在throughput方面表现更好  
b. 当瓶颈链路<span class="keyword">buffer</span>超过BDP时，pacing的throughput更差，这主要是由于pacing会delay congestion <span class="keyword">signal</span>  
</code></pre><p>多条流的情况：  </p>
<pre><code><span class="keyword">a</span>. 在initial period，reno反而性能更好。主要是pacing流几乎同时丢包造成的性能下降，即synchronization effect现象。  
    synchronization effect：pacing流由于将数据包打散，当瓶颈链路<span class="keyword">buffer</span>溢出时，  
    许多pacing流都会产生丢包，进而许多pacing流都会下降cwnd。  
    而reno由于数据包相对是以burst的形式发送的，要么有一条流丢很多包，  
    要么可能某些流一个包都不丢。 

<span class="keyword">b</span>. 在steady state，pacing反而性能更好。主要是de-synchronization effect现象导致的。  
    de-synchronization effect：在稳定状态，Reno每个RTT会将cwnd加<span class="number">1</span>。  
    在<span class="keyword">buffer</span>用满后，每个Reno流多发的这个数据包(burst最后一个包)很大概率就会<span class="keyword">drop</span>。  
    而pacing由于将数据包打散了，丢包的发生有一定的随机性。对于单条pacing流而言就可能没有包被<span class="keyword">drop</span>  
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p>Understanding the Performance of TCP Pacing, INFOCOM’2000  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br>]]>
    
    </summary>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP FRTO机制]]></title>
    <link href="http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/"/>
    <id>http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/</id>
    <published>2015-06-16T10:16:18.000Z</published>
    <updated>2015-06-16T10:23:07.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.csdn.net/zhangskd/article/details/7446441" target="_blank" rel="external">FRTO—虚假超时剖析</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[服务器负载压力测试相关工具]]></title>
    <link href="http://perthcharles.github.com/2015/06/15/server-load-test/"/>
    <id>http://perthcharles.github.com/2015/06/15/server-load-test/</id>
    <published>2015-06-15T02:30:56.000Z</published>
    <updated>2015-07-07T03:33:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <span class="string">multiprocessing http test client  </span>
<span class="attribute">SIEGE</span>: <span class="string">http load testing and benchmarking utility</span>
<span class="attribute">webbench</span>: <span class="string">据文档描述，可以monitor3万个并发连接去测试网站的负载能力  </span>
<span class="attribute">ab</span>: <span class="string">apache benchmark，Apache自带的测试工具  </span>
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://acme.com/software/http_load/" target="_blank" rel="external">HTTP_LOAD homepage</a><br><a href="https://www.joedog.org/siege-home/" target="_blank" rel="external">SIEGE homepage</a><br><a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="external">Web Bench 1.5</a><br><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="external">ab - Apache HTTP server benchmarking tool</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <s]]>
    </summary>
    
      <category term="http_load" scheme="http://perthcharles.github.com/tags/http-load/"/>
    
      <category term="test" scheme="http://perthcharles.github.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TC 实践]]></title>
    <link href="http://perthcharles.github.com/2015/06/12/tc-tutorial/"/>
    <id>http://perthcharles.github.com/2015/06/12/tc-tutorial/</id>
    <published>2015-06-12T01:32:51.000Z</published>
    <updated>2015-06-15T02:30:38.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br><a id="more"></a>  </p>
<h2 id="队列类型">队列类型</h2>
<hr>
<p>Linux内核中支持的常见队列有：  </p>
<ol>
<li>pfifo_fast: 先进先出队列<br><img src="/resources/tc-fifo-qdisc.png" alt=""><br><img src="/resources/tc-pfifo_fast-qdisc.png" alt="">  </li>
<li>TBF(Token Bucket Filter): 令牌桶过滤器<br><img src="/resources/tc-tbf-qdisc.png" alt="">  </li>
<li>SFQ(Stochastic Fairness Queueing): 随机公平队列<br><img src="/resources/tc-sfq-qdisc.png" alt="">  </li>
<li>HTB(Hierarchy Token Bucket): 分层令牌桶<br><img src="/resources/tc-htb-borrow.png" alt="">  </li>
</ol>
<h2 id="TC应用场景">TC应用场景</h2>
<hr>
<p>本节摘抄自<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/overview.html" target="_blank" rel="external">Traffic Control HOWTO</a>.  </p>
<pre><code>Common traffic control solutions  
  <span class="number">1.</span> Limit total bandwidth <span class="built_in">to</span> <span class="operator">a</span> known rate; TBF, HTB <span class="operator">with</span> child class(es).
  <span class="number">2.</span> Limit <span class="operator">the</span> bandwidth <span class="operator">of</span> <span class="operator">a</span> particular user, service <span class="operator">or</span> client; HTB classes <span class="operator">and</span> classifying <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">filter</span>. traffic.
  <span class="number">3.</span> Maximize TCP throughput <span class="command"><span class="keyword">on</span> <span class="title">an</span> <span class="title">asymmetric</span> <span class="title">link</span>; <span class="title">prioritize</span> <span class="title">transmission</span> <span class="title">of</span> <span class="title">ACK</span> <span class="title">packets</span>, <span class="title">wondershaper</span>.</span>
  <span class="number">4.</span> Reserve bandwidth <span class="keyword">for</span> <span class="operator">a</span> particular application <span class="operator">or</span> user; HTB <span class="operator">with</span> children classes <span class="operator">and</span> classifying.
  <span class="number">5.</span> Prefer latency sensitive traffic; PRIO inside <span class="operator">an</span> HTB class.
  <span class="number">6.</span> Managed oversubscribed bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">7.</span> Allow equitable distribution <span class="operator">of</span> unreserved bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">8.</span> Ensure that <span class="operator">a</span> particular type <span class="operator">of</span> traffic is dropped; policer attached <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">filter</span> <span class="operator">with</span> <span class="operator">a</span> drop action.
</code></pre><h2 id="实践案例">实践案例</h2>
<hr>
<h3 id="pfifo_fast">pfifo_fast</h3>
<p>pfifo_fast是系统默认的队列类型，只起到调度的作用，不对数据流量进行控制。<br>其中pfifo中的p是packet的缩写，表示queue的大小计量单位为packet。<br>可以通过ip命令查看当前网络队列设置  </p>
<pre><code><span class="preprocessor"># ip link list</span>
</code></pre><h3 id="TBF">TBF</h3>
<p>TBF队列通过设置令牌的产生速度来限制数据包的发送。  </p>
<pre><code><span class="comment">// 在eth0上设置一个tbf队列，网络带宽为200kbit，延迟50ms，缓冲区为1540个字节</span>
<span class="comment">// rate表示令牌的产生速率</span>
<span class="comment">// latency表示数据包在队列中的最长等待时间</span>
<span class="comment">// 对burst参数解释一下：</span>
<span class="comment">//   burst means the maximum amount of bytes that tokens can be available for instantaneously.</span>
<span class="comment">//   如果数据包的到达速率与令牌的产生速率一致，即200kbit，则数据不会排队，令牌也不会剩余</span>
<span class="comment">//   如果数据包的到达速率小于令牌的产生速率，则令牌会有一定的剩余。</span>
<span class="comment">//   如果后续某一会数据包的到达速率超过了令牌的产生速率，则可以一次性的消耗一定量的令牌。</span>
<span class="comment">//   burst就是用于限制这“一次性”消耗的令牌的数量的，以字节数为单位。</span>
<span class="preprocessor"># tc qdisc add dev eth0 root tbf rate 200kbit latency 50ms burst 1540  </span>

<span class="preprocessor"># tc qdisc ls dev eth0 // 查看eth0上的队列规则  </span>
</code></pre><h3 id="SFQ">SFQ</h3>
<p>SFQ队列通过一个hash函数将不同会话(如TCP流)分到不同的FIFO队列中，从而保证<br>数据流的公平性。  </p>
<pre><code><span class="comment">// perturb表示每10秒更新一次hash函数  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root sfq perturb 10  </span>
</code></pre><h3 id="HTB">HTB</h3>
<pre><code><span class="comment">// handle是一组用户指定的标示符，格式为major:minor。  </span>
<span class="comment">// 如果是一条queueing discipline，minor需要一直为0。  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root handle 1:0 htb  </span>

<span class="comment">// parent指明该新增的class添加到那一个父handle上去  </span>
<span class="comment">// classid指明该class handle的唯一ID，minor需要是非零值  </span>
<span class="comment">// ceil定义rate的上界  </span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:6 htb rate 256kbit ceil 512kbit</span>

<span class="comment">// 新建一个带宽为100kbps的root class, 其classid为1:1</span>
<span class="preprocessor"># tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps</span>
<span class="comment">// 接着建立两个子class，指定其parent为1:1，ceil用来限制子类最大的带宽</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40kbps ceil 100kbps</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:11 htb rate 60kbps ceil 100kbps</span>
<span class="comment">// 随后建立filter指定哪些类型的packet进入那个class</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flow 1:11</span>
<span class="comment">// 最后为这些class添加queuing disciplines</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:11 handle 30: sfq perturb 10</span>
</code></pre><h3 id="其他">其他</h3>
<pre><code><span class="comment">// 同时模拟20Mbps带宽，50msRTT和0.1%丢包率  </span>
<span class="preprocessor"># tc qdisc add dev eth5 root handle 1:0 tbf rate 20mbit burst 10kb limit 300000  </span>
<span class="preprocessor"># tc qdisc add dev eth5 parent 1:0 handle 10:0 netem delay 50ms loss 0.1 limit 300000  </span>
</code></pre><h2 id="Rules,_Guidelines_and_Approaches">Rules, Guidelines and Approaches</h2>
<hr>
<p>‘’’<br>A device can only shape traffic in transmits<br>HTB is an ideal qdisc to use on a link with a know bandwidth<br>In theory, the PRIO scheduler is an ideal match for links with variable bandwidth<br>Sharing/splitting bandwidth based on flows or IP<br>‘’’</p>
<h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://www.turbolinux.com.cn/turbo/wiki/doku.php?id=traffic-control:tc%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B" target="_blank" rel="external">traffic-control:tc流量管理简介</a><br><a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html" target="_blank" rel="external">Traffic Control HOWTO</a><br><a href="http://luxik.cdi.cz/~devik/qos/htb/manual/userg.htm" target="_blank" rel="external">HTB Linux queuing discipline manual - user guide</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br>]]>
    
    </summary>
    
      <category term="tc" scheme="http://perthcharles.github.com/tags/tc/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技艺培养(基于知道创宇技能表v2.2)]]></title>
    <link href="http://perthcharles.github.com/2015/05/07/skill-list/"/>
    <id>http://perthcharles.github.com/2015/05/07/skill-list/</id>
    <published>2015-05-07T10:36:53.000Z</published>
    <updated>2015-05-10T15:46:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre><a id="more"></a>  

<h3 id="通用技能">通用技能</h3>
<h4 id="公司与个人">公司与个人</h4>
<ul>
<li>[X] 公司是盈利组织  </li>
<li>[X] 个人与公司必须双赢  </li>
<li>[X] 个人：在认同公司理念且能够为公司创造足够价值的基础上，<strong>为个人发展而工作</strong>    </li>
</ul>
<h4 id="沟通、反馈、责任">沟通、反馈、责任</h4>
<ul>
<li>[X] 一个无沟通能力的人，要么是天才，要么是不可爱的人  </li>
<li>[X] 反馈要及时  <ul>
<li>[X] 避免出问题不反馈，影响进度  </li>
<li>[X] 方式  <ul>
<li>[X] 正式的：邮件  </li>
<li>[X] 临时的：QQ等即时通信  </li>
<li>[X] 礼貌的：给个电话，短信  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 工作有大小，责任心无大小  </li>
<li>[X] 周报的透明  <ul>
<li>[X] 意义：大家互相了解工作与心得，有利于自己的判断与成长  </li>
<li>[X] 不是单纯的给领导汇报工作  </li>
</ul>
</li>
</ul>
<h4 id="任务四象限，决定优先级">任务四象限，决定优先级</h4>
<ul>
<li>[X] 紧急重要  </li>
<li>[X] 重要不紧急  </li>
<li>[X] 紧急不重要  </li>
<li>[X] 不紧急不重要  </li>
</ul>
<h4 id="新事物的敏感性">新事物的敏感性</h4>
<ul>
<li>[X] 保持好奇心  </li>
<li>[X] 不要局限在自己的圈子，适当跨界吸收灵感  </li>
<li>[X] 订阅国内外优秀博客/资源（详见附录一）  <ul>
<li>[X] 鲜果RSS，Readkit，Pocket和Evernote等工具  </li>
<li>[X] 英文很重要  </li>
</ul>
</li>
<li>[X] 选择性的参与一些必要的回忆，听必要的主题，讨论必要的话题  </li>
</ul>
<h4 id="成长">成长</h4>
<ul>
<li>[X] 对知识的渴望程度决定了前进动力的大小  <ul>
<li>[X] 对知识保持狂热和贪婪。为避免过度，因此也需要学会甄别和取舍。</li>
</ul>
</li>
<li>[X] 不要矫情，不要浮夸  </li>
<li>[X] 和比你厉害的人在一起，和一流的人工作  <ul>
<li>[X] 指点往往是精华  </li>
<li>[X] 杜绝笨蛋爆炸：二流的人招进来的人不太可能是一流的  </li>
</ul>
</li>
<li>[X] 思考  <ul>
<li>[X] 批判性思考  </li>
<li>[X] 换位思考  </li>
</ul>
</li>
<li>[X] 提问的智慧     <ul>
<li>[X] 遇到问题先独立思考，尽最大努力后再提问  </li>
</ul>
</li>
<li>[X] 小事心态  <ul>
<li>[X] 越基础的事越关键，需要越细心  </li>
<li>[X] 不要一味盲目追求”高级感”，而忽视”小事”/“简单事”/“基础事”</li>
<li>[X] 基础不牢，地动山摇  </li>
<li>[X] 小事做不好，别提大事  </li>
</ul>
</li>
<li>[ ] 任务拆分  — 逐步领会<ul>
<li>[X] 成长过程会经历：能力越大、责任越大、事情越多  </li>
<li>[X] 思路  <ul>
<li>[X] 拆分细化为多个点  </li>
<li>[X] 排好优先级  — 参考”任务四象限”  </li>
<li>[X] 加入时间维度：何时完成什么  — 参考”完成的定义”</li>
<li>[X] 是否需要寻求帮助，谁能帮你，自己单干？ — 参考”沟通、反馈、责任”  </li>
<li>[X] 任务是否可以切换/并发  </li>
<li>[X] 自己缺陷什么，立马发现  </li>
</ul>
</li>
</ul>
</li>
<li>[ ] 方法论  — 逐步领会<ul>
<li>[X] 完成一件事有好几条途径，优秀的人能选出最短的一条  </li>
<li>[X] 任务拆分很容易得出做事的方法论  </li>
<li>[X] 好的”方法论”会让你具备更强的”创造力”  </li>
</ul>
</li>
</ul>
<h4 id="牛人姿态">牛人姿态</h4>
<ul>
<li>[X] 即使现在不是牛人，也得具备这样的姿态  </li>
<li>[X] 这种感觉只能意会  </li>
<li>[X] 没有一定扎实内功与远见的人，很少有这样的姿态  </li>
</ul>
<h4 id="完成的定义">完成的定义</h4>
<ul>
<li>[ ] 比如写个POC  </li>
<li>搞懂了目标WEB应用漏洞的原理  </li>
<li>熟练运用Python各相关模块和机制  </li>
<li>熟练了解了HTTP协议：HTTP请求，HTTP相应  </li>
<li>代码写的够规范，让人看起来就是爽  </li>
<li>程序经过足够的测试：黑/白测试  </li>
<li>及时反馈进度  <ul>
<li>我遇到困难了</li>
<li>我搞定了  </li>
</ul>
</li>
<li>更新相关文档，沉淀  </li>
</ul>
<h4 id="熟练的定义">熟练的定义</h4>
<ul>
<li>[ ] 比如熟练SQL注入  <ul>
<li>SQL语句这门”语言”能脱离文档顺手写出  </li>
<li>主流数据库的SQL特有函数、存储过程、机制我都了如指掌  <ul>
<li>MySQL/MSSQL/Oracal/Postgre/Access/SQLite/…  </li>
</ul>
</li>
<li>牛逼的工具我不仅用的顺其自然，源码还读过几遍，我能修改  <ul>
<li>sqlmap/…  </li>
</ul>
</li>
<li>我具备创造性，而不仅仅是跟在大牛身后  <ul>
<li>研究出了几个不错的技巧  </li>
<li>发了几篇不错的paper  </li>
<li>对外会议/沙龙等进行了几次分享  </li>
<li>写出了自己的相关工具，爽  </li>
</ul>
</li>
<li>我实战了N回，遇到了许多奇葩环境，我有足够的信心饶过  </li>
<li>以上这些之后，这才叫熟练！其他同理  </li>
</ul>
</li>
</ul>
<h4 id="好书推荐">好书推荐</h4>
<ul>
<li>[X] 推荐理由  <ul>
<li>[X] 打通任督二脉的书，怎能不看？  </li>
<li>[X] 任何科学研究最终必须至少到哲学层面，触碰到上帝的脚  </li>
<li>[X] 具体技术类书籍请见”专业技能”相关部分  </li>
</ul>
</li>
<li>[ ] 鸡汤类  <ul>
<li>[ ] 黑客与画家  </li>
<li>[X] 浪潮之巅</li>
<li>[X] MacTalk</li>
</ul>
</li>
<li>[ ] 洁癖类  <ul>
<li>[ ] 重构  </li>
<li>[ ] 代码整洁之道  </li>
<li>[ ] 代码大全2  </li>
<li>[X] 数学之美</li>
<li>[X] 编写可读代码的艺术  </li>
</ul>
</li>
<li>[ ] 敏捷类  <ul>
<li>[ ] Rework中文版：37signals团队的敏捷经验  </li>
<li>[ ] 高效程序员的45个习惯  </li>
</ul>
</li>
<li>[ ] 产品类  <ul>
<li>[ ] 人人都是产品经理  </li>
<li>[ ] 结网  </li>
</ul>
</li>
<li>[ ] 神书  <ul>
<li>[ ] 自私的基因  </li>
<li>[ ] 失控  </li>
<li>[ ] 万物由来  </li>
</ul>
</li>
</ul>
<hr>
<h3 id="专业技能">专业技能</h3>
<h4 id="原则">原则</h4>
<ul>
<li>[X] 至少完整看完与练习好一本书  </li>
<li>[X] 至少过一遍官方文档  </li>
</ul>
<h4 id="基础必备">基础必备</h4>
<p>HTTP抓包与调试  </p>
<ul>
<li>[ ] Fiddler: 浏览器代理神器  </li>
<li>[X] wireshark + tshark(terminal wireshark， 脚本分析trace利器)  </li>
<li>[X] tcpdump  </li>
</ul>
<p>编码规范  </p>
<ul>
<li>[X] C/C++  </li>
<li>[ ] Python  </li>
</ul>
<p>office能力  </p>
<ul>
<li>[X] Word文档编写，看上去要专业，尤其对外的  </li>
<li>[X] Excel里面大量的统计、图标功能，需要善于使用  </li>
<li>[X] PPT演讲，培训等必备，如何做好PPT？Google一下。。。  </li>
<li>[X] 进一步：Visio，FreeMind, Latex, Markdown  </li>
</ul>
<p>熟练VIM  </p>
<p>算法  </p>
<ul>
<li>[X] 详见<a href="http://en.wikipedia.org/wiki/List_of_algorithms" target="_blank" rel="external">List of algorithms</a>  </li>
<li>[X] 熟练掌握常见算法和数据结构  </li>
<li>[X] 了解常见高级算法和数据结构，如红黑树，跳表，bloom filter等  </li>
</ul>
<p>正则表达式  </p>
<ul>
<li>[ ] 调试工具：Kodos，RegexBuddy</li>
<li>[ ] 各种正则表达式入门资料，自行Google。。。  </li>
</ul>
<p>研发能力  </p>
<ul>
<li>[X] 瀑布模型：需求-&gt;需求分析-&gt;设计-&gt;开发-&gt;测试-&gt;上线-&gt;运维/运营  </li>
<li>[X] 需求分析能力  <ul>
<li>[X] 给你一个需求，如何给出一个优美的执行思路  — 方法论  </li>
<li>[X] 这个能力非常非常的关键  </li>
</ul>
</li>
<li>[X] 调试能力  <ul>
<li>[X] 只要能定位，就没有解决不了的BUG  </li>
<li>[X] 肉眼看到的都是假象  <ul>
<li>[X] 一定要专业的工具与经验配合  </li>
</ul>
</li>
<li>[X] BUG在哪出现，最终就在哪进行真实模拟调试  </li>
<li>[X] 缩小范围  <ul>
<li>[X] 构建自己的测试样例：排除网络复杂未知情况  </li>
<li>[X] 关联模块一个个排除  </li>
<li>[X] 单步调试</li>
<li>[X] 粗暴调试：print  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 敏捷思想  <ul>
<li>[X] 快速迭代  </li>
<li>[X] 任务拆细  </li>
<li>[X] V1原则：定义好V1的目标，快速完成V1为优先  </li>
<li>[X] 习惯WIKI记录，利于沉淀和分享  — 个人选择：博客  </li>
</ul>
</li>
</ul>
<p>翻墙  </p>
<ul>
<li>[X] Goagent, VPN, VPS, SSH Tunnel, shadowsock…  </li>
</ul>
<h4 id="Web安全">Web安全</h4>
<ul>
<li>[ ] 书  <ul>
<li>[ ] 黑客攻防技术宝典（WEB实战篇）  </li>
<li>[ ] 白帽子讲WEB安全  </li>
<li>[ ] WEB前端黑客技术揭秘  </li>
<li>[ ] SQL注入攻击与防御  </li>
</ul>
</li>
<li>[ ] Papers  <ul>
<li>[ ] <a href="https://www.exploit-db.com/papers/" target="_blank" rel="external">Offensive security exploit database archive</a>  </li>
</ul>
</li>
</ul>
<h4 id="研发清单">研发清单</h4>
<p>编码环境  </p>
<ul>
<li>[ ] pip  </li>
<li>[ ] vagrant  </li>
<li>[X] tmux/screen  </li>
<li>[X] vim  </li>
<li>[ ] zsh + oh-my-zsh  </li>
<li>[X] python 2.7  </li>
<li>[ ] &gt;Django 1.4  </li>
<li>[ ] web.py  </li>
<li>[ ] node.js  </li>
<li>[X] ubuntu/gentoo/centos  </li>
<li>[ ] ipython  </li>
<li>[X] 版本控制：git/svn  </li>
<li>[ ] nginx + uWSGI  </li>
</ul>
<p>Python: 官方手册  </p>
<ul>
<li>[X] 至少过一遍，这都没过一遍，视野会局限  </li>
<li>[X] 行之说：”我没看过Python的书，却熟读官方手册”  </li>
</ul>
<p>Linux：熟练使用常见命令和shell脚本  </p>
<ul>
<li>[ ] 高级Bash脚本编程指南 Mendel Cooper  </li>
<li>[ ] Linux设备驱动第三版  </li>
</ul>
<p>前端：JavaScript DOM编程艺术  </p>
<p>爬虫进阶  </p>
<ul>
<li>[ ] 代理池：爬虫”稳定”需要  </li>
<li>[ ] 网络请求  <ul>
<li>[X] wget/curl  </li>
<li>[ ] urllib2/httplib2/requests  </li>
<li>[ ] scrapy  </li>
</ul>
</li>
<li>[ ] 验证码破解：pytesser  </li>
</ul>
<p>调度  </p>
<ul>
<li>[X] crontab是最原生的定时调度  </li>
<li>[ ] 基于redis实现的分布式调度  </li>
<li>[ ] 就rpyc实现的分布式调度  </li>
<li>[ ] celery/gearman等调度框架  </li>
</ul>
<p>并发  </p>
<ul>
<li>[X] 线程池：进程内优美的并发方案  </li>
<li>[ ] 协程：进程内另一种优美的并发方案  </li>
<li>[X] 多线程：os.fork, multiprocessing  </li>
</ul>
<p>数据结构  </p>
<ul>
<li>[X] JSON</li>
<li>[ ] cPickle  </li>
<li>[ ] protobuf  </li>
</ul>
<p>数据库  </p>
<ul>
<li>[ ] MySQL  </li>
<li>[ ] MongoDB  </li>
<li>[ ] Cassandra  </li>
<li>[ ] Hadoop体系  </li>
<li>[ ] Redis  </li>
<li>[ ] Sqlite  </li>
</ul>
<p>调试  </p>
<ul>
<li>[ ] gdb, pdb  </li>
<li>[X] logging  </li>
<li>[ ] Sentry  </li>
<li>[ ] strace/ltrace  </li>
<li>[X] lsof  </li>
<li>[X] 性能  <ul>
<li>[ ] Python性能分析指南  </li>
<li>[X] top/htop/free/iostat/vmstat/ifconfig…  </li>
</ul>
</li>
</ul>
<p>持续集成  </p>
<ul>
<li>[ ] 自测试：nose  </li>
<li>[ ] Jenkins  </li>
</ul>
<p>协作：Trello, WeiXin  </p>
<h4 id="设计思想">设计思想</h4>
<ul>
<li>[ ] 人人都是架构师：具备架构思想是一件多酷的事  </li>
<li>[X] 实战出真知  — 100%认同啊，且适用于任何技术领域  </li>
<li>[ ] 如何设计  <ul>
<li>[ ] 松耦合，紧内聚  </li>
<li>[ ] 单元与单元属性  </li>
<li>[X] 生产者与消费者  </li>
<li>[X] 结构：队列/LRU  </li>
<li>[ ] 分布式：存储、计算</li>
<li>[X] 资源考虑：CPU, 内存，带宽  </li>
</ul>
</li>
</ul>
<h4 id="牛人1，2，3">牛人1，2，3</h4>
<ul>
<li>[X] 1研究：研究东西，有足够的洞察力，研究水准不错  </li>
<li>[X] 2研发：hack idea自己有魄力实现，不懂研发的黑客如同不会游泳的海盗  </li>
<li>[X] 3工程：研发出来的需要实战、需要工程化，否则只是玩具，而不能成为真正的武器  </li>
</ul>
<hr>
<hr>
<h3 id="附录一：国内外优秀博客/资源">附录一：国内外优秀博客/资源</h3>
<hr>
<p>说道这个点，首先必须吐槽一下Google reader的关闭，其次吐槽一下现在快消费讯息的泛滥！  </p>
<ul>
<li>阮一峰的网络日志  </li>
<li>Vimer的程序世界  </li>
<li>阳志平的网志  </li>
<li>[推荐]弯曲评论  </li>
<li>酷壳CoolShell.cn  </li>
<li>[推荐]伯乐在线-博客  </li>
<li>月光博客  </li>
<li>IT技术博客大学习  </li>
<li>WooYun知识库  </li>
<li>PingWest  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核编码风格]]></title>
    <link href="http://perthcharles.github.com/2015/05/06/coding-style/"/>
    <id>http://perthcharles.github.com/2015/05/06/coding-style/</id>
    <published>2015-05-06T09:49:38.000Z</published>
    <updated>2015-05-10T04:59:31.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p><a id="more"></a>  </p>
<h3 id="缩进">缩进</h3>
<hr>
<p>所有的缩进均应是8字符格式。</p>
<pre><code><span class="keyword">If</span> you need more than <span class="number">3</span> levels indentation, you<span class="attribute">'re</span> screwed anyway, <span class="keyword">and</span> should 
fix your program.
</code></pre><p>注：关于这点保留意见，目前我(也)比较习惯用4字符格式的TAB。  </p>
<pre><code>Don't <span class="keyword">put</span> multiple assignments <span class="function_start"><span class="keyword">on</span></span> a single line.

Get a decent editor <span class="keyword">and</span> don't leave whitespace <span class="keyword">at</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> lines.
</code></pre><h3 id="换行">换行</h3>
<hr>
<p>每行的长度限制在80各字符</p>
<pre><code>However， never <span class="keyword">break</span> user-visible strings such <span class="keyword">as</span> printk <span class="keyword">messages</span>, because 
that breaks the ability <span class="keyword">to</span> <span class="keyword">grep</span> <span class="keyword">for</span> them.  
</code></pre><h3 id="括号和空格">括号和空格</h3>
<hr>
<pre><code>As shown <span class="built_in">to</span> us <span class="keyword">by</span> <span class="operator">the</span> prophets Kernighan <span class="operator">and</span> Ritchie, <span class="operator">the</span> preferred way is <span class="built_in">to</span> 
<span class="built_in">put</span> <span class="operator">the</span> opening brace <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">line</span>, <span class="title">and</span> <span class="title">push</span> <span class="title">the</span> <span class="title">closing</span> <span class="title">brace</span> <span class="title">first</span>, <span class="title">thusly</span>:</span>
<span class="keyword">if</span> (x is <span class="constant">true</span>) {
        we <span class="built_in">do</span> y
}
</code></pre><p>上面的规则适用于所有的代码块，除了函数。  </p>
<pre><code><span class="keyword">Do</span> <span class="keyword">not</span> unnecessarily use braces <span class="keyword">where</span> a <span class="built_in">single</span> statement will <span class="keyword">do</span>.

        <span class="keyword">if</span> (condition)
                action();

<span class="keyword">and</span>
        <span class="keyword">if</span> (condition)
                do_this();
        <span class="keyword">else</span>
                do_that();

This does <span class="keyword">not</span> apply <span class="keyword">if</span> only one branch <span class="keyword">of</span> a conditional statement <span class="keyword">is</span> a <span class="built_in">single</span> 
statement; <span class="keyword">in</span> the latter <span class="keyword">case</span> use braces <span class="keyword">in</span> both braches.
</code></pre><p>注：这个规则我保留意见。由于任何under-developing的代码片段都没办法保证在“现在和将来”都仅包含一条语句。因此我的选择是：在任何代码片段/分支处，均使用括号。  </p>
<p>在Linux kernel的编程风格中，空格的使用主要依赖于function-versus-keyword的使用。</p>
<pre><code><span class="operator"><span class="keyword">Use</span> a <span class="keyword">space</span> <span class="keyword">after</span> (most) keywords.
The notable exceptions <span class="keyword">are</span> sizeof, typeof, alignof, <span class="keyword">and</span> __attribute__,
which look somewhat <span class="keyword">like</span> functions.

<span class="keyword">Do</span> <span class="keyword">not</span> <span class="keyword">add</span> spaces around (inside) parenthesized expressions.

<span class="keyword">When</span> declaring pointer <span class="keyword">data</span> <span class="keyword">or</span> a <span class="keyword">function</span> that <span class="keyword">returns</span> a pointer type, the 
preferred usd <span class="keyword">of</span> <span class="string">'*'</span> <span class="keyword">is</span> adjacent <span class="keyword">to</span> the <span class="keyword">data</span> name <span class="keyword">or</span> <span class="keyword">function</span> name <span class="keyword">and</span> <span class="keyword">not</span> 
adjacent <span class="keyword">to</span> the type name. Examples:
    <span class="built_in">char</span> *line_banner;</span>
    char *match__strdup(substring_t *s);

<span class="operator"><span class="keyword">Use</span> one <span class="keyword">space</span> around (<span class="keyword">on</span> <span class="keyword">each</span> side <span class="keyword">of</span>) most <span class="built_in">binary</span> <span class="keyword">and</span> ternary operators, 
but <span class="keyword">no</span> <span class="keyword">space</span> <span class="keyword">after</span> unary operators.</span>
</code></pre><h3 id="命名">命名</h3>
<hr>
<pre><code>GLOBAL variables need to have descriptive names, as <span class="operator"><span class="keyword">do</span> <span class="keyword">global</span> functions.

Encoding the types <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">into</span> the name (so-called Hungarian notaion) 
<span class="keyword">is</span> brain damaged - the compiler knows the types anyway <span class="keyword">and</span> can <span class="keyword">check</span> those, <span class="keyword">and</span> 
it <span class="keyword">only</span> confuses the programmer. <span class="keyword">No</span> wonder MicroSoft makes buggy programs.
=.= 黑的漂亮  

<span class="keyword">LOCAL</span> variable <span class="keyword">names</span> should be short, <span class="keyword">and</span> <span class="keyword">to</span> the point.</span>
</code></pre><h3 id="自定义类型">自定义类型</h3>
<hr>
<p>typedefs应尽量少用。仅在满足一下条件之一时，typedefs才算是能适当提高可读性的选择。</p>
<ul>
<li>totally opaque objects (where the typedef is actively used to _hide_ what the<br>object is).  </li>
<li>clear integer types, where the abstaction _helps_ avoid confusion whether it<br>is ‘int’ or ‘long’. 例如 u8/u16/u32就是很好的抽象  </li>
<li>when you use sparse to literally create a _new_ type for type-checking.<br>— 暂时不太理解:-(  </li>
<li>New types which are identical to standard C99 types, in certain exceptional<br>circumstances.  </li>
<li>Types safe for use in userspace. — 暂时不太理解:-(  </li>
</ul>
<h3 id="函数">函数</h3>
<hr>
<pre><code>Functions should be short and sweet, and <span class="operator"><span class="keyword">do</span> just one thing. 
They should fit <span class="keyword">on</span> one <span class="keyword">or</span> two screenfuls <span class="keyword">of</span> <span class="built_in">text</span>.

The maximum length <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> inversely proportional <span class="keyword">to</span> the complexity 
<span class="keyword">and</span> indentation <span class="keyword">level</span> <span class="keyword">of</span> that <span class="keyword">function</span>.
<span class="comment">-- 当函数逻辑简单时，稍微长一点没有关系；</span>
<span class="comment">-- 当函数逻辑复杂时，可以通过helper函数缩短函数的长度。同时如果需要考虑性能，inline是个不错的选择。</span>

Another measure <span class="keyword">of</span> the <span class="keyword">function</span> <span class="keyword">is</span> the <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">local</span> <span class="keyword">variables</span>. 
They shouldn<span class="string">'t exceed 5-10, or you'</span>re doing something wrong.
依据：A human brain can generally easily keep track about <span class="number">7</span> different things.

<span class="keyword">In</span> source file, seperate functions <span class="keyword">with</span> one blank line.

<span class="keyword">If</span> the <span class="keyword">function</span> <span class="keyword">is</span> exported, the EXPORT macro <span class="keyword">for</span> it should follow immediately 
<span class="keyword">after</span> the closing <span class="keyword">function</span> brace line.

<span class="keyword">In</span> <span class="keyword">function</span> prototype, include parameter <span class="keyword">names</span> <span class="keyword">with</span> their <span class="keyword">data</span> types.</span>
</code></pre><h3 id="集中管理函数的退出条件">集中管理函数的退出条件</h3>
<hr>
<p>这部分主要是讨论goto的实用技巧(goto反对党请绕道)。  </p>
<pre><code>The <span class="keyword">goto</span> statement comes <span class="keyword">in</span> handy <span class="keyword">when</span> a <span class="keyword">function</span> exits <span class="keyword">from</span> multiple locations 
<span class="keyword">and</span> some common works such <span class="keyword">as</span> cleanup has <span class="keyword">to</span> be done.

Choose label names which say what the <span class="keyword">goto</span> does <span class="keyword">or</span> why the <span class="keyword">goto</span> exits.
</code></pre><p>goto语句在以下情况下，可以合理的使用：  </p>
<ul>
<li>unconditional statements are easier to understand and follow  </li>
<li>nesting is reduced  </li>
<li>errors by not updating individual exit points when making modifications are prevented — 暂时不理解:-(  </li>
<li>save the compiler work to optimize redundant code away  </li>
</ul>
<h3 id="注释">注释</h3>
<hr>
<p>这部分主要是一些避免over-commenting的原则。  </p>
<pre><code>NEVER <span class="keyword">try</span> <span class="keyword">to</span> explain HOW your code works <span class="keyword">in</span> a commment:
<span class="keyword">it</span>'s much better <span class="keyword">to</span> <span class="command">write</span> <span class="keyword">the</span> code so <span class="keyword">the</span> \_working\_ <span class="keyword">is</span> obvious, <span class="keyword">and</span> <span class="keyword">it</span>'s a 
waste <span class="keyword">of</span> <span class="property">time</span> <span class="keyword">to</span> explain badly written code.

Generally, you want your comments <span class="keyword">to</span> <span class="keyword">tell</span> WHAT your code <span class="keyword">does</span>, <span class="keyword">not</span> HOW. <span class="comment">--发人深省啊！</span>

Try <span class="keyword">to</span> avoid putting comments inside a function body.
Instead, <span class="keyword">put</span> <span class="keyword">the</span> comments <span class="keyword">at</span> <span class="keyword">the</span> head <span class="keyword">of</span> <span class="keyword">the</span> function, telling people what <span class="keyword">it</span> <span class="keyword">does</span>,
<span class="keyword">and</span> possibly WHY <span class="keyword">it</span> <span class="keyword">does</span> <span class="keyword">it</span>.  

Linux style <span class="keyword">for</span> comments <span class="keyword">is</span> <span class="keyword">the</span> C89 <span class="string">"/* ... */"</span> style.
Don't use C99-style <span class="string">"// ..."</span> comments.

The preferred style <span class="keyword">for</span> long (multi-line) comments <span class="keyword">is</span>:
/*
 * This <span class="keyword">is</span> <span class="keyword">the</span> preferred style <span class="keyword">for</span> multi-line
 * comments <span class="keyword">in</span> <span class="keyword">the</span> Linux kernel source code.
 * Please use <span class="keyword">it</span> consistently.
 */
</code></pre><h3 id="宏，枚举">宏，枚举</h3>
<hr>
<pre><code>Names <span class="operator">of</span> macros defining constants <span class="operator">and</span> labels <span class="operator">in</span> enums are capitalized.

Enums are preferred when defining serveral related constants.

CAPITALIZED macro names are appreciated but macros resembling functions may be  
named <span class="operator">in</span> <span class="built_in">lower</span> <span class="keyword">case</span>.

Generally, inline functions are preferable <span class="built_in">to</span> macros resembling functions. <span class="comment">-- 个人更认同这一原则。</span>

Macros <span class="operator">with</span> multiple statements should be eclosed <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">do</span>-which block.
</code></pre><h3 id="打印内核消息">打印内核消息</h3>
<pre><code>Make the messages concise, clear, <span class="keyword">and</span> unambiguous.

<span class="keyword">For</span> messages that aren<span class="comment">'t associated with a particular device, <span class="xmlDocTag">&lt;linux/printk.h&gt;</span> </span>
defines pr_notice(), pr_info(), pr_warn(), pr_err(), etc.
</code></pre><h3 id="inline的使用">inline的使用</h3>
<hr>
<pre><code>Abundant use <span class="operator">of</span> <span class="operator">the</span> inline keyword leads <span class="built_in">to</span> <span class="operator">a</span> much bigger kernel, which <span class="operator">in</span> turn 
slows <span class="operator">the</span> <span class="keyword">system</span> <span class="keyword">as</span> <span class="operator">a</span> <span class="keyword">whole</span> down, due <span class="built_in">to</span> <span class="operator">a</span> bigger icache footprint <span class="keyword">for</span> <span class="operator">the</span> CPU 
<span class="operator">and</span> simply because there is less memory available <span class="keyword">for</span> <span class="operator">the</span> pagecache.

A reasonable rule <span class="operator">of</span> thumb is <span class="built_in">to</span> <span class="operator">not</span> <span class="built_in">put</span> inline <span class="keyword">at</span> functions that have more 
than <span class="number">3</span> <span class="keyword">lines</span> <span class="operator">of</span> code <span class="operator">in</span> them.  <span class="comment">--即，inline应限制用于小函数 </span>
</code></pre><h3 id="函数返回值">函数返回值</h3>
<hr>
<pre><code><span class="keyword">If</span> the name <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> an action <span class="keyword">or</span> an imperative command, the <span class="keyword">function</span> 
should <span class="keyword">return</span> an <span class="keyword">error</span>-code <span class="built_in">integer</span>.
<span class="keyword">If</span> the name <span class="keyword">is</span> a predicate, the <span class="keyword">function</span> should <span class="keyword">return</span> a <span class="string">"succeeded"</span> <span class="built_in">boolean</span>.
</code></pre><h3 id="不要重复发明内核宏定义">不要重复发明内核宏定义</h3>
<pre><code>The header <span class="built_in">file</span> <span class="built_in">include</span>/linux/kernel.h <span class="operator">contains</span> <span class="operator">a</span> <span class="built_in">number</span> <span class="operator">of</span> macros that you 
should use, rather than explicitly coding some variant <span class="operator">of</span> them yourself.
</code></pre><h3 id="条件编译">条件编译</h3>
<hr>
<pre><code>Wherever possible, don't <span class="operator"><span class="keyword">use</span> preprocessor conditional (#<span class="keyword">if</span>, #ifdef) <span class="keyword">in</span> .c files, 
doing so makes code harder <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">and</span> logic harder <span class="keyword">to</span> follow.

Prefer <span class="keyword">to</span> compile out entire functions, rather than portions <span class="keyword">of</span> functions <span class="keyword">or</span> 
portions <span class="keyword">of</span> expressions.

Within code, <span class="keyword">where</span> possible, <span class="keyword">use</span> the IS_ENABLED macro <span class="keyword">to</span> <span class="keyword">convert</span> a Kconfig 
symbol <span class="keyword">into</span> a C <span class="built_in">boolean</span> expression, <span class="keyword">and</span> <span class="keyword">use</span> it <span class="keyword">in</span> a normal C conditional.

<span class="keyword">At</span> the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">any</span> non-trivial #<span class="keyword">if</span> <span class="keyword">or</span> #ifdef block (more than a few <span class="keyword">lines</span>), 
place a comment <span class="keyword">after</span> the #endif <span class="keyword">on</span> the same line, noting the conditional 
expression used. <span class="keyword">For</span> instance:
    #ifdef CONFIG_SOMETHING
    ...
    #endif <span class="comment">/* CONFIG_SOMETHING */</span></span>
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://www.kernel.org/doc/Documentation/CodingStyle" target="_blank" rel="external">Linux kernel coding style</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Alfred 使用记录]]></title>
    <link href="http://perthcharles.github.com/2015/03/27/alfred/"/>
    <id>http://perthcharles.github.com/2015/03/27/alfred/</id>
    <published>2015-03-27T07:34:58.000Z</published>
    <updated>2015-05-10T04:57:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br><a id="more"></a>  </p>
<hr>
<h3 id="1-_搜索">1. 搜索</h3>
<hr>
<p>Alfred的核心功能之一就是搜索，所以先简单介绍一下。<br>默认的热键组合是：option + space。<br>比如你想打开chrome浏览器，就可以直接在Alfred中输入chrome了。<br>相比于Spotlight它的显示结果更简单，更易于操作（特别是你想要的结果不是第一个结果时）。  </p>
<p>下面查找文件的方法来自<a href="http://macshuo.com/?p=625" target="_blank" rel="external">http://macshuo.com/?p=625</a>, 其实就是先输个空格，囧。  </p>
<pre><code>简单查找文件：用快捷键呼出Alfred，键入空格，输入你要查找文件名，
即可定位文件，回车打开，<span class="command"><span class="keyword">command</span>+回车打开文件所在文件夹。</span>
</code></pre><h3 id="2-_自定义搜索">2. 自定义搜索</h3>
<hr>
<p>上面只是搜索本地的资源，如果你想在某个特定网站进行搜索呢？<br>Alfred同样提供的custom search的功能，具体的方法可参考<a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br>我自己的案例就是用这个功能实现了在github中进行搜索。具体步骤如下：  </p>
<pre><code><span class="number">1</span>. 进入github页面，在输入框中随便输入一个关键字  
<span class="number">2</span>. 在得到的页面链接中，将你的关键字替换为{query}  
   如：https:<span class="comment">//github.com/search?utf8=%E2%9C%93&amp;q={query}  </span>
<span class="number">3</span>. 依次进入：Alfred的配置-&gt;Features -&gt;Web Search -&gt; Add custom search  
<span class="number">4</span>. 将search URL填写为第二步中得到的链接，其他表项也比较直观。  
   如：我的keyword设为了git, 这样我以后只要在Alfred中输入<span class="string">"git keyword"</span>
       就能直接在默认浏览器中打开github上面的搜索结果。  
</code></pre><h3 id="3-_我还是太年轻了">3. 我还是太年轻了</h3>
<hr>
<p>Alfred真是过于强大了，而且有不少作者总结的很好。这篇文章就写到这里吧，把参考资料都大概瞄一瞄，跟着学一遍基本差不多了。  </p>
<h3 id="4-_我的需求">4. 我的需求</h3>
<hr>
<p>算是TODO list吧，等学完了再回来填坑。  </p>
<pre><code><span class="number">0</span>. 学会用Python写workflow
<span class="number">1</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> VPN
<span class="number">2</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> wifi AP
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br><a href="http://zhuanlan.zhihu.com/pinapps/19986749" target="_blank" rel="external">用Alfred大幅提升操作效率 - workflow</a><br><a href="https://github.com/hzlzh/AlfredWorkflow.com" target="_blank" rel="external">Alfred workflow collection</a><br><a href="http://wellsnake.com/jekyll/update/2014/06/15/001/" target="_blank" rel="external">丢掉鼠标－Mac神软Alfred使用手册1</a><br><a href="http://www.alfredworkflow.com/" target="_blank" rel="external">Alfred workflow list</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://perthcharles.github.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Full Stack developer是怎样的一种存在？]]></title>
    <link href="http://perthcharles.github.com/2015/03/06/what-is-a-full-stack-developer/"/>
    <id>http://perthcharles.github.com/2015/03/06/what-is-a-full-stack-developer/</id>
    <published>2015-03-06T06:53:15.000Z</published>
    <updated>2015-05-09T17:06:32.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>总体上讲：  </p>
<pre><code>A Full Stack Developer is someone <span class="operator">with</span> familiarity <span class="operator">in</span> <span class="keyword">each</span> layer, 
<span class="keyword">if</span> <span class="operator">not</span> mastery <span class="operator">in</span> many <span class="operator">and</span> <span class="operator">a</span> genuine interest <span class="operator">in</span> all software technology.  

Good developers who are familiar <span class="operator">with</span> <span class="operator">the</span> entire stack know how <span class="built_in">to</span> 
make life easier <span class="keyword">for</span> those around them.  
</code></pre><a id="more"></a>  

<p>上面提到的“each layer”大体分为以下几个方面：  </p>
<pre><code><span class="bullet">1. </span>Server, Network, and Hosting Environment.  

<span class="bullet">2. </span>Data Modeling  

<span class="bullet">3. </span>Business Logic  

<span class="bullet">4. </span>API layer / Action Layer / MVC  

<span class="bullet">5. </span>User Interfaces  
<span class="code">    implementing a good visual design is key  </span>

<span class="bullet">6. </span>User Experience  

<span class="bullet">7. </span>Understanding what the customer and the business need
</code></pre><p>其他的内容还包括：  </p>
<pre><code><span class="number">1.</span> Ability <span class="keyword">to</span> <span class="command">write</span> quality unit tests.  

<span class="number">2.</span> Understanding <span class="keyword">of</span> repeatable automated processes <span class="keyword">for</span> building <span class="keyword">the</span> 
<span class="type">application</span>, testing <span class="keyword">it</span>, documenting <span class="keyword">it</span>, <span class="keyword">and</span> deploying <span class="keyword">it</span> <span class="keyword">at</span> scale.  

<span class="number">3.</span> An awareness <span class="keyword">of</span> security concerns <span class="keyword">is</span> important, <span class="keyword">as</span> each layer 
presents <span class="keyword">its</span> own possible valnerabilities.  
</code></pre><p>作者总结：  </p>
<pre><code>I’m <span class="operator">not</span> sure you can call yourself <span class="operator">a</span> full stack developer <span class="keyword">until</span> you 
have worked <span class="operator">in</span> multiple languages, platforms, <span class="operator">and</span> even industries 
<span class="operator">in</span> your professional career.   

Full stack goes beyond <span class="operator">a</span> <span class="string">'senior engineer'</span>, <span class="keyword">as</span> <span class="keyword">it</span> is along <span class="operator">the</span> same 
<span class="keyword">lines</span> <span class="keyword">as</span> <span class="operator">a</span> polyglot programmer but <span class="operator">with</span> <span class="operator">a</span> higher view <span class="operator">of</span> all <span class="operator">the</span> 
connecting pieces. Note that <span class="command"><span class="keyword">on</span> <span class="title">my</span> <span class="title">list</span>, <span class="title">only</span> <span class="title">items</span> <span class="title">3-5</span> <span class="title">involve</span> <span class="title">writing</span> <span class="title">code</span>.</span>
</code></pre><p>我的理解：  </p>
<pre><code><span class="bullet">1. </span>为了达到自己的某个目标，能够主动的分析问题，尽力设计出较实现方案。  

<span class="bullet">2. </span>如果需要去学习新的技能和知识时，也能积极主动的去学习。
这就需要有一定的甄别能力，哪个是真正需要的，哪个是更合适的。  

<span class="bullet">3. </span>Full Stack并不意味着work alone，重点应该是get things done. 
如果有更合适的更优秀的人，会愿意与他合作。  

<span class="bullet">4. </span>Full stack不是为了工作本身，而是为了实现自己的Dream。  
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/" target="_blank" rel="external">原文：What is a Full Stack developer</a><br><a href="http://www.zhihu.com/question/22420900" target="_blank" rel="external">怎样成为全栈工程师（Full Stack Developer）？</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>总体上讲：  </p>
<pre><code>A Full Stack Developer is someone <span class="operator">with</span> familiarity <span class="operator">in</span> <span class="keyword">each</span> layer, 
<span class="keyword">if</span> <span class="operator">not</span> mastery <span class="operator">in</span> many <span class="operator">and</span> <span class="operator">a</span> genuine interest <span class="operator">in</span> all software technology.  

Good developers who are familiar <span class="operator">with</span> <span class="operator">the</span> entire stack know how <span class="built_in">to</span> 
make life easier <span class="keyword">for</span> those around them.  
</code></pre>]]>
    
    </summary>
    
      <category term="好文共享" scheme="http://perthcharles.github.com/categories/%E5%A5%BD%E6%96%87%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux命令学习（十一）：lsof, vnstat, fuser, host, at, cron]]></title>
    <link href="http://perthcharles.github.com/2015/02/06/linux-using-11/"/>
    <id>http://perthcharles.github.com/2015/02/06/linux-using-11/</id>
    <published>2015-02-06T07:07:07.000Z</published>
    <updated>2015-05-10T05:02:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这次介绍一些系统使用和状态方面的一些命令，继续学习Linux命令  </p>
<a id="more"></a>  

<h3 id="1-_lsof:_list_open_file">1. lsof: list open file</h3>
<hr>
<p>使用实例如下：  </p>
<pre><code><span class="array"># lsof </span>-c &lt;process-name&gt;  <span class="comment">// 查看某个进程打开的文件  </span>
<span class="array"># lsof </span>/var/log/message   <span class="comment">// 查看massage文件当前在被谁使用  </span>
<span class="array"># lsof </span>-u ^root           <span class="comment">// 查看当前非root用户打开的文件信息  </span>
<span class="array"># lsof </span>-p <span class="number">1</span>               <span class="comment">// 查看1号进程打开的文件  </span>
<span class="array"># lsof </span>-p `pidof vim`     <span class="comment">// 查看vim进程打开的文件，效果如同第一条  </span>
<span class="array"># lsof </span>-i                 <span class="comment">// 显示所有网络连接信息  </span>
<span class="array"># lsof </span>-i tcp             <span class="comment">// 列出所有TCP网络连接信息  </span>
<span class="array"># lsof </span>-i :<span class="number">22</span>             <span class="comment">// 查看22端口现在运行的情况  </span>
</code></pre><h3 id="2-_vnstat:_a_console-based_network_traffic_monitor">2. vnstat: a console-based network traffic monitor</h3>
<hr>
<p>安装时候后才发现，vnstat并不能算一个实时的命令，更多的像是个制作历史报告的工具。<br>所以暂时就不学了，有需求再来看。<br>PS：如果想实时使用的话，可是使用—l选项。  </p>
<h3 id="3-_fuser:_identify_processing_using_files_or_sockets">3. fuser: identify processing using files or sockets</h3>
<hr>
<p>基本上能用lsof替代，暂时忽略。  </p>
<h3 id="4-_host:_DNS_lookup_utility">4. host: DNS lookup utility</h3>
<hr>
<p>使用实例如下：  </p>
<pre><code><span class="array"># host www.baidu.com      </span><span class="comment">// 查看百度的IP地址  </span>
<span class="array"># host </span>-a www.baidu.com   <span class="comment">// 显示详细的DNS查询消息  </span>
</code></pre><h3 id="5-_dig:_DNS_lookup_utility">5. dig: DNS lookup utility</h3>
<hr>
<p>dig同样也是一个DNS查询的工具，和host互为补充吧。  </p>
<pre><code># <span class="keyword">dig</span> www.baidu.<span class="keyword">com</span>         // 对百度网址进行DNS查询  
# <span class="keyword">dig</span> +trace www.baidu.<span class="keyword">com</span>  // 从根域开始跟踪查询结果  
# <span class="keyword">dig</span> +vc www.baidu.<span class="keyword">com</span>     // 使用TCP协议查询  
</code></pre><p>说道DNS，就想吐槽，大家都懂的.有兴趣的话大家可以对比下面两个命令的输出差异，对G.F.W.有一个大致的了解。  </p>
<pre><code># <span class="keyword">dig</span> +vc +trace www.baidu.<span class="keyword">com</span>  
# <span class="keyword">dig</span> +vc +trace www.facebook.<span class="keyword">com</span>  
</code></pre><h3 id="6-_ss:_another_utility_to_invertigate_sockets">6. ss: another utility to invertigate sockets</h3>
<hr>
<p>ss是socket statistics的缩写，相比于netstat能够显示过多关于socket细节的信息。<br>同时netstat略慢，而ss更快。  </p>
<pre><code><span class="array"># ss </span>-a -t       <span class="comment">// a == all, t == tcp  </span>
<span class="array"># ss </span>-s          <span class="comment">// s == summary, 显示socket信息摘要  </span>
<span class="array"># ss </span>-l          <span class="comment">// l == listenning  </span>
<span class="array"># ss </span>-p          <span class="comment">// p == processes, 显示哪些进程在用哪些socket  </span>
<span class="array"># ss </span>-pl         <span class="comment">// 查看哪些进程在使用listening状态的socket  </span>
</code></pre><h3 id="7-_关于环境变量LD_PRELOAD">7. 关于环境变量LD_PRELOAD</h3>
<hr>
<p>环境变量LD_PRELOAD指定程序运行时优先加载的动态链接库，且其中的符号优先级是最高的。所以在使用LD_PRELOAD环境变量后，可以替换掉标准C中的函数（默认放在libc.so.6文件中）。<br>比如想替换掉系统默认的malloc函数，则将LD_PRELOAD设置为新的malloc函数链接库。  </p>
<pre><code><span class="comment"># LD_PRELOAD="/home/user/mymalloc.so"  </span>
</code></pre><p>关于LD_PRELOAD环境变量，<a href="http://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="external">这篇文章</a>或许能让你脑洞大开。  </p>
<h3 id="8-_at:_executes_commands_at_a_specified_time">8. at: executes commands at a specified time</h3>
<hr>
<p>与cron配置一个周期性的服务不同，at命令主要是用于一次性的任务需求中。  </p>
<pre><code><span class="array"># at </span>-f myscript.sh -v <span class="number">10</span>:<span class="number">30</span>       <span class="comment">// 在10:30时刻，开始执行脚本  </span>
<span class="array"># timer</span>=`date +%k:%M -d <span class="string">'5 min'</span>`   <span class="comment">// 得到距离当前时刻5min的时间  </span>
<span class="array"># at </span>-f myscript.sh -v ${timer}    <span class="comment">// 在timer对应的时刻开始执行脚本  </span>
<span class="array"># atq                              </span><span class="comment">// 查看还未执行的任务  </span>
<span class="array"># atrm </span><span class="number">7</span>                           <span class="comment">// 使用任务编号进行删除  </span>
<span class="array"># at </span>-c <span class="number">8</span>                          <span class="comment">// 查看某任务编号对应的具体内容  </span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这次介绍一些系统使用和状态方面的一些命令，继续学习Linux命令  </p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="Shell" scheme="http://perthcharles.github.com/categories/Shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Network stack specialization for performance]]></title>
    <link href="http://perthcharles.github.com/2015/02/05/wiki-network-paper-stack-specialization/"/>
    <id>http://perthcharles.github.com/2015/02/05/wiki-network-paper-stack-specialization/</id>
    <published>2015-02-05T08:44:16.000Z</published>
    <updated>2015-05-10T05:07:48.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章是剑桥大学的Marinos发表在SIGCOMM 2014上的一篇关于网络协议栈优化的工作。<br>主要的argue就是指出，现有通用协议栈已经成为performance和scaling方面的主要瓶颈，是时候考虑做network stack specialization了。  </p>
<a id="more"></a>  

<h3 id="1-_Motivation">1. Motivation</h3>
<hr>
<p>首先，数据中心和大规模应用的出现，一定程度上改变了传统的服务需求。从之前的一台机器负责完成多个功能(1 machine n functions)变成了多台机器完成一件事情(n machines 1 function)。  </p>
<p>同时，数据中心中低延迟和高带宽的特点，使得endhost的软件协议栈的开销逐步的成为新的瓶颈。而这些部署在数据中心中的应用又是如此的在意performance。  </p>
<p>在对performance的更高准求的驱动下，作者认为针对n machines 1 function的应用场景有必要优化现有的软件协议栈（作者成为general-purpose stacks）。  </p>
<p>论文中的主要例子就是conventional stacks对于短流的性能不太好，同时又拿Yahoo! CDN的观测数据证明短流的普遍存在。  </p>
<h3 id="2-_Problem_and_Goals">2. Problem and Goals</h3>
<hr>
<p>本文想要解决的一大问题就是：短流在数据中心里<em>低</em>带宽利用率和<em>高</em>CPU使用率的问题。  </p>
<p>问题存在的主要原因就是：memory copy/move，context switch等。  </p>
<p>因此文章的主要目标就是设计一个定制化的协议栈，它能够更完美的做到zero-copy，更高效的做到数据的传输和响应，更聪明的利用应用的特点。<br>具体例子就是文章提到的sandstorm，对具体实现感兴趣的可以看下论文或PPT。  </p>
<h3 id="3-_Highlights">3. Highlights</h3>
<hr>
<ul>
<li>使用netmap，将应用层与NIC相关联，减少memory copy/move；  </li>
<li>利用了体系结构方面的技术：DDIO(Direct Data I/O)；  </li>
<li>对于短流，有2-10x的性能提升，同时CPU使用率也较低，对比对象为Linux + Ngnix和FreeBSD + Nginx。  </li>
</ul>
<h3 id="4-_My_Notes">4. My Notes</h3>
<hr>
<p>sandstorm一定程度上是提前准备好的数据，并且放在了DRAM中，作者对比的时候好像并未评测这个因素。因为Nginx从disk发数据，而sandstorm是从DRAM发数据。<br>本文创新方面也有待商榷，主要贡献就是利用一个demo重新在学术界呼吁了一下network stack specialization的重要性和可行性。论文最后一个作者是真神，有兴趣的可以去看下他的Google scholar。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章是剑桥大学的Marinos发表在SIGCOMM 2014上的一篇关于网络协议栈优化的工作。<br>主要的argue就是指出，现有通用协议栈已经成为performance和scaling方面的主要瓶颈，是时候考虑做network stack specialization了。  </p>
]]>
    
    </summary>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
</feed>
