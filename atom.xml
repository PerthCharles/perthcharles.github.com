<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天赋  无与伦比的坚持]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://perthcharles.github.com/"/>
  <updated>2015-06-18T09:10:12.095Z</updated>
  <id>http://perthcharles.github.com/</id>
  
  <author>
    <name><![CDATA[Perth Charles]]></name>
    <email><![CDATA[zhongbincharles@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Random early detection]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/</id>
    <published>2015-06-18T09:05:52.000Z</published>
    <updated>2015-06-18T09:08:46.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resource/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikipedia.org/?title=Random_early_detection" target="_blank" rel="external">Random Early Detection: wiki</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resource/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikiped]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Understand the Performance of Pacing]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/</id>
    <published>2015-06-18T05:20:22.000Z</published>
    <updated>2015-06-18T09:09:16.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br><a id="more"></a>  </p>
<h2 id="1-_What_is_Pacing_?">1. What is Pacing ?</h2>
<hr>
<p>TCP的数据发送目前有三种策略：<br>a. ACK-Clocking: 这是Linux TCP/IP协议栈现有的实现策略。每一个数据包的发送<br>都是由收到的确认包触发的。当数据确认包ACK由于网络拥塞无法及时达到发送端时，<br>发送方是不会发送数据的，除非timeout。总的来说就是，ack控制数据发送的时机，<br>min(cwnd, rwnd)控制发送数据的多少。  </p>
<p>b. Rate-based: pure的rate-based的方法使用一个估计的瓶颈链路带宽rate来控制<br>数据发送的多少和时机。  </p>
<p>c. Pacing: pacing算是以上两种方法的一个hybrid。pure的rate-based的方法最大的<br>缺点就是可能造成瓶颈链路的over-subscribed，而不能及时的发现。而在Pacing方法<br>中，发送数据量的多少还是由min(cwnd, rwnd)控制，而数据的发送时机则由timer控制。<br>timer控制的目的就是保证在一个RTT内，数据是比较平滑的发送出去的。  </p>
<h2 id="why_needs_pacing_?">why needs pacing ?</h2>
<hr>
<p>Pacing的提出主要是为了解决传统协议栈中存在的bursty transmission的情况。<br>文章总结的TCP中可能产生burst的情况有：  </p>
<pre><code><span class="tag">a</span>. <span class="tag">Slow</span> <span class="tag">Start</span>：慢启动阶段<span class="tag">cwnd</span>的增长是指数级的  
<span class="tag">b</span>. <span class="tag">Losses</span>: 当<span class="tag">rwnd</span>用完后，在丢包发生时无法发送新数据，重传结束后会引发<span class="tag">burst</span>。  
  <span class="tag">Note</span>: 这种<span class="tag">burst</span>可以用<span class="tag">opportunistic</span> <span class="tag">retransmission</span> 解决 <span class="pseudo">:)</span>  
<span class="tag">c</span>. <span class="tag">ACK</span> <span class="tag">Compression</span>: 当存在双向的数据流时，<span class="tag">ACK</span>包可能会在瓶颈链路中排队，破坏<span class="tag">ack-clocking</span>机制。  
<span class="tag">d</span>. <span class="tag">Multiplexing</span>: 当多条流共享一个高速瓶颈链路时，尽管同一条流数据包可能到达瓶颈链路的时间不同(细小的维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>)，但当数据包经历在瓶颈链路排队后，维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>被完全的破坏了。最终导致的结果就是数据包的发送都是突发性的。  
</code></pre><h2 id="Results">Results</h2>
<hr>
<p>Pacing的实现：  </p>
<pre><code>Timeouts are scheduled <span class="keyword">at</span> regular intervals <span class="operator">of</span> duration RTT/window.  
A packet is transmitted <span class="built_in">from</span> <span class="operator">the</span> window whenever <span class="operator">the</span> timer fires.  
</code></pre><p>单条流的情况：  </p>
<pre><code>a. 当瓶颈链路<span class="keyword">buffer</span>小于BDP时，reno会更早的遭遇丢包，因此pacing在throughput方面表现更好  
b. 当瓶颈链路<span class="keyword">buffer</span>超过BDP时，pacing的throughput更差，这主要是由于pacing会delay congestion <span class="keyword">signal</span>  
</code></pre><p>多条流的情况：  </p>
<pre><code><span class="keyword">a</span>. 在initial period，reno反而性能更好。主要是pacing流几乎同时丢包造成的性能下降，即synchronization effect现象。  
    synchronization effect：pacing流由于将数据包打散，当瓶颈链路<span class="keyword">buffer</span>溢出时，  
    许多pacing流都会产生丢包，进而许多pacing流都会下降cwnd。  
    而reno由于数据包相对是以burst的形式发送的，要么有一条流丢很多包，  
    要么可能某些流一个包都不丢。 

<span class="keyword">b</span>. 在steady state，pacing反而性能更好。主要是de-synchronization effect现象导致的。  
    de-synchronization effect：在稳定状态，Reno每个RTT会将cwnd加<span class="number">1</span>。  
    在<span class="keyword">buffer</span>用满后，每个Reno流多发的这个数据包(burst最后一个包)很大概率就会<span class="keyword">drop</span>。  
    而pacing由于将数据包打散了，丢包的发生有一定的随机性。对于单条pacing流而言就可能没有包被<span class="keyword">drop</span>  
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p>Understanding the Performance of TCP Pacing, INFOCOM’2000  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br>]]>
    
    </summary>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP FRTO机制]]></title>
    <link href="http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/"/>
    <id>http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/</id>
    <published>2015-06-16T10:16:18.000Z</published>
    <updated>2015-06-16T10:23:07.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.csdn.net/zhangskd/article/details/7446441" target="_blank" rel="external">FRTO—虚假超时剖析</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[服务器负载压力测试相关工具]]></title>
    <link href="http://perthcharles.github.com/2015/06/15/server-load-test/"/>
    <id>http://perthcharles.github.com/2015/06/15/server-load-test/</id>
    <published>2015-06-15T02:30:56.000Z</published>
    <updated>2015-06-15T03:32:22.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <span class="string">multiprocessing http test client  </span>
<span class="attribute">SIEGE</span>: <span class="string">http load testing and benchmarking utility</span>
<span class="attribute">webbench</span>: <span class="string">据文档描述，可以monitor3万个并发连接去测试网站的负载能力  </span>
<span class="attribute">ab</span>: <span class="string">apache benchmark，Apache自带的测试工具  </span>
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://acme.com/software/http_load/" target="_blank" rel="external">HTTP_LOAD homepage</a><br><a href="https://www.joedog.org/siege-home/" target="_blank" rel="external">SIEGE homepage</a><br><a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="external">Web Bench 1.5</a><br><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="external">ab - Apache HTTP server benchmarking tool</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <s]]>
    </summary>
    
      <category term="http_load, test" scheme="http://perthcharles.github.com/tags/http-load-test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TC 实践]]></title>
    <link href="http://perthcharles.github.com/2015/06/12/tc-tutorial/"/>
    <id>http://perthcharles.github.com/2015/06/12/tc-tutorial/</id>
    <published>2015-06-12T01:32:51.000Z</published>
    <updated>2015-06-15T02:30:38.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br><a id="more"></a>  </p>
<h2 id="队列类型">队列类型</h2>
<hr>
<p>Linux内核中支持的常见队列有：  </p>
<ol>
<li>pfifo_fast: 先进先出队列<br><img src="/resources/tc-fifo-qdisc.png" alt=""><br><img src="/resources/tc-pfifo_fast-qdisc.png" alt="">  </li>
<li>TBF(Token Bucket Filter): 令牌桶过滤器<br><img src="/resources/tc-tbf-qdisc.png" alt="">  </li>
<li>SFQ(Stochastic Fairness Queueing): 随机公平队列<br><img src="/resources/tc-sfq-qdisc.png" alt="">  </li>
<li>HTB(Hierarchy Token Bucket): 分层令牌桶<br><img src="/resources/tc-htb-borrow.png" alt="">  </li>
</ol>
<h2 id="TC应用场景">TC应用场景</h2>
<hr>
<p>本节摘抄自<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/overview.html" target="_blank" rel="external">Traffic Control HOWTO</a>.  </p>
<pre><code>Common traffic control solutions  
  <span class="number">1.</span> Limit total bandwidth <span class="built_in">to</span> <span class="operator">a</span> known rate; TBF, HTB <span class="operator">with</span> child class(es).
  <span class="number">2.</span> Limit <span class="operator">the</span> bandwidth <span class="operator">of</span> <span class="operator">a</span> particular user, service <span class="operator">or</span> client; HTB classes <span class="operator">and</span> classifying <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">filter</span>. traffic.
  <span class="number">3.</span> Maximize TCP throughput <span class="command"><span class="keyword">on</span> <span class="title">an</span> <span class="title">asymmetric</span> <span class="title">link</span>; <span class="title">prioritize</span> <span class="title">transmission</span> <span class="title">of</span> <span class="title">ACK</span> <span class="title">packets</span>, <span class="title">wondershaper</span>.</span>
  <span class="number">4.</span> Reserve bandwidth <span class="keyword">for</span> <span class="operator">a</span> particular application <span class="operator">or</span> user; HTB <span class="operator">with</span> children classes <span class="operator">and</span> classifying.
  <span class="number">5.</span> Prefer latency sensitive traffic; PRIO inside <span class="operator">an</span> HTB class.
  <span class="number">6.</span> Managed oversubscribed bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">7.</span> Allow equitable distribution <span class="operator">of</span> unreserved bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">8.</span> Ensure that <span class="operator">a</span> particular type <span class="operator">of</span> traffic is dropped; policer attached <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">filter</span> <span class="operator">with</span> <span class="operator">a</span> drop action.
</code></pre><h2 id="实践案例">实践案例</h2>
<hr>
<h3 id="pfifo_fast">pfifo_fast</h3>
<p>pfifo_fast是系统默认的队列类型，只起到调度的作用，不对数据流量进行控制。<br>其中pfifo中的p是packet的缩写，表示queue的大小计量单位为packet。<br>可以通过ip命令查看当前网络队列设置  </p>
<pre><code><span class="preprocessor"># ip link list</span>
</code></pre><h3 id="TBF">TBF</h3>
<p>TBF队列通过设置令牌的产生速度来限制数据包的发送。  </p>
<pre><code><span class="comment">// 在eth0上设置一个tbf队列，网络带宽为200kbit，延迟50ms，缓冲区为1540个字节</span>
<span class="comment">// rate表示令牌的产生速率</span>
<span class="comment">// latency表示数据包在队列中的最长等待时间</span>
<span class="comment">// 对burst参数解释一下：</span>
<span class="comment">//   burst means the maximum amount of bytes that tokens can be available for instantaneously.</span>
<span class="comment">//   如果数据包的到达速率与令牌的产生速率一致，即200kbit，则数据不会排队，令牌也不会剩余</span>
<span class="comment">//   如果数据包的到达速率小于令牌的产生速率，则令牌会有一定的剩余。</span>
<span class="comment">//   如果后续某一会数据包的到达速率超过了令牌的产生速率，则可以一次性的消耗一定量的令牌。</span>
<span class="comment">//   burst就是用于限制这“一次性”消耗的令牌的数量的，以字节数为单位。</span>
<span class="preprocessor"># tc qdisc add dev eth0 root tbf rate 200kbit latency 50ms burst 1540  </span>

<span class="preprocessor"># tc qdisc ls dev eth0 // 查看eth0上的队列规则  </span>
</code></pre><h3 id="SFQ">SFQ</h3>
<p>SFQ队列通过一个hash函数将不同会话(如TCP流)分到不同的FIFO队列中，从而保证<br>数据流的公平性。  </p>
<pre><code><span class="comment">// perturb表示每10秒更新一次hash函数  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root sfq perturb 10  </span>
</code></pre><h3 id="HTB">HTB</h3>
<pre><code><span class="comment">// handle是一组用户指定的标示符，格式为major:minor。  </span>
<span class="comment">// 如果是一条queueing discipline，minor需要一直为0。  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root handle 1:0 htb  </span>

<span class="comment">// parent指明该新增的class添加到那一个父handle上去  </span>
<span class="comment">// classid指明该class handle的唯一ID，minor需要是非零值  </span>
<span class="comment">// ceil定义rate的上界  </span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:6 htb rate 256kbit ceil 512kbit</span>

<span class="comment">// 新建一个带宽为100kbps的root class, 其classid为1:1</span>
<span class="preprocessor"># tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps</span>
<span class="comment">// 接着建立两个子class，指定其parent为1:1，ceil用来限制子类最大的带宽</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40kbps ceil 100kbps</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:11 htb rate 60kbps ceil 100kbps</span>
<span class="comment">// 随后建立filter指定哪些类型的packet进入那个class</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flow 1:11</span>
<span class="comment">// 最后为这些class添加queuing disciplines</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:11 handle 30: sfq perturb 10</span>
</code></pre><h3 id="其他">其他</h3>
<pre><code><span class="comment">// 同时模拟20Mbps带宽，50msRTT和0.1%丢包率  </span>
<span class="preprocessor"># tc qdisc add dev eth5 root handle 1:0 tbf rate 20mbit burst 10kb limit 300000  </span>
<span class="preprocessor"># tc qdisc add dev eth5 parent 1:0 handle 10:0 netem delay 50ms loss 0.1 limit 300000  </span>
</code></pre><h2 id="Rules,_Guidelines_and_Approaches">Rules, Guidelines and Approaches</h2>
<hr>
<p>‘’’<br>A device can only shape traffic in transmits<br>HTB is an ideal qdisc to use on a link with a know bandwidth<br>In theory, the PRIO scheduler is an ideal match for links with variable bandwidth<br>Sharing/splitting bandwidth based on flows or IP<br>‘’’</p>
<h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://www.turbolinux.com.cn/turbo/wiki/doku.php?id=traffic-control:tc%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B" target="_blank" rel="external">traffic-control:tc流量管理简介</a><br><a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html" target="_blank" rel="external">Traffic Control HOWTO</a><br><a href="http://luxik.cdi.cz/~devik/qos/htb/manual/userg.htm" target="_blank" rel="external">HTB Linux queuing discipline manual - user guide</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br>]]>
    
    </summary>
    
      <category term="tc" scheme="http://perthcharles.github.com/tags/tc/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技艺培养(基于知道创宇技能表v2.2)]]></title>
    <link href="http://perthcharles.github.com/2015/05/07/skill-list/"/>
    <id>http://perthcharles.github.com/2015/05/07/skill-list/</id>
    <published>2015-05-07T10:36:53.000Z</published>
    <updated>2015-05-10T15:46:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre><a id="more"></a>  

<h3 id="通用技能">通用技能</h3>
<h4 id="公司与个人">公司与个人</h4>
<ul>
<li>[X] 公司是盈利组织  </li>
<li>[X] 个人与公司必须双赢  </li>
<li>[X] 个人：在认同公司理念且能够为公司创造足够价值的基础上，<strong>为个人发展而工作</strong>    </li>
</ul>
<h4 id="沟通、反馈、责任">沟通、反馈、责任</h4>
<ul>
<li>[X] 一个无沟通能力的人，要么是天才，要么是不可爱的人  </li>
<li>[X] 反馈要及时  <ul>
<li>[X] 避免出问题不反馈，影响进度  </li>
<li>[X] 方式  <ul>
<li>[X] 正式的：邮件  </li>
<li>[X] 临时的：QQ等即时通信  </li>
<li>[X] 礼貌的：给个电话，短信  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 工作有大小，责任心无大小  </li>
<li>[X] 周报的透明  <ul>
<li>[X] 意义：大家互相了解工作与心得，有利于自己的判断与成长  </li>
<li>[X] 不是单纯的给领导汇报工作  </li>
</ul>
</li>
</ul>
<h4 id="任务四象限，决定优先级">任务四象限，决定优先级</h4>
<ul>
<li>[X] 紧急重要  </li>
<li>[X] 重要不紧急  </li>
<li>[X] 紧急不重要  </li>
<li>[X] 不紧急不重要  </li>
</ul>
<h4 id="新事物的敏感性">新事物的敏感性</h4>
<ul>
<li>[X] 保持好奇心  </li>
<li>[X] 不要局限在自己的圈子，适当跨界吸收灵感  </li>
<li>[X] 订阅国内外优秀博客/资源（详见附录一）  <ul>
<li>[X] 鲜果RSS，Readkit，Pocket和Evernote等工具  </li>
<li>[X] 英文很重要  </li>
</ul>
</li>
<li>[X] 选择性的参与一些必要的回忆，听必要的主题，讨论必要的话题  </li>
</ul>
<h4 id="成长">成长</h4>
<ul>
<li>[X] 对知识的渴望程度决定了前进动力的大小  <ul>
<li>[X] 对知识保持狂热和贪婪。为避免过度，因此也需要学会甄别和取舍。</li>
</ul>
</li>
<li>[X] 不要矫情，不要浮夸  </li>
<li>[X] 和比你厉害的人在一起，和一流的人工作  <ul>
<li>[X] 指点往往是精华  </li>
<li>[X] 杜绝笨蛋爆炸：二流的人招进来的人不太可能是一流的  </li>
</ul>
</li>
<li>[X] 思考  <ul>
<li>[X] 批判性思考  </li>
<li>[X] 换位思考  </li>
</ul>
</li>
<li>[X] 提问的智慧     <ul>
<li>[X] 遇到问题先独立思考，尽最大努力后再提问  </li>
</ul>
</li>
<li>[X] 小事心态  <ul>
<li>[X] 越基础的事越关键，需要越细心  </li>
<li>[X] 不要一味盲目追求”高级感”，而忽视”小事”/“简单事”/“基础事”</li>
<li>[X] 基础不牢，地动山摇  </li>
<li>[X] 小事做不好，别提大事  </li>
</ul>
</li>
<li>[ ] 任务拆分  — 逐步领会<ul>
<li>[X] 成长过程会经历：能力越大、责任越大、事情越多  </li>
<li>[X] 思路  <ul>
<li>[X] 拆分细化为多个点  </li>
<li>[X] 排好优先级  — 参考”任务四象限”  </li>
<li>[X] 加入时间维度：何时完成什么  — 参考”完成的定义”</li>
<li>[X] 是否需要寻求帮助，谁能帮你，自己单干？ — 参考”沟通、反馈、责任”  </li>
<li>[X] 任务是否可以切换/并发  </li>
<li>[X] 自己缺陷什么，立马发现  </li>
</ul>
</li>
</ul>
</li>
<li>[ ] 方法论  — 逐步领会<ul>
<li>[X] 完成一件事有好几条途径，优秀的人能选出最短的一条  </li>
<li>[X] 任务拆分很容易得出做事的方法论  </li>
<li>[X] 好的”方法论”会让你具备更强的”创造力”  </li>
</ul>
</li>
</ul>
<h4 id="牛人姿态">牛人姿态</h4>
<ul>
<li>[X] 即使现在不是牛人，也得具备这样的姿态  </li>
<li>[X] 这种感觉只能意会  </li>
<li>[X] 没有一定扎实内功与远见的人，很少有这样的姿态  </li>
</ul>
<h4 id="完成的定义">完成的定义</h4>
<ul>
<li>[ ] 比如写个POC  </li>
<li>搞懂了目标WEB应用漏洞的原理  </li>
<li>熟练运用Python各相关模块和机制  </li>
<li>熟练了解了HTTP协议：HTTP请求，HTTP相应  </li>
<li>代码写的够规范，让人看起来就是爽  </li>
<li>程序经过足够的测试：黑/白测试  </li>
<li>及时反馈进度  <ul>
<li>我遇到困难了</li>
<li>我搞定了  </li>
</ul>
</li>
<li>更新相关文档，沉淀  </li>
</ul>
<h4 id="熟练的定义">熟练的定义</h4>
<ul>
<li>[ ] 比如熟练SQL注入  <ul>
<li>SQL语句这门”语言”能脱离文档顺手写出  </li>
<li>主流数据库的SQL特有函数、存储过程、机制我都了如指掌  <ul>
<li>MySQL/MSSQL/Oracal/Postgre/Access/SQLite/…  </li>
</ul>
</li>
<li>牛逼的工具我不仅用的顺其自然，源码还读过几遍，我能修改  <ul>
<li>sqlmap/…  </li>
</ul>
</li>
<li>我具备创造性，而不仅仅是跟在大牛身后  <ul>
<li>研究出了几个不错的技巧  </li>
<li>发了几篇不错的paper  </li>
<li>对外会议/沙龙等进行了几次分享  </li>
<li>写出了自己的相关工具，爽  </li>
</ul>
</li>
<li>我实战了N回，遇到了许多奇葩环境，我有足够的信心饶过  </li>
<li>以上这些之后，这才叫熟练！其他同理  </li>
</ul>
</li>
</ul>
<h4 id="好书推荐">好书推荐</h4>
<ul>
<li>[X] 推荐理由  <ul>
<li>[X] 打通任督二脉的书，怎能不看？  </li>
<li>[X] 任何科学研究最终必须至少到哲学层面，触碰到上帝的脚  </li>
<li>[X] 具体技术类书籍请见”专业技能”相关部分  </li>
</ul>
</li>
<li>[ ] 鸡汤类  <ul>
<li>[ ] 黑客与画家  </li>
<li>[X] 浪潮之巅</li>
<li>[X] MacTalk</li>
</ul>
</li>
<li>[ ] 洁癖类  <ul>
<li>[ ] 重构  </li>
<li>[ ] 代码整洁之道  </li>
<li>[ ] 代码大全2  </li>
<li>[X] 数学之美</li>
<li>[X] 编写可读代码的艺术  </li>
</ul>
</li>
<li>[ ] 敏捷类  <ul>
<li>[ ] Rework中文版：37signals团队的敏捷经验  </li>
<li>[ ] 高效程序员的45个习惯  </li>
</ul>
</li>
<li>[ ] 产品类  <ul>
<li>[ ] 人人都是产品经理  </li>
<li>[ ] 结网  </li>
</ul>
</li>
<li>[ ] 神书  <ul>
<li>[ ] 自私的基因  </li>
<li>[ ] 失控  </li>
<li>[ ] 万物由来  </li>
</ul>
</li>
</ul>
<hr>
<h3 id="专业技能">专业技能</h3>
<h4 id="原则">原则</h4>
<ul>
<li>[X] 至少完整看完与练习好一本书  </li>
<li>[X] 至少过一遍官方文档  </li>
</ul>
<h4 id="基础必备">基础必备</h4>
<p>HTTP抓包与调试  </p>
<ul>
<li>[ ] Fiddler: 浏览器代理神器  </li>
<li>[X] wireshark + tshark(terminal wireshark， 脚本分析trace利器)  </li>
<li>[X] tcpdump  </li>
</ul>
<p>编码规范  </p>
<ul>
<li>[X] C/C++  </li>
<li>[ ] Python  </li>
</ul>
<p>office能力  </p>
<ul>
<li>[X] Word文档编写，看上去要专业，尤其对外的  </li>
<li>[X] Excel里面大量的统计、图标功能，需要善于使用  </li>
<li>[X] PPT演讲，培训等必备，如何做好PPT？Google一下。。。  </li>
<li>[X] 进一步：Visio，FreeMind, Latex, Markdown  </li>
</ul>
<p>熟练VIM  </p>
<p>算法  </p>
<ul>
<li>[X] 详见<a href="http://en.wikipedia.org/wiki/List_of_algorithms" target="_blank" rel="external">List of algorithms</a>  </li>
<li>[X] 熟练掌握常见算法和数据结构  </li>
<li>[X] 了解常见高级算法和数据结构，如红黑树，跳表，bloom filter等  </li>
</ul>
<p>正则表达式  </p>
<ul>
<li>[ ] 调试工具：Kodos，RegexBuddy</li>
<li>[ ] 各种正则表达式入门资料，自行Google。。。  </li>
</ul>
<p>研发能力  </p>
<ul>
<li>[X] 瀑布模型：需求-&gt;需求分析-&gt;设计-&gt;开发-&gt;测试-&gt;上线-&gt;运维/运营  </li>
<li>[X] 需求分析能力  <ul>
<li>[X] 给你一个需求，如何给出一个优美的执行思路  — 方法论  </li>
<li>[X] 这个能力非常非常的关键  </li>
</ul>
</li>
<li>[X] 调试能力  <ul>
<li>[X] 只要能定位，就没有解决不了的BUG  </li>
<li>[X] 肉眼看到的都是假象  <ul>
<li>[X] 一定要专业的工具与经验配合  </li>
</ul>
</li>
<li>[X] BUG在哪出现，最终就在哪进行真实模拟调试  </li>
<li>[X] 缩小范围  <ul>
<li>[X] 构建自己的测试样例：排除网络复杂未知情况  </li>
<li>[X] 关联模块一个个排除  </li>
<li>[X] 单步调试</li>
<li>[X] 粗暴调试：print  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 敏捷思想  <ul>
<li>[X] 快速迭代  </li>
<li>[X] 任务拆细  </li>
<li>[X] V1原则：定义好V1的目标，快速完成V1为优先  </li>
<li>[X] 习惯WIKI记录，利于沉淀和分享  — 个人选择：博客  </li>
</ul>
</li>
</ul>
<p>翻墙  </p>
<ul>
<li>[X] Goagent, VPN, VPS, SSH Tunnel, shadowsock…  </li>
</ul>
<h4 id="Web安全">Web安全</h4>
<ul>
<li>[ ] 书  <ul>
<li>[ ] 黑客攻防技术宝典（WEB实战篇）  </li>
<li>[ ] 白帽子讲WEB安全  </li>
<li>[ ] WEB前端黑客技术揭秘  </li>
<li>[ ] SQL注入攻击与防御  </li>
</ul>
</li>
<li>[ ] Papers  <ul>
<li>[ ] <a href="https://www.exploit-db.com/papers/" target="_blank" rel="external">Offensive security exploit database archive</a>  </li>
</ul>
</li>
</ul>
<h4 id="研发清单">研发清单</h4>
<p>编码环境  </p>
<ul>
<li>[ ] pip  </li>
<li>[ ] vagrant  </li>
<li>[X] tmux/screen  </li>
<li>[X] vim  </li>
<li>[ ] zsh + oh-my-zsh  </li>
<li>[X] python 2.7  </li>
<li>[ ] &gt;Django 1.4  </li>
<li>[ ] web.py  </li>
<li>[ ] node.js  </li>
<li>[X] ubuntu/gentoo/centos  </li>
<li>[ ] ipython  </li>
<li>[X] 版本控制：git/svn  </li>
<li>[ ] nginx + uWSGI  </li>
</ul>
<p>Python: 官方手册  </p>
<ul>
<li>[X] 至少过一遍，这都没过一遍，视野会局限  </li>
<li>[X] 行之说：”我没看过Python的书，却熟读官方手册”  </li>
</ul>
<p>Linux：熟练使用常见命令和shell脚本  </p>
<ul>
<li>[ ] 高级Bash脚本编程指南 Mendel Cooper  </li>
<li>[ ] Linux设备驱动第三版  </li>
</ul>
<p>前端：JavaScript DOM编程艺术  </p>
<p>爬虫进阶  </p>
<ul>
<li>[ ] 代理池：爬虫”稳定”需要  </li>
<li>[ ] 网络请求  <ul>
<li>[X] wget/curl  </li>
<li>[ ] urllib2/httplib2/requests  </li>
<li>[ ] scrapy  </li>
</ul>
</li>
<li>[ ] 验证码破解：pytesser  </li>
</ul>
<p>调度  </p>
<ul>
<li>[X] crontab是最原生的定时调度  </li>
<li>[ ] 基于redis实现的分布式调度  </li>
<li>[ ] 就rpyc实现的分布式调度  </li>
<li>[ ] celery/gearman等调度框架  </li>
</ul>
<p>并发  </p>
<ul>
<li>[X] 线程池：进程内优美的并发方案  </li>
<li>[ ] 协程：进程内另一种优美的并发方案  </li>
<li>[X] 多线程：os.fork, multiprocessing  </li>
</ul>
<p>数据结构  </p>
<ul>
<li>[X] JSON</li>
<li>[ ] cPickle  </li>
<li>[ ] protobuf  </li>
</ul>
<p>数据库  </p>
<ul>
<li>[ ] MySQL  </li>
<li>[ ] MongoDB  </li>
<li>[ ] Cassandra  </li>
<li>[ ] Hadoop体系  </li>
<li>[ ] Redis  </li>
<li>[ ] Sqlite  </li>
</ul>
<p>调试  </p>
<ul>
<li>[ ] gdb, pdb  </li>
<li>[X] logging  </li>
<li>[ ] Sentry  </li>
<li>[ ] strace/ltrace  </li>
<li>[X] lsof  </li>
<li>[X] 性能  <ul>
<li>[ ] Python性能分析指南  </li>
<li>[X] top/htop/free/iostat/vmstat/ifconfig…  </li>
</ul>
</li>
</ul>
<p>持续集成  </p>
<ul>
<li>[ ] 自测试：nose  </li>
<li>[ ] Jenkins  </li>
</ul>
<p>协作：Trello, WeiXin  </p>
<h4 id="设计思想">设计思想</h4>
<ul>
<li>[ ] 人人都是架构师：具备架构思想是一件多酷的事  </li>
<li>[X] 实战出真知  — 100%认同啊，且适用于任何技术领域  </li>
<li>[ ] 如何设计  <ul>
<li>[ ] 松耦合，紧内聚  </li>
<li>[ ] 单元与单元属性  </li>
<li>[X] 生产者与消费者  </li>
<li>[X] 结构：队列/LRU  </li>
<li>[ ] 分布式：存储、计算</li>
<li>[X] 资源考虑：CPU, 内存，带宽  </li>
</ul>
</li>
</ul>
<h4 id="牛人1，2，3">牛人1，2，3</h4>
<ul>
<li>[X] 1研究：研究东西，有足够的洞察力，研究水准不错  </li>
<li>[X] 2研发：hack idea自己有魄力实现，不懂研发的黑客如同不会游泳的海盗  </li>
<li>[X] 3工程：研发出来的需要实战、需要工程化，否则只是玩具，而不能成为真正的武器  </li>
</ul>
<hr>
<hr>
<h3 id="附录一：国内外优秀博客/资源">附录一：国内外优秀博客/资源</h3>
<hr>
<p>说道这个点，首先必须吐槽一下Google reader的关闭，其次吐槽一下现在快消费讯息的泛滥！  </p>
<ul>
<li>阮一峰的网络日志  </li>
<li>Vimer的程序世界  </li>
<li>阳志平的网志  </li>
<li>[推荐]弯曲评论  </li>
<li>酷壳CoolShell.cn  </li>
<li>[推荐]伯乐在线-博客  </li>
<li>月光博客  </li>
<li>IT技术博客大学习  </li>
<li>WooYun知识库  </li>
<li>PingWest  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核编码风格]]></title>
    <link href="http://perthcharles.github.com/2015/05/06/coding-style/"/>
    <id>http://perthcharles.github.com/2015/05/06/coding-style/</id>
    <published>2015-05-06T09:49:38.000Z</published>
    <updated>2015-05-10T04:59:31.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p><a id="more"></a>  </p>
<h3 id="缩进">缩进</h3>
<hr>
<p>所有的缩进均应是8字符格式。</p>
<pre><code><span class="keyword">If</span> you need more than <span class="number">3</span> levels indentation, you<span class="attribute">'re</span> screwed anyway, <span class="keyword">and</span> should 
fix your program.
</code></pre><p>注：关于这点保留意见，目前我(也)比较习惯用4字符格式的TAB。  </p>
<pre><code>Don't <span class="keyword">put</span> multiple assignments <span class="function_start"><span class="keyword">on</span></span> a single line.

Get a decent editor <span class="keyword">and</span> don't leave whitespace <span class="keyword">at</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> lines.
</code></pre><h3 id="换行">换行</h3>
<hr>
<p>每行的长度限制在80各字符</p>
<pre><code>However， never <span class="keyword">break</span> user-visible strings such <span class="keyword">as</span> printk <span class="keyword">messages</span>, because 
that breaks the ability <span class="keyword">to</span> <span class="keyword">grep</span> <span class="keyword">for</span> them.  
</code></pre><h3 id="括号和空格">括号和空格</h3>
<hr>
<pre><code>As shown <span class="built_in">to</span> us <span class="keyword">by</span> <span class="operator">the</span> prophets Kernighan <span class="operator">and</span> Ritchie, <span class="operator">the</span> preferred way is <span class="built_in">to</span> 
<span class="built_in">put</span> <span class="operator">the</span> opening brace <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">line</span>, <span class="title">and</span> <span class="title">push</span> <span class="title">the</span> <span class="title">closing</span> <span class="title">brace</span> <span class="title">first</span>, <span class="title">thusly</span>:</span>
<span class="keyword">if</span> (x is <span class="constant">true</span>) {
        we <span class="built_in">do</span> y
}
</code></pre><p>上面的规则适用于所有的代码块，除了函数。  </p>
<pre><code><span class="keyword">Do</span> <span class="keyword">not</span> unnecessarily use braces <span class="keyword">where</span> a <span class="built_in">single</span> statement will <span class="keyword">do</span>.

        <span class="keyword">if</span> (condition)
                action();

<span class="keyword">and</span>
        <span class="keyword">if</span> (condition)
                do_this();
        <span class="keyword">else</span>
                do_that();

This does <span class="keyword">not</span> apply <span class="keyword">if</span> only one branch <span class="keyword">of</span> a conditional statement <span class="keyword">is</span> a <span class="built_in">single</span> 
statement; <span class="keyword">in</span> the latter <span class="keyword">case</span> use braces <span class="keyword">in</span> both braches.
</code></pre><p>注：这个规则我保留意见。由于任何under-developing的代码片段都没办法保证在“现在和将来”都仅包含一条语句。因此我的选择是：在任何代码片段/分支处，均使用括号。  </p>
<p>在Linux kernel的编程风格中，空格的使用主要依赖于function-versus-keyword的使用。</p>
<pre><code><span class="operator"><span class="keyword">Use</span> a <span class="keyword">space</span> <span class="keyword">after</span> (most) keywords.
The notable exceptions <span class="keyword">are</span> sizeof, typeof, alignof, <span class="keyword">and</span> __attribute__,
which look somewhat <span class="keyword">like</span> functions.

<span class="keyword">Do</span> <span class="keyword">not</span> <span class="keyword">add</span> spaces around (inside) parenthesized expressions.

<span class="keyword">When</span> declaring pointer <span class="keyword">data</span> <span class="keyword">or</span> a <span class="keyword">function</span> that <span class="keyword">returns</span> a pointer type, the 
preferred usd <span class="keyword">of</span> <span class="string">'*'</span> <span class="keyword">is</span> adjacent <span class="keyword">to</span> the <span class="keyword">data</span> name <span class="keyword">or</span> <span class="keyword">function</span> name <span class="keyword">and</span> <span class="keyword">not</span> 
adjacent <span class="keyword">to</span> the type name. Examples:
    <span class="built_in">char</span> *line_banner;</span>
    char *match__strdup(substring_t *s);

<span class="operator"><span class="keyword">Use</span> one <span class="keyword">space</span> around (<span class="keyword">on</span> <span class="keyword">each</span> side <span class="keyword">of</span>) most <span class="built_in">binary</span> <span class="keyword">and</span> ternary operators, 
but <span class="keyword">no</span> <span class="keyword">space</span> <span class="keyword">after</span> unary operators.</span>
</code></pre><h3 id="命名">命名</h3>
<hr>
<pre><code>GLOBAL variables need to have descriptive names, as <span class="operator"><span class="keyword">do</span> <span class="keyword">global</span> functions.

Encoding the types <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">into</span> the name (so-called Hungarian notaion) 
<span class="keyword">is</span> brain damaged - the compiler knows the types anyway <span class="keyword">and</span> can <span class="keyword">check</span> those, <span class="keyword">and</span> 
it <span class="keyword">only</span> confuses the programmer. <span class="keyword">No</span> wonder MicroSoft makes buggy programs.
=.= 黑的漂亮  

<span class="keyword">LOCAL</span> variable <span class="keyword">names</span> should be short, <span class="keyword">and</span> <span class="keyword">to</span> the point.</span>
</code></pre><h3 id="自定义类型">自定义类型</h3>
<hr>
<p>typedefs应尽量少用。仅在满足一下条件之一时，typedefs才算是能适当提高可读性的选择。</p>
<ul>
<li>totally opaque objects (where the typedef is actively used to _hide_ what the<br>object is).  </li>
<li>clear integer types, where the abstaction _helps_ avoid confusion whether it<br>is ‘int’ or ‘long’. 例如 u8/u16/u32就是很好的抽象  </li>
<li>when you use sparse to literally create a _new_ type for type-checking.<br>— 暂时不太理解:-(  </li>
<li>New types which are identical to standard C99 types, in certain exceptional<br>circumstances.  </li>
<li>Types safe for use in userspace. — 暂时不太理解:-(  </li>
</ul>
<h3 id="函数">函数</h3>
<hr>
<pre><code>Functions should be short and sweet, and <span class="operator"><span class="keyword">do</span> just one thing. 
They should fit <span class="keyword">on</span> one <span class="keyword">or</span> two screenfuls <span class="keyword">of</span> <span class="built_in">text</span>.

The maximum length <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> inversely proportional <span class="keyword">to</span> the complexity 
<span class="keyword">and</span> indentation <span class="keyword">level</span> <span class="keyword">of</span> that <span class="keyword">function</span>.
<span class="comment">-- 当函数逻辑简单时，稍微长一点没有关系；</span>
<span class="comment">-- 当函数逻辑复杂时，可以通过helper函数缩短函数的长度。同时如果需要考虑性能，inline是个不错的选择。</span>

Another measure <span class="keyword">of</span> the <span class="keyword">function</span> <span class="keyword">is</span> the <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">local</span> <span class="keyword">variables</span>. 
They shouldn<span class="string">'t exceed 5-10, or you'</span>re doing something wrong.
依据：A human brain can generally easily keep track about <span class="number">7</span> different things.

<span class="keyword">In</span> source file, seperate functions <span class="keyword">with</span> one blank line.

<span class="keyword">If</span> the <span class="keyword">function</span> <span class="keyword">is</span> exported, the EXPORT macro <span class="keyword">for</span> it should follow immediately 
<span class="keyword">after</span> the closing <span class="keyword">function</span> brace line.

<span class="keyword">In</span> <span class="keyword">function</span> prototype, include parameter <span class="keyword">names</span> <span class="keyword">with</span> their <span class="keyword">data</span> types.</span>
</code></pre><h3 id="集中管理函数的退出条件">集中管理函数的退出条件</h3>
<hr>
<p>这部分主要是讨论goto的实用技巧(goto反对党请绕道)。  </p>
<pre><code>The <span class="keyword">goto</span> statement comes <span class="keyword">in</span> handy <span class="keyword">when</span> a <span class="keyword">function</span> exits <span class="keyword">from</span> multiple locations 
<span class="keyword">and</span> some common works such <span class="keyword">as</span> cleanup has <span class="keyword">to</span> be done.

Choose label names which say what the <span class="keyword">goto</span> does <span class="keyword">or</span> why the <span class="keyword">goto</span> exits.
</code></pre><p>goto语句在以下情况下，可以合理的使用：  </p>
<ul>
<li>unconditional statements are easier to understand and follow  </li>
<li>nesting is reduced  </li>
<li>errors by not updating individual exit points when making modifications are prevented — 暂时不理解:-(  </li>
<li>save the compiler work to optimize redundant code away  </li>
</ul>
<h3 id="注释">注释</h3>
<hr>
<p>这部分主要是一些避免over-commenting的原则。  </p>
<pre><code>NEVER <span class="keyword">try</span> <span class="keyword">to</span> explain HOW your code works <span class="keyword">in</span> a commment:
<span class="keyword">it</span>'s much better <span class="keyword">to</span> <span class="command">write</span> <span class="keyword">the</span> code so <span class="keyword">the</span> \_working\_ <span class="keyword">is</span> obvious, <span class="keyword">and</span> <span class="keyword">it</span>'s a 
waste <span class="keyword">of</span> <span class="property">time</span> <span class="keyword">to</span> explain badly written code.

Generally, you want your comments <span class="keyword">to</span> <span class="keyword">tell</span> WHAT your code <span class="keyword">does</span>, <span class="keyword">not</span> HOW. <span class="comment">--发人深省啊！</span>

Try <span class="keyword">to</span> avoid putting comments inside a function body.
Instead, <span class="keyword">put</span> <span class="keyword">the</span> comments <span class="keyword">at</span> <span class="keyword">the</span> head <span class="keyword">of</span> <span class="keyword">the</span> function, telling people what <span class="keyword">it</span> <span class="keyword">does</span>,
<span class="keyword">and</span> possibly WHY <span class="keyword">it</span> <span class="keyword">does</span> <span class="keyword">it</span>.  

Linux style <span class="keyword">for</span> comments <span class="keyword">is</span> <span class="keyword">the</span> C89 <span class="string">"/* ... */"</span> style.
Don't use C99-style <span class="string">"// ..."</span> comments.

The preferred style <span class="keyword">for</span> long (multi-line) comments <span class="keyword">is</span>:
/*
 * This <span class="keyword">is</span> <span class="keyword">the</span> preferred style <span class="keyword">for</span> multi-line
 * comments <span class="keyword">in</span> <span class="keyword">the</span> Linux kernel source code.
 * Please use <span class="keyword">it</span> consistently.
 */
</code></pre><h3 id="宏，枚举">宏，枚举</h3>
<hr>
<pre><code>Names <span class="operator">of</span> macros defining constants <span class="operator">and</span> labels <span class="operator">in</span> enums are capitalized.

Enums are preferred when defining serveral related constants.

CAPITALIZED macro names are appreciated but macros resembling functions may be  
named <span class="operator">in</span> <span class="built_in">lower</span> <span class="keyword">case</span>.

Generally, inline functions are preferable <span class="built_in">to</span> macros resembling functions. <span class="comment">-- 个人更认同这一原则。</span>

Macros <span class="operator">with</span> multiple statements should be eclosed <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">do</span>-which block.
</code></pre><h3 id="打印内核消息">打印内核消息</h3>
<pre><code>Make the messages concise, clear, <span class="keyword">and</span> unambiguous.

<span class="keyword">For</span> messages that aren<span class="comment">'t associated with a particular device, <span class="xmlDocTag">&lt;linux/printk.h&gt;</span> </span>
defines pr_notice(), pr_info(), pr_warn(), pr_err(), etc.
</code></pre><h3 id="inline的使用">inline的使用</h3>
<hr>
<pre><code>Abundant use <span class="operator">of</span> <span class="operator">the</span> inline keyword leads <span class="built_in">to</span> <span class="operator">a</span> much bigger kernel, which <span class="operator">in</span> turn 
slows <span class="operator">the</span> <span class="keyword">system</span> <span class="keyword">as</span> <span class="operator">a</span> <span class="keyword">whole</span> down, due <span class="built_in">to</span> <span class="operator">a</span> bigger icache footprint <span class="keyword">for</span> <span class="operator">the</span> CPU 
<span class="operator">and</span> simply because there is less memory available <span class="keyword">for</span> <span class="operator">the</span> pagecache.

A reasonable rule <span class="operator">of</span> thumb is <span class="built_in">to</span> <span class="operator">not</span> <span class="built_in">put</span> inline <span class="keyword">at</span> functions that have more 
than <span class="number">3</span> <span class="keyword">lines</span> <span class="operator">of</span> code <span class="operator">in</span> them.  <span class="comment">--即，inline应限制用于小函数 </span>
</code></pre><h3 id="函数返回值">函数返回值</h3>
<hr>
<pre><code><span class="keyword">If</span> the name <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> an action <span class="keyword">or</span> an imperative command, the <span class="keyword">function</span> 
should <span class="keyword">return</span> an <span class="keyword">error</span>-code <span class="built_in">integer</span>.
<span class="keyword">If</span> the name <span class="keyword">is</span> a predicate, the <span class="keyword">function</span> should <span class="keyword">return</span> a <span class="string">"succeeded"</span> <span class="built_in">boolean</span>.
</code></pre><h3 id="不要重复发明内核宏定义">不要重复发明内核宏定义</h3>
<pre><code>The header <span class="built_in">file</span> <span class="built_in">include</span>/linux/kernel.h <span class="operator">contains</span> <span class="operator">a</span> <span class="built_in">number</span> <span class="operator">of</span> macros that you 
should use, rather than explicitly coding some variant <span class="operator">of</span> them yourself.
</code></pre><h3 id="条件编译">条件编译</h3>
<hr>
<pre><code>Wherever possible, don't <span class="operator"><span class="keyword">use</span> preprocessor conditional (#<span class="keyword">if</span>, #ifdef) <span class="keyword">in</span> .c files, 
doing so makes code harder <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">and</span> logic harder <span class="keyword">to</span> follow.

Prefer <span class="keyword">to</span> compile out entire functions, rather than portions <span class="keyword">of</span> functions <span class="keyword">or</span> 
portions <span class="keyword">of</span> expressions.

Within code, <span class="keyword">where</span> possible, <span class="keyword">use</span> the IS_ENABLED macro <span class="keyword">to</span> <span class="keyword">convert</span> a Kconfig 
symbol <span class="keyword">into</span> a C <span class="built_in">boolean</span> expression, <span class="keyword">and</span> <span class="keyword">use</span> it <span class="keyword">in</span> a normal C conditional.

<span class="keyword">At</span> the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">any</span> non-trivial #<span class="keyword">if</span> <span class="keyword">or</span> #ifdef block (more than a few <span class="keyword">lines</span>), 
place a comment <span class="keyword">after</span> the #endif <span class="keyword">on</span> the same line, noting the conditional 
expression used. <span class="keyword">For</span> instance:
    #ifdef CONFIG_SOMETHING
    ...
    #endif <span class="comment">/* CONFIG_SOMETHING */</span></span>
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://www.kernel.org/doc/Documentation/CodingStyle" target="_blank" rel="external">Linux kernel coding style</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Alfred 使用记录]]></title>
    <link href="http://perthcharles.github.com/2015/03/27/alfred/"/>
    <id>http://perthcharles.github.com/2015/03/27/alfred/</id>
    <published>2015-03-27T07:34:58.000Z</published>
    <updated>2015-05-10T04:57:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br><a id="more"></a>  </p>
<hr>
<h3 id="1-_搜索">1. 搜索</h3>
<hr>
<p>Alfred的核心功能之一就是搜索，所以先简单介绍一下。<br>默认的热键组合是：option + space。<br>比如你想打开chrome浏览器，就可以直接在Alfred中输入chrome了。<br>相比于Spotlight它的显示结果更简单，更易于操作（特别是你想要的结果不是第一个结果时）。  </p>
<p>下面查找文件的方法来自<a href="http://macshuo.com/?p=625" target="_blank" rel="external">http://macshuo.com/?p=625</a>, 其实就是先输个空格，囧。  </p>
<pre><code>简单查找文件：用快捷键呼出Alfred，键入空格，输入你要查找文件名，
即可定位文件，回车打开，<span class="command"><span class="keyword">command</span>+回车打开文件所在文件夹。</span>
</code></pre><h3 id="2-_自定义搜索">2. 自定义搜索</h3>
<hr>
<p>上面只是搜索本地的资源，如果你想在某个特定网站进行搜索呢？<br>Alfred同样提供的custom search的功能，具体的方法可参考<a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br>我自己的案例就是用这个功能实现了在github中进行搜索。具体步骤如下：  </p>
<pre><code><span class="number">1</span>. 进入github页面，在输入框中随便输入一个关键字  
<span class="number">2</span>. 在得到的页面链接中，将你的关键字替换为{query}  
   如：https:<span class="comment">//github.com/search?utf8=%E2%9C%93&amp;q={query}  </span>
<span class="number">3</span>. 依次进入：Alfred的配置-&gt;Features -&gt;Web Search -&gt; Add custom search  
<span class="number">4</span>. 将search URL填写为第二步中得到的链接，其他表项也比较直观。  
   如：我的keyword设为了git, 这样我以后只要在Alfred中输入<span class="string">"git keyword"</span>
       就能直接在默认浏览器中打开github上面的搜索结果。  
</code></pre><h3 id="3-_我还是太年轻了">3. 我还是太年轻了</h3>
<hr>
<p>Alfred真是过于强大了，而且有不少作者总结的很好。这篇文章就写到这里吧，把参考资料都大概瞄一瞄，跟着学一遍基本差不多了。  </p>
<h3 id="4-_我的需求">4. 我的需求</h3>
<hr>
<p>算是TODO list吧，等学完了再回来填坑。  </p>
<pre><code><span class="number">0</span>. 学会用Python写workflow
<span class="number">1</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> VPN
<span class="number">2</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> wifi AP
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br><a href="http://zhuanlan.zhihu.com/pinapps/19986749" target="_blank" rel="external">用Alfred大幅提升操作效率 - workflow</a><br><a href="https://github.com/hzlzh/AlfredWorkflow.com" target="_blank" rel="external">Alfred workflow collection</a><br><a href="http://wellsnake.com/jekyll/update/2014/06/15/001/" target="_blank" rel="external">丢掉鼠标－Mac神软Alfred使用手册1</a><br><a href="http://www.alfredworkflow.com/" target="_blank" rel="external">Alfred workflow list</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://perthcharles.github.com/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Full Stack developer是怎样的一种存在？]]></title>
    <link href="http://perthcharles.github.com/2015/03/06/what-is-a-full-stack-developer/"/>
    <id>http://perthcharles.github.com/2015/03/06/what-is-a-full-stack-developer/</id>
    <published>2015-03-06T06:53:15.000Z</published>
    <updated>2015-05-09T17:06:32.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>总体上讲：  </p>
<pre><code>A Full Stack Developer is someone <span class="operator">with</span> familiarity <span class="operator">in</span> <span class="keyword">each</span> layer, 
<span class="keyword">if</span> <span class="operator">not</span> mastery <span class="operator">in</span> many <span class="operator">and</span> <span class="operator">a</span> genuine interest <span class="operator">in</span> all software technology.  

Good developers who are familiar <span class="operator">with</span> <span class="operator">the</span> entire stack know how <span class="built_in">to</span> 
make life easier <span class="keyword">for</span> those around them.  
</code></pre><a id="more"></a>  

<p>上面提到的“each layer”大体分为以下几个方面：  </p>
<pre><code><span class="bullet">1. </span>Server, Network, and Hosting Environment.  

<span class="bullet">2. </span>Data Modeling  

<span class="bullet">3. </span>Business Logic  

<span class="bullet">4. </span>API layer / Action Layer / MVC  

<span class="bullet">5. </span>User Interfaces  
<span class="code">    implementing a good visual design is key  </span>

<span class="bullet">6. </span>User Experience  

<span class="bullet">7. </span>Understanding what the customer and the business need
</code></pre><p>其他的内容还包括：  </p>
<pre><code><span class="number">1.</span> Ability <span class="keyword">to</span> <span class="command">write</span> quality unit tests.  

<span class="number">2.</span> Understanding <span class="keyword">of</span> repeatable automated processes <span class="keyword">for</span> building <span class="keyword">the</span> 
<span class="type">application</span>, testing <span class="keyword">it</span>, documenting <span class="keyword">it</span>, <span class="keyword">and</span> deploying <span class="keyword">it</span> <span class="keyword">at</span> scale.  

<span class="number">3.</span> An awareness <span class="keyword">of</span> security concerns <span class="keyword">is</span> important, <span class="keyword">as</span> each layer 
presents <span class="keyword">its</span> own possible valnerabilities.  
</code></pre><p>作者总结：  </p>
<pre><code>I’m <span class="operator">not</span> sure you can call yourself <span class="operator">a</span> full stack developer <span class="keyword">until</span> you 
have worked <span class="operator">in</span> multiple languages, platforms, <span class="operator">and</span> even industries 
<span class="operator">in</span> your professional career.   

Full stack goes beyond <span class="operator">a</span> <span class="string">'senior engineer'</span>, <span class="keyword">as</span> <span class="keyword">it</span> is along <span class="operator">the</span> same 
<span class="keyword">lines</span> <span class="keyword">as</span> <span class="operator">a</span> polyglot programmer but <span class="operator">with</span> <span class="operator">a</span> higher view <span class="operator">of</span> all <span class="operator">the</span> 
connecting pieces. Note that <span class="command"><span class="keyword">on</span> <span class="title">my</span> <span class="title">list</span>, <span class="title">only</span> <span class="title">items</span> <span class="title">3-5</span> <span class="title">involve</span> <span class="title">writing</span> <span class="title">code</span>.</span>
</code></pre><p>我的理解：  </p>
<pre><code><span class="bullet">1. </span>为了达到自己的某个目标，能够主动的分析问题，尽力设计出较实现方案。  

<span class="bullet">2. </span>如果需要去学习新的技能和知识时，也能积极主动的去学习。
这就需要有一定的甄别能力，哪个是真正需要的，哪个是更合适的。  

<span class="bullet">3. </span>Full Stack并不意味着work alone，重点应该是get things done. 
如果有更合适的更优秀的人，会愿意与他合作。  

<span class="bullet">4. </span>Full stack不是为了工作本身，而是为了实现自己的Dream。  
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.laurencegellert.com/2012/08/what-is-a-full-stack-developer/" target="_blank" rel="external">原文：What is a Full Stack developer</a><br><a href="http://www.zhihu.com/question/22420900" target="_blank" rel="external">怎样成为全栈工程师（Full Stack Developer）？</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>总体上讲：  </p>
<pre><code>A Full Stack Developer is someone <span class="operator">with</span> familiarity <span class="operator">in</span> <span class="keyword">each</span> layer, 
<span class="keyword">if</span> <span class="operator">not</span> mastery <span class="operator">in</span> many <span class="operator">and</span> <span class="operator">a</span> genuine interest <span class="operator">in</span> all software technology.  

Good developers who are familiar <span class="operator">with</span> <span class="operator">the</span> entire stack know how <span class="built_in">to</span> 
make life easier <span class="keyword">for</span> those around them.  
</code></pre>]]>
    
    </summary>
    
      <category term="好文共享" scheme="http://perthcharles.github.com/categories/%E5%A5%BD%E6%96%87%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux命令学习（十一）：lsof, vnstat, fuser, host, at, cron]]></title>
    <link href="http://perthcharles.github.com/2015/02/06/linux-using-11/"/>
    <id>http://perthcharles.github.com/2015/02/06/linux-using-11/</id>
    <published>2015-02-06T07:07:07.000Z</published>
    <updated>2015-05-10T05:02:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这次介绍一些系统使用和状态方面的一些命令，继续学习Linux命令  </p>
<a id="more"></a>  

<h3 id="1-_lsof:_list_open_file">1. lsof: list open file</h3>
<hr>
<p>使用实例如下：  </p>
<pre><code><span class="array"># lsof </span>-c &lt;process-name&gt;  <span class="comment">// 查看某个进程打开的文件  </span>
<span class="array"># lsof </span>/var/log/message   <span class="comment">// 查看massage文件当前在被谁使用  </span>
<span class="array"># lsof </span>-u ^root           <span class="comment">// 查看当前非root用户打开的文件信息  </span>
<span class="array"># lsof </span>-p <span class="number">1</span>               <span class="comment">// 查看1号进程打开的文件  </span>
<span class="array"># lsof </span>-p `pidof vim`     <span class="comment">// 查看vim进程打开的文件，效果如同第一条  </span>
<span class="array"># lsof </span>-i                 <span class="comment">// 显示所有网络连接信息  </span>
<span class="array"># lsof </span>-i tcp             <span class="comment">// 列出所有TCP网络连接信息  </span>
<span class="array"># lsof </span>-i :<span class="number">22</span>             <span class="comment">// 查看22端口现在运行的情况  </span>
</code></pre><h3 id="2-_vnstat:_a_console-based_network_traffic_monitor">2. vnstat: a console-based network traffic monitor</h3>
<hr>
<p>安装时候后才发现，vnstat并不能算一个实时的命令，更多的像是个制作历史报告的工具。<br>所以暂时就不学了，有需求再来看。<br>PS：如果想实时使用的话，可是使用—l选项。  </p>
<h3 id="3-_fuser:_identify_processing_using_files_or_sockets">3. fuser: identify processing using files or sockets</h3>
<hr>
<p>基本上能用lsof替代，暂时忽略。  </p>
<h3 id="4-_host:_DNS_lookup_utility">4. host: DNS lookup utility</h3>
<hr>
<p>使用实例如下：  </p>
<pre><code><span class="array"># host www.baidu.com      </span><span class="comment">// 查看百度的IP地址  </span>
<span class="array"># host </span>-a www.baidu.com   <span class="comment">// 显示详细的DNS查询消息  </span>
</code></pre><h3 id="5-_dig:_DNS_lookup_utility">5. dig: DNS lookup utility</h3>
<hr>
<p>dig同样也是一个DNS查询的工具，和host互为补充吧。  </p>
<pre><code># <span class="keyword">dig</span> www.baidu.<span class="keyword">com</span>         // 对百度网址进行DNS查询  
# <span class="keyword">dig</span> +trace www.baidu.<span class="keyword">com</span>  // 从根域开始跟踪查询结果  
# <span class="keyword">dig</span> +vc www.baidu.<span class="keyword">com</span>     // 使用TCP协议查询  
</code></pre><p>说道DNS，就想吐槽，大家都懂的.有兴趣的话大家可以对比下面两个命令的输出差异，对G.F.W.有一个大致的了解。  </p>
<pre><code># <span class="keyword">dig</span> +vc +trace www.baidu.<span class="keyword">com</span>  
# <span class="keyword">dig</span> +vc +trace www.facebook.<span class="keyword">com</span>  
</code></pre><h3 id="6-_ss:_another_utility_to_invertigate_sockets">6. ss: another utility to invertigate sockets</h3>
<hr>
<p>ss是socket statistics的缩写，相比于netstat能够显示过多关于socket细节的信息。<br>同时netstat略慢，而ss更快。  </p>
<pre><code><span class="array"># ss </span>-a -t       <span class="comment">// a == all, t == tcp  </span>
<span class="array"># ss </span>-s          <span class="comment">// s == summary, 显示socket信息摘要  </span>
<span class="array"># ss </span>-l          <span class="comment">// l == listenning  </span>
<span class="array"># ss </span>-p          <span class="comment">// p == processes, 显示哪些进程在用哪些socket  </span>
<span class="array"># ss </span>-pl         <span class="comment">// 查看哪些进程在使用listening状态的socket  </span>
</code></pre><h3 id="7-_关于环境变量LD_PRELOAD">7. 关于环境变量LD_PRELOAD</h3>
<hr>
<p>环境变量LD_PRELOAD指定程序运行时优先加载的动态链接库，且其中的符号优先级是最高的。所以在使用LD_PRELOAD环境变量后，可以替换掉标准C中的函数（默认放在libc.so.6文件中）。<br>比如想替换掉系统默认的malloc函数，则将LD_PRELOAD设置为新的malloc函数链接库。  </p>
<pre><code><span class="comment"># LD_PRELOAD="/home/user/mymalloc.so"  </span>
</code></pre><p>关于LD_PRELOAD环境变量，<a href="http://blog.csdn.net/haoel/article/details/1602108" target="_blank" rel="external">这篇文章</a>或许能让你脑洞大开。  </p>
<h3 id="8-_at:_executes_commands_at_a_specified_time">8. at: executes commands at a specified time</h3>
<hr>
<p>与cron配置一个周期性的服务不同，at命令主要是用于一次性的任务需求中。  </p>
<pre><code><span class="array"># at </span>-f myscript.sh -v <span class="number">10</span>:<span class="number">30</span>       <span class="comment">// 在10:30时刻，开始执行脚本  </span>
<span class="array"># timer</span>=`date +%k:%M -d <span class="string">'5 min'</span>`   <span class="comment">// 得到距离当前时刻5min的时间  </span>
<span class="array"># at </span>-f myscript.sh -v ${timer}    <span class="comment">// 在timer对应的时刻开始执行脚本  </span>
<span class="array"># atq                              </span><span class="comment">// 查看还未执行的任务  </span>
<span class="array"># atrm </span><span class="number">7</span>                           <span class="comment">// 使用任务编号进行删除  </span>
<span class="array"># at </span>-c <span class="number">8</span>                          <span class="comment">// 查看某任务编号对应的具体内容  </span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这次介绍一些系统使用和状态方面的一些命令，继续学习Linux命令  </p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="Shell" scheme="http://perthcharles.github.com/categories/Shell/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Network stack specialization for performance]]></title>
    <link href="http://perthcharles.github.com/2015/02/05/wiki-network-paper-stack-specialization/"/>
    <id>http://perthcharles.github.com/2015/02/05/wiki-network-paper-stack-specialization/</id>
    <published>2015-02-05T08:44:16.000Z</published>
    <updated>2015-05-10T05:07:48.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章是剑桥大学的Marinos发表在SIGCOMM 2014上的一篇关于网络协议栈优化的工作。<br>主要的argue就是指出，现有通用协议栈已经成为performance和scaling方面的主要瓶颈，是时候考虑做network stack specialization了。  </p>
<a id="more"></a>  

<h3 id="1-_Motivation">1. Motivation</h3>
<hr>
<p>首先，数据中心和大规模应用的出现，一定程度上改变了传统的服务需求。从之前的一台机器负责完成多个功能(1 machine n functions)变成了多台机器完成一件事情(n machines 1 function)。  </p>
<p>同时，数据中心中低延迟和高带宽的特点，使得endhost的软件协议栈的开销逐步的成为新的瓶颈。而这些部署在数据中心中的应用又是如此的在意performance。  </p>
<p>在对performance的更高准求的驱动下，作者认为针对n machines 1 function的应用场景有必要优化现有的软件协议栈（作者成为general-purpose stacks）。  </p>
<p>论文中的主要例子就是conventional stacks对于短流的性能不太好，同时又拿Yahoo! CDN的观测数据证明短流的普遍存在。  </p>
<h3 id="2-_Problem_and_Goals">2. Problem and Goals</h3>
<hr>
<p>本文想要解决的一大问题就是：短流在数据中心里<em>低</em>带宽利用率和<em>高</em>CPU使用率的问题。  </p>
<p>问题存在的主要原因就是：memory copy/move，context switch等。  </p>
<p>因此文章的主要目标就是设计一个定制化的协议栈，它能够更完美的做到zero-copy，更高效的做到数据的传输和响应，更聪明的利用应用的特点。<br>具体例子就是文章提到的sandstorm，对具体实现感兴趣的可以看下论文或PPT。  </p>
<h3 id="3-_Highlights">3. Highlights</h3>
<hr>
<ul>
<li>使用netmap，将应用层与NIC相关联，减少memory copy/move；  </li>
<li>利用了体系结构方面的技术：DDIO(Direct Data I/O)；  </li>
<li>对于短流，有2-10x的性能提升，同时CPU使用率也较低，对比对象为Linux + Ngnix和FreeBSD + Nginx。  </li>
</ul>
<h3 id="4-_My_Notes">4. My Notes</h3>
<hr>
<p>sandstorm一定程度上是提前准备好的数据，并且放在了DRAM中，作者对比的时候好像并未评测这个因素。因为Nginx从disk发数据，而sandstorm是从DRAM发数据。<br>本文创新方面也有待商榷，主要贡献就是利用一个demo重新在学术界呼吁了一下network stack specialization的重要性和可行性。论文最后一个作者是真神，有兴趣的可以去看下他的Google scholar。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章是剑桥大学的Marinos发表在SIGCOMM 2014上的一篇关于网络协议栈优化的工作。<br>主要的argue就是指出，现有通用协议栈已经成为performance和scaling方面的主要瓶颈，是时候考虑做network stack specialization了。  </p>
]]>
    
    </summary>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OSI模型]]></title>
    <link href="http://perthcharles.github.com/2015/01/26/wiki-network-osi-model/"/>
    <id>http://perthcharles.github.com/2015/01/26/wiki-network-osi-model/</id>
    <published>2015-01-26T08:57:56.000Z</published>
    <updated>2015-05-10T05:07:41.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>OSI model是Open System Interconnection reference model的缩写/简称，<br>是由国际标准化组织ISO提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI model将计算机网络体系结构划分为七层，分别是Application Layer, Presentation Layer, Session Layer, Transport Layer, Network Layer, Data link Layer 和 Physical Layer。<br>这个页面主要简单介绍一下各个层次的功能。<br><a id="more"></a>  </p>
<h3 id="1-_层次划分">1. 层次划分</h3>
<hr>
<p>下表来自wikipedia，但经过了一定的缩减。  </p>
<table>
<thead>
<tr>
<th>layer</th>
<th>function</th>
<th>examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Application</td>
<td>High-level APIs, including resource sharing, remote file access, derectory services and virtual terminals</td>
<td>HTTP, FTP, SMTP</td>
</tr>
<tr>
<td>Presentation</td>
<td>Translation of data between a networking service and an application, including character encoding and data compression</td>
<td>ASCII, JPEG</td>
</tr>
<tr>
<td>Session</td>
<td>Managing communication sessions</td>
<td>RPC</td>
</tr>
<tr>
<td>Transport</td>
<td>Reliable transmission of data segments between hosts</td>
<td>TCP, UDP</td>
</tr>
<tr>
<td>Network</td>
<td>Structing and managing a multi-node network, including addressing and routing</td>
<td>IPv4, IPv6</td>
</tr>
<tr>
<td>Data link</td>
<td>reliable transmission of data frames between two nodes connected by a physical layer</td>
<td>PPP, IEEE 802.2</td>
</tr>
<tr>
<td>Physical</td>
<td>Transmission and reception of raw bit streams over a physical medium</td>
<td>DSL</td>
</tr>
</tbody>
</table>
<p>Physical layer负责解决如何使用物理信号（如电信号，光信号）表达数字信号的问题，工作在这一层的设备主要有集线器；  </p>
<p>Data link layer则通过使用CRC等技术将物理层提供的可能出错的信息进行校验检错和封装。MAC地址是这一层最具代表性的标志，交换机是这层的代表性网络设备；  </p>
<p>Network layer的作用主要是决定如何将发送发的数据传到接收方，IP和routing是这一层最核心的技术，路由器则是最典型的三层设备；  </p>
<p>Transport layer是两台计算机经过网络进行数据通信时，具有端到端connection概念的层次。有诸如TCP的可靠的端到端协议和UDP这中不可靠的端到端协议。一般在这一层还会做一些流量控制，拥塞控制和差错检验的工作；  </p>
<p>Session layer的session一词就直接道出了这层的功能：会话。这层需要负责建立，管理和关闭所有涉及到的connections。  </p>
<p>Presentation layer负责定义数据的呈现方式以及解析方式，如果把session layer比作一次中美双边会谈，那么那些个翻译官就好比是工作在presentation layer；  </p>
<p>Application layer直接与User打交道的一层，它的任务也就是提供一些API，应用层序只需要使用这些API接口与负责网络通信的部分进行交互。  </p>
<p>当然，由于OSI是一个比较抽象的框架，所以现实世界中还会存在一些cross-layer的东西存在，一个最简单地例子就是ARP/RARP。同时目前应用最广的TCP/IP stack也不是完全符合OSI模型的。    </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://en.wikipedia.org/wiki/OSI_model#Description_of_OSI_layers" target="_blank" rel="external">OSI model</a>   </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>OSI model是Open System Interconnection reference model的缩写/简称，<br>是由国际标准化组织ISO提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。<br>OSI model将计算机网络体系结构划分为七层，分别是Application Layer, Presentation Layer, Session Layer, Transport Layer, Network Layer, Data link Layer 和 Physical Layer。<br>这个页面主要简单介绍一下各个层次的功能。<br>]]>
    
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[网络时钟同步协议-- NTP, PTP]]></title>
    <link href="http://perthcharles.github.com/2015/01/20/ntp-ptp-intro/"/>
    <id>http://perthcharles.github.com/2015/01/20/ntp-ptp-intro/</id>
    <published>2015-01-20T08:50:43.000Z</published>
    <updated>2015-05-10T05:03:31.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章介绍一下两个时钟同步的网络协议：NTP和PTP。<br>这里不涉及协议的原理和具体实现(想了解的可自行Google)，重点是如何搭建起这两个服务。<br><a id="more"></a>  </p>
<h3 id="1-_NTP及PTP简介">1. NTP及PTP简介</h3>
<hr>
<p>NTP(Network Time Protocol)是用于不同计算机之间同步时钟的网络协议。<br>它的设计目标是使所有的互连的机器之间的时钟与UTC时间只相差若干<em>毫秒</em>。  </p>
<p>目前NTP协议已经是有第4版了，如果不需要了解NTP太多细节的话，看看<a href="http://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="external">这个wiki页面</a>应该就足够了。需要注意的就是它有clock strata的概念。    </p>
<p>PTP(Precision Time Protocol)看名字就知道是一个比NTP更精确的时钟同步协议了，PTP的设计目标是使机器之间的时钟偏差在sub-microsecond范围—这是<a href="http://en.wikipedia.org/wiki/Precision_Time_Protocol" target="_blank" rel="external">wiki页面</a>上提到的，有其他的地方说的是偏差若干微秒，本文搭建的环境中测量到的偏差也在微秒级别，没有到sub-microsecond级别。在使用PTP协议时，需要了解的主要概念点就是它的master/slave机制。  </p>
<p>接下来我们就介绍我搭建NTP和PTP环境的过程，所用到的操作系统是CentOS6.5，内核版本是3.10。其他软件的版本会在用到时提及。  </p>
<h3 id="2-_搭建NTP服务">2. 搭建NTP服务</h3>
<hr>
<p>配置环境：两台服务器，一台做NTP服务器，一台做NTP的客户端。同时这两台机器都未联网。<br>NTP服务器地址：192.168.0.11<br>NTP客户端地址：192.168.0.22  </p>
<p>A. 在192.168.0.11中启动NTP服务  </p>
<pre><code>$ service iptables stop <span class="comment"> // 首先把防火墙关了  </span>
$ yum list |grep ntp    <span class="comment"> // 看下yum源中是否有ntp软件    </span>
$ yum install -y ntp    
$ ntpd <span class="comment">--version  </span>
    ntpd <span class="number">4.2</span><span class="number">.6</span>p5  
$ vim /etc/ntp.conf     <span class="comment"> // 修改配置文件  </span>
    restrict <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span> mask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span> nomodify nostrap <span class="comment"> // 限制作为局域网NTP服务器</span>
   <span class="comment"> // 下面两句很关键。含义是如果这台NTP服务器的server地址无法访问，  </span>
   <span class="comment"> // 则将本地时间作为NTP服务时间，这个IP地址也是固定的，不要修改  </span>
    server <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span>  
    fudge  <span class="number">127.127</span><span class="number">.1</span><span class="number">.0</span> stratum <span class="number">10</span>   
$ ntpd -p /var/run/ntpd.pid <span class="comment"> // 启动ntpd  </span>
$ service ntpd start         <span class="comment"> // 第二种启动ntpd服务的方法  </span><span class="comment">
// 等待5分钟  </span>
$ ntpstat<span class="comment"> // 从这条命令应该能看到NTP时钟同步好了，正常的显示结果应该与下面类似  </span>
    synchronised <span class="built_in">to</span> <span class="built_in">local</span> net <span class="keyword">at</span> stratum <span class="number">11</span>
        <span class="built_in">time</span> correct <span class="built_in">to</span> <span class="operator">within</span> <span class="number">11</span> ms  
        polling server every <span class="number">64</span> s
</code></pre><p>B. 在192.168.0.22上启动NTP服务，选择192.168.0.11为NTP服务器  </p>
<pre><code><span class="char">$ </span>service iptables stop
<span class="char">$ </span>yum install -y ntp
<span class="char">$ </span>vim /etc/ntp.conf  // 添加下面这个server地址，把其他的都注释掉  
    server <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span>  
<span class="char">$ </span>service ntpd start
<span class="char">$ </span>netstat  // 等待若干时间应该就能够显示同步成功了  
</code></pre><p>我的这两台实验机器是在同一个Rack的，结果显示差不多同步的偏差在30ms左右。<br>每个版本的ntpd配置文件可能有少许的差别，不过好在注释都做的不错，所以别的细节就不啰嗦了。  </p>
<h3 id="3-_搭建PTP服务">3. 搭建PTP服务</h3>
<hr>
<p>从<a href="http://en.wikipedia.org/wiki/List_of_PTP_implementations" target="_blank" rel="external">List of PTP implementations</a>可以看到PTP的实现有很多很多种，可以是硬件实现的，可以是软件实现的也可以是软硬件结合实现的。本文中搭建的PTP服务是基于软件<a href="http://en.wikipedia.org/wiki/PTPd" target="_blank" rel="external">PTPd</a>。如果没有特殊的硬件的话，这算是一种非常方便的方法了。  </p>
<pre><code>$ service iptables <span class="operator"><span class="keyword">stop</span> // 关掉防火墙  
$ yum list |grep ptp    // 检查yum源  
$ yum <span class="keyword">install</span> -y ptpd
$ ptpd2 <span class="comment">--version  </span>
    ptpd2 <span class="keyword">version</span> <span class="number">2.3</span><span class="number">.0</span>  
// 弄一个管理脚本，从serverfault找来的 ：）    
// http://serverfault.com/questions/<span class="number">329127</span>/ptp-<span class="keyword">time</span>-synchronization-<span class="keyword">on</span>-centos6-rhel
$ vim ptpd.sh  // 将PTPADRGS 改为 PTPD_EXTRA_OPTIONS  
$ chmod +x ptpd.sh 
$ vim /etc/ptpd2.conf  // 修改配置文件  
    ptpengine:preset=masterslave    // 对于<span class="keyword">master</span>主机，不要选masteronly，具体原因请查看<span class="keyword">help</span>  
    ptpengine:preset=slaveonly      // 对于<span class="keyword">slave</span>主机  
    // 其他选项也可以根据需要进行调整，比如<span class="keyword">log</span>是否开启，是否绑定CPU。这些看配置文件的注释就好了  
$ vim /etc/sysconfig/ptpd2  // 修改启动命令，主要就是指定PTPD的配置文件  
    PTPD_EXTRA_OPTIONS=<span class="string">"-c /etc/ptpd2.conf"</span>  
// 现在就可以使用下面三个命令来启动，查看和关闭ptpd服务了  
$ ./ptpd.sh <span class="keyword">start</span>  
$ ./ptpd.sh <span class="keyword">status</span>  
$ ./ptpd.sh <span class="keyword">stop</span>  </span>
</code></pre><p>如果遇到任何问题，首先一定要看看help，使用-H选项的话还能看到非常详细的配置（虽然大多我可看不懂，不过不能不看，理解的越多，遇到的问题就会越少）。<br>如果log里面的信息看不懂，可以把代码下下来，一个grep搞定。  </p>
<p>经测试，在我的机器上使用PTPD软件搭建的服务，时钟偏移的平均值能够达到5us左右。这个粒度基本能满足我们的需求了。  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://en.wikipedia.org/wiki/Network_Time_Protocol" target="_blank" rel="external">Network Time Protocol</a><br><a href="http://blog.chinaunix.net/uid-20551990-id-4308732.html" target="_blank" rel="external">CentOS 6.3搭建NTP服务器</a><br><a href="http://blog.meinbergglobal.com/2013/09/14/ieee-1588-accurate/" target="_blank" rel="external">Why is IEEE 1588 so accurate?</a><br><a href="http://en.wikipedia.org/wiki/Precision_Time_Protocol" target="_blank" rel="external">Precision Time Protocol</a><br><a href="http://en.wikipedia.org/wiki/List_of_PTP_implementations" target="_blank" rel="external">List of PTP implementations</a><br><a href="http://sourceforge.net/projects/ptpd/?source=typ_redirect" target="_blank" rel="external">ptpd source code</a><br><a href="http://serverfault.com/questions/329127/ptp-time-synchronization-on-centos6-rhel" target="_blank" rel="external">ptpd manage scripts</a><br><a href="http://www.h3c.com.cn/products___technology/technology/system_management/other_technology/technology_recommend/201008/686476_30003_0.htm" target="_blank" rel="external">PTP技术介绍 by H3C</a><br><a href="http://sourceforge.net/p/ptpd/wiki/Home/" target="_blank" rel="external">PTP FAQ</a><br><a href="http://blog.meinbergglobal.com/2013/11/22/ntp-vs-ptp-network-timing-smackdown/" target="_blank" rel="external">More: NTP vs PTP</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章介绍一下两个时钟同步的网络协议：NTP和PTP。<br>这里不涉及协议的原理和具体实现(想了解的可自行Google)，重点是如何搭建起这两个服务。<br>]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="NTP" scheme="http://perthcharles.github.com/tags/NTP/"/>
    
      <category term="PTP" scheme="http://perthcharles.github.com/tags/PTP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何为hexo主题添加新layout]]></title>
    <link href="http://perthcharles.github.com/2015/01/17/how-to-hack-hexo/"/>
    <id>http://perthcharles.github.com/2015/01/17/how-to-hack-hexo/</id>
    <published>2015-01-17T08:09:48.000Z</published>
    <updated>2015-05-10T08:13:33.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在使用小组内部的paper reading list的时候，突然想到应该给我自己的博客也添加一个类似的页面或功能，用来比较系统的整理一些知识点。<br>最初的idea只是想添加一个简单地页面，它默认情况下以列表的形式显示条目名称，而条目对应的具体内容则是被点击后才展开。但后来又想，如果每次添加或者删除某个条目时，都需要对这个页面进行修改，可能维护起来不太方便。<br>在找到<a href="http://hahack.com/codes/hexo-theme-wixo/" target="_blank" rel="external">Wixo</a>这个hexo的主题后，我就知道我想要的那个页面就是这个样子的。<br>但我暂时还不想完全改变博客的主题，所以就需要将Wixo主题实现的功能给融合进现有的<a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="external">Landscape</a>主题中，整个过程记录成此文。<br><a id="more"></a>  </p>
<h3 id="1-_Hexo主题的安装与使用">1. Hexo主题的安装与使用</h3>
<hr>
<p>Hexo安装一个主题的方法非常简单，只需要在<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">theme list</a>中找准一个自己喜欢的主题，然后下载下来就可以了。<br>以默认landscape主题为例，具体步骤如下：  </p>
<pre><code><span class="comment">// 将源码下载到你博客项目的themes目录下  </span>
$ git <span class="keyword">clone</span> https:<span class="comment">//github.com/hexojs/hexo-theme-landscape.git themes/landscape</span>
<span class="comment">// 编辑_config.yml，将theme设置为landscape  </span>
$ vim _config.yml  
  theme: landscape 
</code></pre><h3 id="2-_Landscape主题的源码结构">2. Landscape主题的源码结构</h3>
<hr>
<p>关于hexo主题的源码结构，在<a href="http://hexo.io/docs/themes.html" target="_blank" rel="external">官方的文档:Themes</a>中有比较详细的介绍，_config.yml是主题的配置文件，scripts文件夹主要用于存放javascript脚本，source中主要存放CSS，图片等内容，layout中则实现了该主题支持的layout。<br>在layout文件夹中是一些ejs文件，EJS是Embedded JavsScript的缩写，这些ejs文件完成的功能我理解成整个博客框架的模板。  </p>
<pre><code><span class="keyword">layout</span>.ejs：是整个博客的最基本的模板，所有的页面都在它基础上展开。  
从源码可以到，它主要就是为每一个页面定义了一个统一的最基本的框架，比如head,sidebar,footer。      
</code></pre><figure class="highlight title:"><figcaption><span>layout.ejs源码  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="vbscript">&lt;%- partial(<span class="comment">'_partial/head') %&gt;</span></span></div><div class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"wrap"</span>&gt;</span></div><div class="line">      <span class="vbscript">&lt;%- partial(<span class="comment">'_partial/header', null, {cache: !config.relative_link}) %&gt;</span></span></div><div class="line">      <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="title">section</span> <span class="attribute">id</span>=<span class="value">"main"</span>&gt;</span><span class="vbscript">&lt;%- body %&gt;</span><span class="tag">&lt;/<span class="title">section</span>&gt;</span></div><div class="line">        <span class="vbscript">&lt;% <span class="keyword">if</span> (theme.sidebar && theme.sidebar !== <span class="comment">'bottom'){ %&gt;</span></span></div><div class="line">          <span class="vbscript">&lt;%- partial(<span class="comment">'_partial/sidebar', null, {cache: !config.relative_link}) %&gt;</span></span></div><div class="line">        <span class="vbscript">&lt;% } %&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">      <span class="vbscript">&lt;%- partial(<span class="comment">'_partial/footer', null, {cache: !config.relative_link}) %&gt;</span></span></div><div class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">    <span class="vbscript">&lt;%- partial(<span class="comment">'_partial/mobile-nav', null, {cache: !config.relative_link}) %&gt;</span></span></div><div class="line">    <span class="vbscript">&lt;%- partial(<span class="comment">'_partial/after-footer') %&gt;</span></span></div><div class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></div></pre></td></tr></table></figure>

<p>而最常见的post和page都是在layout.ejs的基础上，补全了<strong><em>body</em></strong>部分。而且从源码来看，post和page的layout细节上是完全一致的，唯一的不同是hexo对于post和page这两类layout的处理方式不一样，具体可以去看看文档。    </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">post</span>.ejs源码：  </div><div class="line">    &lt;%- partial(<span class="string">'_partial/article'</span>, {<span class="built_in">post</span>: page, index: <span class="constant">false</span>}) %&gt;  </div><div class="line">page.ejs源码：  </div><div class="line">    &lt;%- partial(<span class="string">'_partial/article'</span>, {<span class="built_in">post</span>: page, index: <span class="constant">false</span>}) %&gt;</div></pre></td></tr></table></figure>



<h3 id="3-_如何将wixo主题的layout添加进landscape主题？">3. 如何将wixo主题的layout添加进landscape主题？</h3>
<hr>
<p>通过大致分析了landscape主题layout的源码，具体怎么hack landscape主题就不难了。目前的实现方法如下：<br>a. 在layout文件夹中增加wiki-index.ejs这个layout，源码基本参照<a href="https://github.com/wzpan/hexo-theme-wixo/blob/master/layout/_partial/index.ejs" target="_blank" rel="external">wixo的index.ejs</a>；<br>b. 将wixo需要的CSS和JS都放到landscape的相应位置，然后在wiki-index.ejs中引用；<br>c. 为博客建一个layout是wiki-index.ejs的post，然后将它的链接放到导航栏中；<br>d. 从下面wiki-index.ejs的实现中，可以看到我使用了一个trick来生成wiki页面。wiki-index页面只会解析名字是以”wiki-“开头的category。这可能会对原始博客的categories widget造成干扰，有待进一步改善。  </p>
<figure class="highlight title:"><figcaption><span>wiki-index.ejs源码  </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/bootstrap-responsive.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/bootstrap.min.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/font-awesome.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/google-fonts.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/responsive.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/sidenav.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/style.css']) %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- css([<span class="comment">'css/wiki/highlight.css']) %&gt;</span></span></div><div class="line"></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/jquery-2.0.3.min.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/jquery.imagesloaded.min.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/jquery.tableofcontents.min.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/gallery.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/main.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/bootstrap.min.js') %&gt;</span></span></div><div class="line"><span class="vbscript">&lt;%- js(<span class="comment">'js/wiki/tocgenerator.min.js') %&gt;</span></span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"row page"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"col-md-12"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"panel-group"</span> <span class="attribute">id</span>=<span class="value">"notebook"</span>&gt;</span></div><div class="line">      <span class="vbscript">&lt;% site.categories.sort(<span class="comment">'name').each(function(cat){ %&gt;</span></span></div><div class="line">      <span class="vbscript">&lt;% <span class="keyword">if</span>(cat.name.substring(<span class="number">0</span>, <span class="number">5</span>) == <span class="comment">'wiki-') { %&gt;</span></span></div><div class="line">        <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"panel panel-default"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"panel-heading"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">a</span> <span class="attribute">class</span>=<span class="value">"panel-title"</span> <span class="attribute">data-toggle</span>=<span class="value">"collapse"</span> <span class="attribute">data-parent</span>=<span class="value">"#notebook"</span> <span class="attribute">href</span>=<span class="value">"#&lt;%= cat.name %&gt;"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="title">i</span> <span class="attribute">class</span>=<span class="value">"fa fa-folder"</span>&gt;</span><span class="tag">&lt;/<span class="title">i</span>&gt;</span> <span class="vbscript">&lt;%= cat.name %&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"&lt;%= cat.name %&gt;"</span> <span class="attribute">class</span>=<span class="value">"panel-collapse collapse"</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"panel-body"</span>&gt;</span></div><div class="line">              <span class="vbscript">&lt;%- list_posts({orderby:<span class="string">"date"</span>,order:<span class="number">1</span>,count:<span class="number">65535</span>,query:{categories:cat.name}}) %&gt;</span>              <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line">      <span class="vbscript">&lt;% } %&gt;</span></div><div class="line">      <span class="vbscript">&lt;% }); %&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span><span class="comment">&lt;!-- accordion --&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></div></pre></td></tr></table></figure>




<p>最后非常感谢Wixo的作者<a href="https://github.com/wzpan" target="_blank" rel="external">wzpan</a>实现了这么美观又实用的一个主题。  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://hexo.io/docs/" target="_blank" rel="external">Hexo: Documentation</a><br><a href="http://hahack.com/codes/hexo-theme-wixo/" target="_blank" rel="external">Wixo - a wiki theme for Hexo</a><br><a href="http://hahack.tk/hexo-theme-wixo/#" target="_blank" rel="external">Wixo demo</a><br><a href="https://github.com/wzpan/hexo-theme-wixo" target="_blank" rel="external">Wixo source code</a><br><a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="external">Hexo: theme list</a><br><a href="http://kevinsfork.info/2015/02/25/hexo-lightum-enhance/" target="_blank" rel="external">Hexo折腾笔记（二）博客优化与定制</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在使用小组内部的paper reading list的时候，突然想到应该给我自己的博客也添加一个类似的页面或功能，用来比较系统的整理一些知识点。<br>最初的idea只是想添加一个简单地页面，它默认情况下以列表的形式显示条目名称，而条目对应的具体内容则是被点击后才展开。但后来又想，如果每次添加或者删除某个条目时，都需要对这个页面进行修改，可能维护起来不太方便。<br>在找到<a href="http://hahack.com/codes/hexo-theme-wixo/" target="_blank" rel="external">Wixo</a>这个hexo的主题后，我就知道我想要的那个页面就是这个样子的。<br>但我暂时还不想完全改变博客的主题，所以就需要将Wixo主题实现的功能给融合进现有的<a href="https://github.com/hexojs/hexo-theme-landscape" target="_blank" rel="external">Landscape</a>主题中，整个过程记录成此文。<br>]]>
    
    </summary>
    
      <category term="hexo" scheme="http://perthcharles.github.com/tags/hexo/"/>
    
      <category term="wixo" scheme="http://perthcharles.github.com/tags/wixo/"/>
    
      <category term="博客搭建" scheme="http://perthcharles.github.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[test-wiki]]></title>
    <link href="http://perthcharles.github.com/2015/01/14/test-wiki/"/>
    <id>http://perthcharles.github.com/2015/01/14/test-wiki/</id>
    <published>2015-01-14T13:34:08.000Z</published>
    <updated>2015-05-10T05:06:05.000Z</updated>
    <content type="html"><![CDATA[]]></content>
    <summary type="html">
    <![CDATA[]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[tcpprobe, observe the TCP flow with kprobes]]></title>
    <link href="http://perthcharles.github.com/2014/12/19/tcp-probe-intro/"/>
    <id>http://perthcharles.github.com/2014/12/19/tcp-probe-intro/</id>
    <published>2014-12-19T02:49:23.000Z</published>
    <updated>2015-05-10T05:05:48.000Z</updated>
    <content type="html"><![CDATA[<p>这篇文章介绍最近用到的一个监听TCP信息的内核模块：tcpprobe.<br>主要说说这个内核模块：  </p>
<ol>
<li>tcpprobe是什么？  </li>
<li>tcpprobe的基本用法？  </li>
<li>tcpprobe是怎么实现的？  </li>
<li>实践中如何用好tcpprobe？  </li>
</ol>
<a id="more"></a>  

<hr>
<h4 id="1-_tcp_probe_是什么？">1. tcp probe 是什么？</h4>
<p>下面摘录<a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/tcpprobe" target="_blank" rel="external">LINUX FOUNDATION对于tcpprobe</a>上对于tcpprobe的一段解释：  </p>
<pre><code>tcpprobe is <span class="operator">a</span> module that records <span class="operator">the</span> state <span class="operator">of</span> <span class="operator">a</span> TCP connection <span class="operator">in</span> response <span class="built_in">to</span> incoming packets.  
It works <span class="keyword">by</span> inserting <span class="operator">a</span> hook <span class="keyword">into</span> <span class="operator">the</span> tcp_recv processing path <span class="keyword">using</span> kprobe, so that <span class="operator">the</span> 
congestion window <span class="operator">and</span> sequence <span class="built_in">number</span> can be captured.  
</code></pre><p>首先tcpprobe是一个内核模块，可以按需加载与卸载。在下文的实践中如何用好tcpprobe可以看出模块化的好处。<br>同时tcpprobe是用于监听某些特定TCP的，而不是整个TCP/IP协议栈的内容。在使用tcpprobe模块时需要指定特定的端口号用于监听。<br>这个限制主要是出于效率上的考虑，但是基本上也能满足大部分的需求了，后面我们也将介绍如何根据需要实现我们自己的限制条件。<br>最后tcpprobe是基于kprobe机制实现的，它能捕捉cwnd和seq等信息。这些内容将在后续的内容中具体介绍。  </p>
<hr>
<h4 id="2-_tcpprobe的基本用法">2. tcpprobe的基本用法</h4>
<p>Linux Foundation上有一个简单地例子，这里我结合我的实际使用给出一个更加具体的例子。  </p>
<p>2.1 编译tcpprobe模块  </p>
<pre><code><span class="comment">// 方法1：tcpprobe是一个内核模块，在Linux 3.10中它的实现代码是net/ipv4/tcp_probe.c  </span>
<span class="comment">//        可以设置在编译内核时，将tcpprobe也编译了。方法就是在.config中添加</span>
CONFIG_NET_TCPPROBE=m  

<span class="comment">// 方法2：可以像一个普通内核模块一样，只编译tcpprobe模块，然后加载  </span>
# vim Makefile    <span class="comment">// 为tcpprobe模块建立一个新Makefile文件，最好把整个tcp_probe.c和Makefile放到单独的一个文件夹中</span>
obj-m += tcp_probe.o
all:
    make -C <span class="regexp">/lib/m</span>odules<span class="regexp">/`uname -r`/</span>build M=${PWD} modules  
clean:
    make -C <span class="regexp">/lib/m</span>odules<span class="regexp">/`uname -r`/</span>build M=${PWD} clean
</code></pre><p>2.2 tcpprobe模块的加载与卸载  </p>
<pre><code><span class="comment">// 如果是通过修改.config来编译tcpprobe的，可以使用modprobe加载    </span>
<span class="preprocessor"># modprobe tcp_probe port=5001          // 监听所有本地端口是5001的TCP流，仅在cwnd变化时捕捉信息  </span>
<span class="preprocessor"># modprobe tcp_probe full=1 port=5001   // full选项表示每次收到数据包都捕捉信息</span>

<span class="comment">// 如果是普通内核模块形式编译的，则使用insmod加载  </span>
<span class="preprocessor"># insmod tcp_probe.ko full=1 port=5001  </span>

<span class="comment">// 卸掉tcpprobe模块的命令也很简单，只要当前没有任务在使用tcpprobe模块即可卸载  </span>
<span class="preprocessor"># rmmod tcp_probe  </span>
</code></pre><p>2.3 tcpprobe模块的使用<br>加载tcpprobe模块后，会新增一个/proc/net/tcpprobe的接口，可以通过这个接口获取tcpprobe捕捉的信息。  </p>
<pre><code><span class="preprocessor"># cat /proc/net/tcpprobe &gt; data.out &amp;    // tcpprobe捕捉的信息是持续性的，因此读这个接口可以放到后台读  </span>
<span class="preprocessor"># pid=$!   // 保存上一个读命令的pid，用于结束读tcpprobe接口  </span>
<span class="preprocessor"># iperf -c otherhost    // 使用iperf建立一个TCP流  </span>
<span class="preprocessor"># kill $pid  </span>
</code></pre><p>记录在data.out中的数据大致是这个样子：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">11<span class="class">.172120204</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.2</span><span class="pseudo">:8089</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.25</span><span class="pseudo">:54320</span> 32 0<span class="tag">x842ccad</span> 0<span class="tag">x84299c5</span> 10 168 14608 143  </div><div class="line">11<span class="class">.172141113</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.2</span><span class="pseudo">:8089</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.25</span><span class="pseudo">:54320</span> 32 0<span class="tag">x842ccad</span> 0<span class="tag">x842b60d</span> 11 168 29088 137  </div><div class="line">11<span class="class">.172283353</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.2</span><span class="pseudo">:8089</span> 193<span class="class">.168</span><span class="class">.0</span><span class="class">.25</span><span class="pseudo">:54320</span> 32 0<span class="tag">x842f9ed</span> 0<span class="tag">x842bbb5</span> 11 168 31984 133</div></pre></td></tr></table></figure>


<p>每行的各列分别为：  </p>
<pre><code>timestamp  
saddr:port  <span class="comment">// 源IP及端口，我的数据是在发送端捕捉的，所以port是固定的8089    </span>
daddr:port  <span class="comment">// 目的IP及端口  </span>
skb-&gt;len    <span class="comment">// 收到的数据包skb大小，收到的都是ACK包，所以len都比较小。  </span>
snd_nxt     <span class="comment">// 下一个待发送数据的序列号  </span>
snd_una     <span class="comment">// 待确认数据的序列号  </span>
snd_cwnd    <span class="comment">// 拥塞窗口大小  </span>
ssthresh    <span class="comment">// 慢启动阈值  </span>
snd_wnd     <span class="comment">// 接收窗口大小  </span>
srtt        <span class="comment">// smoothed RTT  </span>
</code></pre><p>可以使用简单地文本处理及gnuplot将得到的数据进行可视化，不过这里就不展开了。  </p>
<hr>
<h4 id="3-_tcpprobe是怎么实现的？">3. tcpprobe是怎么实现的？</h4>
<p>tcpprobe是一个机遇kprobe机制实现的模块，代码量其实不大，这节算是我的一个学习笔记吧。  </p>
<p>首先tcpprobe定义了两个由于记录捕捉信息的数据结构：struct tcp_log和static struct tcp_probe。<br>tcp_log的元素基本就是上面介绍的一行中各列的数据，而tcp_probe结构体算是一个管理结构体，比如spinlock和用于判断cwnd是否改变的lastcwnd。  </p>
<p>作为一个内核模块，必不可少的就是初始化和退出函数。下面先总体上说下这两个函数完成的任务。  </p>
<pre><code><span class="keyword">static</span> __init <span class="type">int</span> tcpprobe_init(<span class="type">void</span>)  
    =&gt; spin_lock_init(&amp;tcp_probe.lock)  // 初始化tcp_probe结构体中的内容  
    =&gt; tcp_probe.log = kcalloc(bufsize, sizeof(struct tcp_log), <span class="type">GFP_KERNEL</span>) // 为捕捉数据分配内存空间  
    =&gt; proc_create(procname, <span class="type">S_URUSR</span>, init_net.proc_net, &amp;tcpprobe_fops)    // 为tcpprobe模块创建一个<span class="keyword">proc</span>文件系统接口  
    =&gt; register_jprobe(&amp;tcp_jprobe) // 将tcp_jprobe注册到内核中  

<span class="keyword">static</span> __exit <span class="type">void</span> tcpprobe_exit(<span class="type">void</span>)
    =&gt; remove_proc_entry(procname, init_net.proc_net);  // 删除tcpprobe模块的<span class="keyword">proc</span>接口  
    =&gt; unregister_jprobe(&amp;tcp_jprobe);  // 注销tcp_jprobe
    =&gt; kfree(tcp_probe.log)      // 释放内存
</code></pre><p>tcp_probe中锁的初始化和内存分配就不说了，先介绍一下proc_create()函数创建的proc接口，再说说register_jprobe()函数。<br>proc_create()函数的原型如下，在include/linux/proc_fs.h中实现。  </p>
<pre><code><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> proc_dir_entry *proc_create(
        <span class="keyword">const</span> <span class="keyword">char</span> *name, umode_t mode, <span class="keyword">struct</span> proc_dir_entry *parent,
        <span class="keyword">const</span> <span class="keyword">struct</span> file_operations *proc_fops)
</code></pre><p>tcpprobe模块中的各个参数的含义如下：  </p>
<ol>
<li>name      = “tcpprobe”  </li>
<li>mode      = S_IRUSR, 允许读文件  </li>
<li>parent    = init_net.proc_net，新建的proc接口将出现在/proc/net/目录中  </li>
<li>proc_fops = &amp;tcpprobe_fops  </li>
</ol>
<p>tcpprobe_fops结构体的声明如下  </p>
<pre><code>static const struct file_operations <span class="variable">tcpprobe_fops =</span> {
    .<span class="variable">owner   =</span> THIS_MODULE,
    .<span class="variable">open    =</span> tcpprobe_open,  
    .<span class="variable">read    =</span> tcpprobe_read,  
    .<span class="variable">llseek  =</span> noop_llseek,
};
</code></pre><p>proc接口也是被当做文件来处理的，且由于是只读的，所以主要需要实现open和read这两个函数。<br>tcpprobe_open()主要就是将tcp_probe结构体的各项内容进行reset，<br>tcpprobe_read()则是读取已经记录的数据，当没有数据可读时则睡眠，正常情况就将tcp_probe.log数组的最后一项读取出来。  </p>
<p>至此还只是建好了一个只读的proc接口，但是数据的采集函数并没有注册到内核中，接下来就简单说说tcp_jprobe这个数据结构体。<br>register_jprobe()函数的原型如下，在kernel/kprobes.c中实现。  </p>
<pre><code><span class="keyword">int</span> __kprobes register_jprobe(<span class="keyword">struct</span> jprobe *jp)  
</code></pre><p>tcp_jprobe结构体的定义如下：  </p>
<pre><code>static struct jprobe <span class="variable">tcp_jprobe =</span> {
    .<span class="variable">kp =</span> {
        .<span class="variable">symbol_name  =</span> <span class="string">"tcp_rcv_established"</span>,
    },
    .<span class="variable">entry =</span> jtcp_rcv_established,
};
</code></pre><p>可以看出来，tcpprobe其实是用的jprobe方式实现的，监听tcp_rcv_established函数(这也是为什么tcpprobe不会抓取三次握手时候的包信息的原因)。<br>对kprobe和jprobe感兴趣的话，可以看看最后给出的几个参考资料。  </p>
<p>最后说说jtcp_rcv_established()函数，由于它是用于监听tcp_rcv_established()函数的，因此函数的参数需要完全一致，从而jtcp_rcv_established()就拿到了一个TCP流最关键的sk结构体。<br>具体实现就是如果这个包的Port是监听的那一个，则往tcp_probe.log中新写入一项，然后唤醒等待数据的读进程。<br>还有一点就是tcp_probe.log是以一个循环数组形式实现的，再具体点就是那种保留一项不用的实现。代码就补解释了。  </p>
<h4 id="4-_实践中如何用好tcpprobe？">4. 实践中如何用好tcpprobe？</h4>
<p>在实践中往往会发现tcpprobe的功能还不够强大，但只要适当修改，利用tcpprobe的实现原理还是能做很多的事情的。<br>tcpprobe算是目前为止我了解到的用于分析Linux内核TCP流的最赞的工具之一了。  </p>
<p>首先，由于tcpprobe能够拿到TCP流的sk结构体，其实它能用于打印输出的信息远远不止是cwnd。<br>sk结构体是内核中记录一个TCP流最关键的数据结构，里面包含一条TCP流几乎任何的信息。<br>比如内存相关的可以看发送缓冲区的大小和占用情况，接收缓存区的大小。<br>其实只要在内核中拿到了一条TCP流的sk结构体，几乎可以对这条TCP流做任何事情。<br>所以建议在使用tcpprobe的时候，根据自己的需求修改tcp_probe.log结构体的内容。  </p>
<p>其次，有时候无法或不便知道端口号，tcpprobe的现有实现就无法满足要求了。但是其实只要根据实际情况适当的修改tcpprobe模块，或许就能达到目的。比如如果我们知道src IP和dst IP，那么只要修改jtcp_rcv_established()函数记录数据的判断条件即可。  </p>
<p>最后如果对TCP的内核实现熟悉的话，甚至可以改掉tcpprobe的监听入口函数。比如我们想监听skb发送时的一些信息，可以把监听入口函数改为tcp_transmit_skb()。  </p>
<p>以上。</p>
<hr>
<h4 id="参考资料">参考资料</h4>
<p><a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/tcpprobe" target="_blank" rel="external">tcpprobe by LINUX FOUNDATION</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-kprobes.html" target="_blank" rel="external">使用Kprobes调试内核 by IBM</a><br><a href="https://www.redhat.com/magazine/005mar05/features/kprobes/" target="_blank" rel="external">Gaining insight into the linux kernel with kprobes</a><br><a href="http://www.opensourceforu.com/2011/04/kernel-debugging-using-kprobe-and-jprobe/" target="_blank" rel="external">Kernel Debugging Using Kprobe and Jprobe</a><br><a href="http://lwn.net/Articles/132196/" target="_blank" rel="external">An introduction to KProbes</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这篇文章介绍最近用到的一个监听TCP信息的内核模块：tcpprobe.<br>主要说说这个内核模块：  </p>
<ol>
<li>tcpprobe是什么？  </li>
<li>tcpprobe的基本用法？  </li>
<li>tcpprobe是怎么实现的？  </li>
<li>实践中如何用好tcpprobe？  </li>
</ol>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tshark, network protocol analyzer]]></title>
    <link href="http://perthcharles.github.com/2014/12/16/tshark-intro/"/>
    <id>http://perthcharles.github.com/2014/12/16/tshark-intro/</id>
    <published>2014-12-16T09:17:05.000Z</published>
    <updated>2015-05-10T05:06:26.000Z</updated>
    <content type="html"><![CDATA[<p>分析过网络trace的同学一定对tcpdump和wireshark比较熟悉，但是wireshark毕竟是一个图形界面，如果想对整个抓包和分析包的过程都脚本化，wireshark可能就不能满足需求了。<br>Google找到了tshark，terminal wireshark，果断用起来啊，当然类似的工具还有tcptrace。<br>基本的用法Google一下就能找到，tshark能做的事情还是听多的。结合shell和gunplot用起来的话基本上能满足基本需求了。  </p>
<hr>
<p><a href="https://www.wireshark.org/docs/man-pages/tshark.html" target="_blank" rel="external">tshark man page</a><br><a href="http://www.tcptrace.org/" target="_blank" rel="external">tcptrace</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>分析过网络trace的同学一定对tcpdump和wireshark比较熟悉，但是wireshark毕竟是一个图形界面，如果想对整个抓包和分析包的过程都脚本化，wireshark可能就不能满足需求了。<br>Google找到了tshark，terminal wireshark]]>
    </summary>
    
      <category term="tshark" scheme="http://perthcharles.github.com/tags/tshark/"/>
    
      <category term="wireshark" scheme="http://perthcharles.github.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux Phase 1]]></title>
    <link href="http://perthcharles.github.com/2014/12/16/tcp-design-and-implementation-phase1/"/>
    <id>http://perthcharles.github.com/2014/12/16/tcp-design-and-implementation-phase1/</id>
    <published>2014-12-16T08:11:42.000Z</published>
    <updated>2015-05-10T05:05:37.000Z</updated>
    <content type="html"><![CDATA[<p>对Linux TCP implementation的阅读暂时先告一段落。以后有需求的时候再来加深理解。<br>顺道分享一个总结性的<a href="http://vdisk.weibo.com/s/B_gfVkmzsvB60" target="_blank" rel="external">PPT</a>。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对Linux TCP implementation的阅读暂时先告一段落。以后有需求的时候再来加深理解。<br>顺道分享一个总结性的<a href="http://vdisk.weibo.com/s/B_gfVkmzsvB60" target="_blank" rel="ex]]>
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(8): TCP receive]]></title>
    <link href="http://perthcharles.github.com/2014/11/20/tcp-design-and-implementation-8/"/>
    <id>http://perthcharles.github.com/2014/11/20/tcp-design-and-implementation-8/</id>
    <published>2014-11-20T08:17:45.000Z</published>
    <updated>2015-05-10T05:05:13.000Z</updated>
    <content type="html"><![CDATA[<p>这章主要是TCP接收包得处理流程。<br>kernel对于TCP包得处理大致可以分为两类：  </p>
<ol>
<li>如果处理in-sequence的包时，application正阻塞在read操作中，则接收到的数据包的数据会被直接拷贝到user buffer。  </li>
<li>否则，in-sequence包会被放在receive queue中，out-of-order包会放置于out-of-order queue中。  </li>
</ol>
<a id="more"></a>  

<p>8.1 Queuing mechanism<br>处理收到的TCP时，涉及到三个queue：backlog queue, prequeue, 和receive queue。<br>注：prequeue好像已经是一个过气的概念了。  </p>
<pre><code><span class="number">1</span>. receive queue 包含的都是处理过的包，也就是说所有的协议头都被解析完了，  
   里面的数据就等着被复制到<span class="literal">user</span> space了。  
</code></pre><p>TCP层处理数据包的第一个函数是tcp_v4_rcv()，首先从这个函数开始理解整个流程。  </p>
<pre><code>tcp_v4_rcv()  <span class="comment">// net/ipv4/tcp_ipv4.c  </span>
    =&gt; sk = __inet_lookup_skb()  <span class="comment">// 找到skb属于的sock结构体  </span>
    =&gt; <span class="keyword">if</span> (!sock_owned_by_user(sk))  <span class="comment">// sock未被加锁  </span>
        =&gt; <span class="keyword">if</span> (!tcp_prequeue(sk, skb))  <span class="comment">// 如果符合加入prequeue的原则，则加入prequeue，返回true;反之返回false  </span>
            =&gt; ret = tcp_v4_do_rcv(sk, skb)  
                =&gt; tcp_rcv_established()  <span class="comment">// receive function for the ESTABLISHED state  </span>
                    =&gt; <span class="keyword">if</span> (len == tcp_header_len)  <span class="comment">// 如果是纯ack包</span>
                        =&gt; tcp_ack(sk, skb, <span class="number">0</span>)  <span class="comment">// dealing with incoming acks  </span>
                            =&gt; flag |= tcp_clean_rtx_queue()  <span class="comment">// see if we can take anything off of the retransmit queue  </span>
                            =&gt; <span class="keyword">if</span> (tcp_ack_is_dubious(sk, flag)  <span class="comment">// 判断时候出现可疑情况，具体看下代码吧。  </span>
                                =&gt; tcp_fastretrans_alert()  <span class="comment">// 进入快速重传  </span>
                                    =&gt; tcp_cwnd_down()  <span class="comment">// decrease cwnd each second ack, 该函数就是快速重传对cwnd操作的关键函数  </span>
                                    =&gt; tcp_xmit_retransmit_queue(sk)  <span class="comment">// 在重传阶段，该函数负责找到合适的数据进行重传  </span>
                        =&gt; __kfree_skb(skb)  <span class="comment">// free an sk_buff  </span>
                        =&gt; tcp_data_snd_check(sk)  <span class="comment">// 如果有数据需要发送，则发送数据到对端  </span>
                            =&gt; tcp_push_pending_frames(sk)   <span class="comment">// 发送pending的数据</span>
                                =&gt; tcp_write_xmit()  <span class="comment">// writes packets to the network， 这部分在上一章已经分析过了   </span>
                            =&gt; tcp_check_space(sk)  <span class="comment">//  如果有内存释放，则唤醒等待内存的队列  </span>
                                <span class="comment">/* when incoming ACK allows to free some skb from write_queue,  
                                 * we remember this event in flag SOCK_QUEUE_SHRUNK and wake up socket  
                                 * on the exit from tcp input hander.
                                 *  
                                 * PROBLEM: sndbuf expansion does not work well with largesend. 
                                 */</span>
                                =&gt; tcp_new_space(sk)  
                                    =&gt; sk<span class="variable">-&gt;sk_sndbuf</span> = min(sndmem, sysctl_tcp_wmem[<span class="number">2</span>])  <span class="comment">// expand the sndbuf if possible  </span>
                    =&gt; <span class="keyword">else</span> <span class="comment">// 如果是带数据的包  </span>
                        <span class="comment">/* 此数据包刚好是下一个读取的数据，并且用户空间可存放下该数据包 */</span>
                        =&gt; <span class="keyword">if</span> (tp<span class="variable">-&gt;copied_seq</span> == tp<span class="variable">-&gt;rcv_nxt</span> &amp;&amp; len - tcp_header_len &lt;= tp<span class="variable">-&gt;ucopy</span>.len)  
                            <span class="comment">/* 如果函数在进程上下文调用并且sock被用户占用的话 */</span>
                            =&gt; <span class="keyword">if</span> (tp<span class="variable">-&gt;ucopy</span>.task == current &amp;&amp; sock_owned_by_user(sk) &amp;&amp; !copied_early)  
                                =&gt; tcp_copy_to_iovec()  <span class="comment">// 直接copy 到用户空间  </span>
                        =&gt; <span class="keyword">if</span> (!eaten)  <span class="comment">// 没有直接读到用户空间  </span>
                            <span class="comment">/* 当truesize大于sk_forward_alloc时，表示已分配的限额已经用完，不能直接放到receive queue中, 此时往往要重新计算sk_forward_alloc */</span>
                            =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;truesize</span> &gt; sk<span class="variable">-&gt;sk_forward_alloc</span>) <span class="keyword">goto</span> step5  
                            =&gt; eaten = tcp_queue_rcv()  
                                =&gt; tcp_try_coalesce()  <span class="comment">// try merge skb to prior one  </span>
                                =&gt; <span class="keyword">if</span> (!eaten) __skb_queue_tail()  <span class="comment">// 如果上一步未成功，则将skb放入receive queue中  </span>
                        =&gt; tcp_event_data_recv(sk, skb)  <span class="comment">// 数据包接收后续处理  </span>
                            <span class="comment">/* 每次收到超过128字节的数据报后，需要调用tcp_grow_window增加rcv_ssthresh的值 */</span>
                            =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;len</span> &gt;= <span class="number">128</span>) tcp_grow_window(sk, skb) 
                        =&gt; __tcp_ack_snd_check(sk, <span class="number">0</span>) <span class="comment">// check if sending an ack is needed  </span>

                    =&gt; tcp_validate_incoming(sk, skb, th, <span class="number">1</span>)  <span class="comment">// standard slow path, [details ignored]  </span>
                    =&gt; tcp_data_queue(sk, skb)  <span class="comment">// 对数据包进行处理  </span>
                        =&gt; <span class="keyword">if</span> (TCP_SKB_CB(skb)<span class="variable">-&gt;seq</span> == tp<span class="variable">-&gt;rcv_nxt</span>)   <span class="comment">// 如果是待接收的报文  </span>
                            =&gt; <span class="keyword">if</span> (tcp_receive_window(tp) == <span class="number">0</span>) <span class="keyword">goto</span> out_of_window;  <span class="comment">// 如果超出rwnd，则直接丢掉  </span>
                            =&gt; 如果正在读，且正是要读的数据，那么直接拷贝到用户空间  
                            =&gt; <span class="keyword">else</span> eaten = tcp_queue_rcv()  <span class="comment">// 将数据放入receive queue中  </span>
                            =&gt; <span class="keyword">if</span> (!skb_queue_empty(&amp;tp<span class="variable">-&gt;out_of_order_queue</span>))  <span class="comment">// 如果out of ordre queue不为空  </span>
                                =&gt; tcp_ofo_queue(sk)  <span class="comment">// This one checks to see if we can put data from the out-of-order queue into the receive-queue  </span>
                            =&gt; tcp_fast_path_check(sk)  <span class="comment">// 检查是否可以从slowpath回到fastpath  </span>

                        =&gt; <span class="keyword">else</span> tcp_data_queue_ofo(sk, skb)  <span class="comment">// 将数据包放到out-of-order queue中  </span>
                    =&gt; tcp_data_snd_check(sk)  <span class="comment">// 如果有数据需要发送，则发送数据到对端  </span>
                    =&gt; tcp_ack_snd_check(sk)  <span class="comment">// 判断是否有必要发送一个ack  </span>
</code></pre><hr>
<h4 id="prequeue的作用">prequeue的作用</h4>
<p>首先来理解两个相关的参数。    </p>
<ol>
<li><p>sysctl_tcp_low_latency == /proc/sys/net/ipv4/tcp_low_latency<br>通过man 7 tcp可以看到官方的解释  </p>
<p> tcp_low_latency (Boolean; default: disabled)  </p>
<pre><code> <span class="keyword">If</span> enabled, the  TCP  stack makes decisions that prefer lower
 latency <span class="keyword">as</span> opposed <span class="keyword">to</span> higher throughput.   It  this  <span class="keyword">option</span>  <span class="keyword">is</span>
 disabled,  <span class="keyword">then</span>  higher throughput <span class="keyword">is</span> preferred.  An example <span class="keyword">of</span>
 an application <span class="keyword">where</span> this <span class="keyword">default</span> should be changed would be  a
 Beowulf compute cluster.
</code></pre></li>
</ol>
<ol>
<li>tcp_sock-&gt;ucopy.task<br>ucopy.task != NULL 表示进程空间有进程在等待sock的数据到来  </li>
</ol>
<p>下面这句话是tcp_prequeue()的一个关键判断：是否将该skb放到prequeue中。  </p>
<pre><code><span class="keyword">if</span> (sysctl_tcp_low_latency || !tp-&gt;ucopy.task) <span class="keyword">return</span> <span class="keyword">false</span>;  
</code></pre><p>首先字面理解这行代码就是说:<br>如果更关心low latency则不用prequeue;<br>如果当前用进程在等待读数据，则不用prequeue.  </p>
<p>根据目前的理解，我认为prequeue有如下几方面的作用：  </p>
<pre><code>1. 进prequeue处理会更侧重throughput。
    由于软中断每次处理一个包，如果不进prequeue，而调用<span class="function">tcp_v4_do_rcv</span>()放进receive queue的话，  
    工作量会不少(<span class="function">tcp_rcv_established</span>()函数很复杂的)。  
    为了软中断更快的完成，放进prequeue后软中断就直接返回了，从而能更多地处理更多地收包。  
    具体处理prequeue中数据的任务交给了进程上下文(即tcp_recvmsg调用中)去处理了。   
    注：其实最终prequeue中的skb还是调用<span class="function">tcp_v4_do_rcv</span>()来处理的，所以放在prequeue中只是选择不同的处理skb的时机罢了。  
2. 进prequeue能够更快速的唤醒blocking状态的数据读请求。  
    这点很显然，进入prequeue的话，一般会立即wake up等待的进程。
</code></pre><hr>
<p>fastpath VS slowpath<br>这是一个看代码才了解到的概念，目前理解还不是太透彻，只是通过注释和代码初步知道了一些判断是否进入fast path的原则。区分这两类path的具体原因还没理解，等之后理解了再来补充吧。<br>目前的猜测可能是说满足fast path条件的话能省去许多判断的工作。暂时就简单列下tcp_rcv_established函数前面的一些注释吧：  </p>
<pre><code>The fast path <span class="keyword">is</span> disabled <span class="keyword">when</span>:  
- A zero window was announced from us - zero window probing  
  <span class="keyword">is</span> only handled properly <span class="keyword">in</span> the slow path.  
- <span class="keyword">Out</span> <span class="keyword">of</span> order segments arrived.  
- Urgent data <span class="keyword">is</span> expected.  
- There <span class="keyword">is</span> no <span class="keyword">buffer</span> space left.  
- Unexpected TCP flags/window value/header lenghts are received  
  (detected by checking the TCP header against pred_flags)  
- Data <span class="keyword">is</span> sent <span class="keyword">in</span> both directions. Fast path only supports <span class="keyword">pure</span> senders  
  <span class="keyword">or</span> <span class="keyword">pure</span> receivers (this means either the <span class="keyword">sequence</span> number <span class="keyword">or</span> the ack  
  value must stay <span class="keyword">constant</span>)  
- Unexpected TCP option.  

Fast processing <span class="keyword">is</span> turned <span class="keyword">on</span> <span class="keyword">in</span> tcp_data_queue <span class="keyword">when</span> everything <span class="keyword">is</span> OK.  
</code></pre><hr>
<h3 id="Processing_of_Queues">Processing of Queues</h3>
<p>TCP的接收队列的处理主要是在tcp_recvmsg()函数中，所以先从这个函数入手。<br>CSDN的<a href="http://blog.csdn.net/mrpre/article/details/33347221" target="_blank" rel="external">这篇博客</a>是一个不错的参考，不过一切还请以代码为准。  </p>
<pre><code>tcp_recvmsg()  <span class="regexp">//</span> <span class="keyword">this</span> routine copies from a sock struct into the user buffer<span class="function">  
    =&gt;</span> lock_sock(sk)  <span class="regexp">//</span> become a socket user<span class="function">  
    =&gt;</span> skb_queue_walk()  <span class="regexp">//</span> get a skb<span class="function">  

    =&gt;</span> 如果有skb可供拷贝<span class="function">  
        =&gt;</span> err = skb_copy_datagram_iovec()  <span class="regexp">//</span> copy data into iovec <span class="keyword">if</span> found_ok_skb  
        /* This <span class="reserved">function</span> should be called every time data <span class="keyword">is</span> copied to user space.  
         * It calculates the appropriate TCP receive buffer space.  
         */<span class="function">  
        =&gt;</span> tcp_rcv_space_adjust<span class="function"><span class="params">(sk)</span>  
            =&gt;</span> 调整至少每隔一个RTT才进行一次<span class="function">  
            =&gt;</span> space = <span class="number">2</span> * (tp-&gt;copied_seq - tp-&gt;rcvq_space.seq)  <span class="regexp">//</span> 一个RTT内，接收并复制到用户空间的数量的<span class="number">2</span>倍  
            ...<span class="function">  
            =&gt;</span> sk-&gt;sk_rcvbuf = space  <span class="regexp">//</span> 调整接收缓冲区的大小<span class="function">  
        =&gt;</span> sk_eat_skb(sk, skb, copied_early)  <span class="regexp">//</span> 如果一个skb内数据被拷贝完了，则释放掉该skb<span class="function">  

    =&gt;</span> 如果没有skb可供拷贝  
        <span class="regexp">/* 如果设置了MSG_WAITALL，target == len; 否则target == 1 */</span><span class="function">
        =&gt;</span> <span class="keyword">if</span> (copied &gt;= target &amp;&amp; !sk-&gt;sk_backlog.tail) <span class="keyword">break</span>;  <span class="regexp">//</span> 如果读够了target，且backlog queue 为空则直接<span class="keyword">return</span><span class="function">  

        =&gt;</span> tcp_cleanup_rbuf(sk, copied)  
            <span class="regexp">/* 注意区分这个函数与sk_eat_skb()  后者是清掉某个skb及其内存, 前者的主要功能是发送一个接收窗口更新的ACK--因为用户进程消费了读缓存中的数据 */</span><span class="function">
            =&gt;</span> <span class="keyword">if</span> <span class="function"><span class="params">(inet_csk_ack_scheduled(sk))</span>  // <span class="title">if</span> <span class="title">the</span> <span class="title">ack</span> <span class="title">is</span> <span class="title">scheduled</span> <span class="title">by</span> <span class="title">calling</span> <span class="title">tcp_ack_scheduled</span><span class="params">()</span>  
                =&gt;</span> <span class="keyword">if</span> delayed ACK was blocked <span class="keyword">by</span> socket lock, send an ACK<span class="function">  
                =&gt;</span> <span class="keyword">if</span> we have <span class="keyword">not</span> ACKed data <span class="keyword">of</span> length &gt; <span class="number">1</span>mss, send an ACK<span class="function">  
                =&gt;</span> <span class="keyword">if</span> we have emptied the receive buffer, <span class="keyword">and</span> there <span class="keyword">is</span> data flow only <span class="keyword">in</span> one direction, send an ACK<span class="function">  
            =&gt;</span> rcv_window_now = tcp_receive_window(tp)  <span class="regexp">//</span> 计算当前的应该通知对方的receive <span class="built_in">window</span><span class="function">
                =&gt;</span> win = tp-&gt;rcv_wup + tp-&gt;rcv_wnd - tp-&gt;rcv_nxt  <span class="regexp">//</span> 左边界 + 当前receive_window - 已用<span class="function">  
            =&gt;</span> new_window = __tcp_select_window(sk)  <span class="regexp">//</span> 计算新的接收窗口大小, 约为rcvbuf空闲部分的一半<span class="function">  
            =&gt;</span> <span class="keyword">if</span> (new_window &amp;&amp; new_window &gt;= <span class="number">2</span> * rcv_window_now)  send an ACK<span class="function">  

            =&gt;</span> <span class="keyword">if</span> (time_to_ack) tcp_send_ack(sk)   <span class="regexp">//</span> 如果上面有需要发送ack的需求，则发送一个ACK  
        /* <span class="keyword">if</span> prequeue <span class="keyword">is</span> <span class="keyword">not</span> empty, we have to process it before releasing socket  
         * queue的处理优先级如下：  
         * receive queue 最高
         * prequeue queue 次之
         * backlog queue 最低
         */<span class="function">  
        =&gt;</span> <span class="keyword">if</span> prequeue <span class="keyword">is</span> <span class="keyword">not</span> empty, goto do_prequeue<span class="function">
            =&gt;</span> tcp_prequeue_process<span class="function"><span class="params">(sk)</span>  
                =&gt;</span> sk_backlog_rcv<span class="function"><span class="params">(sk, skb)</span>  == <span class="title">tcp_v4_do_rcv</span><span class="params">()</span>  

        =&gt;</span> <span class="keyword">if</span> (copied &gt;= target)   <span class="regexp">//</span> 下面两个步骤主要就是为了处理backlog queue<span class="function">  
            =&gt;</span> release_sock<span class="function"><span class="params">(sk)</span>  
                =&gt;</span> <span class="keyword">if</span> <span class="function"><span class="params">(sk-&gt;sk_backlog.tail)</span>   
                    =&gt;</span> __release_sock<span class="function"><span class="params">(sk)</span>  
                        =&gt;</span> sk_backlog_rcv<span class="function"><span class="params">(sk, skb)</span>  == <span class="title">tcp_v4_do_rcv</span><span class="params">()</span>  
            =&gt;</span> lock_sock<span class="function"><span class="params">(sk)</span> 
        =&gt;</span> <span class="keyword">else</span><span class="function">  
            =&gt;</span> sk_wait_data(sk, &amp;timeo)  <span class="regexp">//</span> 睡眠等待新数据的到来  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>这章主要是TCP接收包得处理流程。<br>kernel对于TCP包得处理大致可以分为两类：  </p>
<ol>
<li>如果处理in-sequence的包时，application正阻塞在read操作中，则接收到的数据包的数据会被直接拷贝到user buffer。  </li>
<li>否则，in-sequence包会被放在receive queue中，out-of-order包会放置于out-of-order queue中。  </li>
</ol>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP ADI in Linux(7): TCP send]]></title>
    <link href="http://perthcharles.github.com/2014/11/19/tcp-design-and-implementation-7/"/>
    <id>http://perthcharles.github.com/2014/11/19/tcp-design-and-implementation-7/</id>
    <published>2014-11-19T11:30:22.000Z</published>
    <updated>2015-05-10T05:05:08.000Z</updated>
    <content type="html"><![CDATA[<p>这种重点描述从应用层下发的数据，是在TCP中如何被管理以及被传输的。主要会涉及到MTU，各类TCP层的算法（如Nagle）以及核心的拥塞控制算法和flow control算法（滑动窗口机制）。<br>另外需要注意的是，这块我看的内核3.10与书中的内核版本实现存在较大不同，看代码的时候需要引起注意。  </p>
<a id="more"></a>  

<p>7.1 TCP segmentation unit for sending data<br>当应用层调用send发送数据后，内核中对应的函数就是tcp_sendmsg()。因此我们从这个函数切入来理解TCP的发送流程。  </p>
<pre><code>SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len, unsigned int, flags) // net/socket.c  
=<span class="ruby">&gt; sys_sendto(fd, buff, len, flags, <span class="constant">NULL</span>, <span class="number">0</span>)  /<span class="regexp">/ send a datagram to a given address, net/socket</span>.c line <span class="number">1754</span>  
</span>    =<span class="ruby">&gt; sock = sockfd_lookup_light()  /<span class="regexp">/ 通过fd找到sock  
</span></span>    =<span class="ruby">&gt; err = sock_sendmsg(sock, &amp;msg, len)  
</span>        =<span class="ruby">&gt; sock-&gt;ops-&gt;sendmsg()  == tcp_sendmsg()
</span>
tcp_sendmsg()  
    =<span class="ruby">&gt; mss_now = tcp_send_mss()  /<span class="regexp">/ 获得current mss
</span></span>    =<span class="ruby">&gt; sg = !!(sk-&gt;sk_route_caps * <span class="constant">NETIF_F_SG</span>)  /<span class="regexp">/ 检查硬件是否支持scatter-gather
</span></span>    =<span class="ruby">&gt; 两个循环，第一层遍历所有的buffer块，第二层遍历某一个buffer的所有数据  
</span><span class="comment">        /* 获取sk-&gt;sk_write_queue的最后一个skb，用于检查是否用满。</span>
         * 用满了就新建一个skb放新数据，否则将新数据拼接到这最后一个skb中   
         */
        =<span class="ruby">&gt; skb = tcp_write_queue_tail(sk)  
</span>        =<span class="ruby">&gt; <span class="keyword">if</span> (copy &lt;= <span class="number">0</span>) /<span class="regexp">/ 需要new a segment
</span></span>            =<span class="ruby">&gt; sk_stream_memory_free(sk)  /<span class="regexp">/ 检查send buffer的配额是否超过上限, 超过了要跳转到wait_for_sndbuf  
</span></span>                =<span class="ruby">&gt; <span class="keyword">return</span> sk-&gt;sk_wmem_queued &lt; sk-&gt;sk_sndbuf  
</span>            =<span class="ruby">&gt; skb = sk_stream_alloc_skb() /<span class="regexp">/ 为新数据新分配一个skb  
</span></span>            =<span class="ruby">&gt; skb_entail(sk, skb)    /<span class="regexp">/ 将新生成的skb挂到sk-&gt;sk_write_queue的尾部  
</span></span>        =<span class="ruby">&gt; skb_can_coalesce()  /<span class="regexp">/ 判断最后一页能否合并更多数据  
</span></span>
        =<span class="ruby">&gt; forced_push(tp) /<span class="regexp">/ 解释见接下来的note
</span></span>        =<span class="ruby">&gt; tcp_mark_push(tp, skb)  /<span class="regexp">/ 解释见接下来的note
</span></span><span class="comment">        /* push out any pending frames which were held back due to TCP_CORK </span>
         * or attempt at coalescing tiny packets 
         */
        =<span class="ruby">&gt; __tcp_push_pending_frame()  /<span class="regexp">/ 如果是设置了PSH flag，会调用该函数尽快的将数据发送出去  
</span></span>
        =<span class="ruby">&gt; <span class="keyword">if</span> (copied) tcp_push()  /<span class="regexp">/发送数据
</span></span>            =<span class="ruby">&gt; check sk-&gt;sk_send_head is <span class="constant">NULL</span> <span class="keyword">or</span> <span class="keyword">not</span> /<span class="regexp">/ 不为空表示有数据待发送  
</span></span>            =<span class="ruby">&gt; __tcp_push_pending_frames()  /<span class="regexp">/ 大部分数据应该是走这条流程被发送出去的  
</span></span>                =<span class="ruby">&gt; tcp_write_xmit()  /<span class="regexp">/ this rountine write packets to the network  
</span></span><span class="comment">                    /* 只要有数据pending在write queue里面就继续发送，</span>
                     * 当然循环内部有各种条件判断是否应该终止循环  
                     */
                    =<span class="ruby">&gt; <span class="keyword">while</span> (skb = tcp_send_head(sk))  
</span>                        =<span class="ruby">&gt; cwnd_quota = tcp_cwnd_test(tp, skb)  /<span class="regexp">/ 根据cwnd与packet in flight的差得到配额  
</span></span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(!tcp_snd_wnd_test(tp, skb, mss_now)) <span class="keyword">break</span>;  <span class="regexp">//</span> 判断是否受限于rwnd  
</span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(!tcp_nagle_test()) <span class="keyword">break</span>;  <span class="regexp">//</span> <span class="keyword">return</span> <span class="keyword">true</span> <span class="keyword">if</span> allow by <span class="constant">Nagle</span>
</span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (unlikely(tcp_transmit_skb(sk, skb, <span class="number">1</span>, gfp)) <span class="keyword">break</span>;  <span class="regexp">//</span> 发送一个skb，不成功则<span class="keyword">break</span>。参数<span class="number">1</span>表示传递一份clone  
</span>                            =<span class="ruby">&gt; 细节见后续章节    
</span>                        =<span class="ruby">&gt; tcp_event_new_data_sent(sk, skb)  /<span class="regexp">/ 更新sk-&gt;sk_send_head，tp-&gt;snd_nxt, tp-&gt;packet_out等  
</span></span>                        =<span class="ruby">&gt; <span class="keyword">if</span> (push_one) <span class="keyword">break</span>;  <span class="regexp">//</span> 如果之前只允许发送一个，则<span class="keyword">break</span>  
</span>


tcp_mark_push()为sk_buff设置PSH flag。当满足下面某一个条件时，PSH会被设置：  
    1. we have written more than half of the so far maximum window size from the last byte marked as pushed  
    2. we have one full-sized TCP segment ready for transmission.  

forced_push()就是用来判断上面条件一是否成立的  
</code></pre><h4 id="tcp_transmit_skb">tcp_transmit_skb</h4>
<p>源代码函数上方的几句注释摘录一下，应该基本知道该函数的功能了。  </p>
<pre><code>This routine actually transmits TCP packets queued <span class="keyword">in</span> <span class="keyword">by</span> tcp_do_sendmsg().  
This <span class="keyword">is</span> used <span class="keyword">by</span> both the initial transmission <span class="keyword">and</span> possible later retransmissions.  
All SKB<span class="comment">'s seen here are completely headerless.  </span>
</code></pre><p>话多不说，直接读代码  </p>
<pre><code>tcp_transmit_skb()  
    =&gt; skb = skb_clone(skb, gfp_mask)  <span class="comment">// 复制一份skb，新的skb不属于任何一个socket  </span>
    =&gt; <span class="keyword">if</span> (tcp_packets_in_flight(tp) == <span class="number">0</span>) tcp_ca_event(sk, CA_EVENT_TX_START);  <span class="comment">// 根据packet inflight判断传输的开始  </span>
    =&gt; skb_push(skb, tcp_head_size)  <span class="comment">// 根据计算得到的TCP header长度调整skb  </span>
    =&gt; th = tcp_hdr(skb)  <span class="comment">// 获得TCP header对应位置，并开始构建TCP header</span>
    =&gt; tcp_options_write()  <span class="comment">// write previously computed TCP options to the packet</span>
    =&gt; icsk<span class="variable">-&gt;icsk_af_ops</span><span class="variable">-&gt;send_check</span>(sk, skb) == tcp_v4_send_check()  <span class="comment">// compute an IPv4 TCP checksum  </span>
    =&gt; <span class="keyword">if</span> (skb<span class="variable">-&gt;len</span> != tcp_header_size) tcp_event_data_send(tp, sk)  <span class="comment">// congestion state accounting after a packet has been sent  </span>
    =&gt; err = icsk<span class="variable">-&gt;icsk_af_ops</span><span class="variable">-&gt;queue_xmit</span>()   ==  ip_queue_xmit() <span class="comment">// 目前不关心ip层及以下的实现  </span>
</code></pre><h3 id="TODO">TODO</h3>
<p>sock结构体中有一个sk_forward_alloc，需要理解一下这个变量  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>这种重点描述从应用层下发的数据，是在TCP中如何被管理以及被传输的。主要会涉及到MTU，各类TCP层的算法（如Nagle）以及核心的拥塞控制算法和flow control算法（滑动窗口机制）。<br>另外需要注意的是，这块我看的内核3.10与书中的内核版本实现存在较大不同，看代码的时候需要引起注意。  </p>
]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="读书笔记" scheme="http://perthcharles.github.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
