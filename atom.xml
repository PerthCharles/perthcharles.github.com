<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天赋  无与伦比的坚持]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://perthcharles.github.com/"/>
  <updated>2015-09-14T13:25:24.403Z</updated>
  <id>http://perthcharles.github.com/</id>
  
  <author>
    <name><![CDATA[Perth Charles]]></name>
    <email><![CDATA[zhongbincharles@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用ip命令修改初始拥塞窗口和接收窗口]]></title>
    <link href="http://perthcharles.github.com/2015/09/14/ip-route-initcwnd/"/>
    <id>http://perthcharles.github.com/2015/09/14/ip-route-initcwnd/</id>
    <published>2015-09-14T10:14:04.000Z</published>
    <updated>2015-09-14T13:25:18.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在不修改内核的情况下，Linux提供了一种使用ip命令修改初始拥塞窗口和接收窗口的机制。<br>具体的例子可看<a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">这篇文章</a><br><a id="more"></a>  </p>
<hr>
<h3 id="修改初始拥塞窗口">修改初始拥塞窗口</h3>
<p>使用如下命令可修改init cwnd  </p>
<pre><code>sudo ip route change <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> dev eth0  proto <span class="keyword">static</span> initcwnd <span class="number">10</span>
</code></pre><p>内核源码分析  </p>
<pre><code><span class="comment">// 初始化cwnd的函数，会判断是否设置了route来指定initcwnd  </span>
<span class="number">__u32</span> tcp_init_cwnd(<span class="keyword">const</span> <span class="keyword">struct</span> tcp_sock *tp, <span class="keyword">const</span> <span class="keyword">struct</span> dst_entry *dst)
{
    <span class="number">__u32</span> cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : <span class="number">0</span>);

    <span class="keyword">if</span> (!cwnd)
        cwnd = TCP_INIT_CWND;
    <span class="keyword">return</span> min_t(<span class="number">__u32</span>, cwnd, tp-&gt;snd_cwnd_clamp);
}

<span class="comment">// 内核中一个典型的调用序列  </span>
tcp_finish_connect()
    =&gt; tcp_init_metrics()
        =&gt; tp-&gt;snd_cwnd = tcp_init_cwnd(tp, dst);
</code></pre><hr>
<h3 id="修改初始接收窗口">修改初始接收窗口</h3>
<p>使用如下命令可修改init rwnd  </p>
<pre><code>sudo ip route change <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> dev eth0  proto <span class="keyword">static</span> initrwnd <span class="number">10</span>
</code></pre><p>内核源码分析<br>    // 内核中一个典型的调用<br>    tcp_connect_init()<br>        =&gt; tcp_select_inital_window()<br>            =&gt; dst_metric(dst, RTAX_INITRWND)</p>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">Tuning initcwnd for optimum performance</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在不修改内核的情况下，Linux提供了一种使用ip命令修改初始拥塞窗口和接收窗口的机制。<br>具体的例子可看<a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">这篇文章</a><br>]]>
    
    </summary>
    
      <category term="ip" scheme="http://perthcharles.github.com/tags/ip/"/>
    
      <category term="tool" scheme="http://perthcharles.github.com/tags/tool/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊重传次数]]></title>
    <link href="http://perthcharles.github.com/2015/09/07/wiki-tcp-retries/"/>
    <id>http://perthcharles.github.com/2015/09/07/wiki-tcp-retries/</id>
    <published>2015-09-07T13:40:02.000Z</published>
    <updated>2015-09-08T05:28:05.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在<a href="http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/" target="_blank" rel="external">RTO的计算方法</a>中，介绍了RFC6298对于RTO的计算和RTO timer的管理算法。<br>但有一个重要的问题RFC没有提到，那就是如果出现了超时重传，那重传多少次可以放弃呢？<br>当然这是一个实现相关的细节，不同的操作系统可能有不同的实现策略。<br>在这篇wiki中，就来介绍一下Linux中是怎么限制超时重传次数的。<br><a id="more"></a>  </p>
<hr>
<h3 id="听说Linux有两个参数限制超时重传次数">听说Linux有两个参数限制超时重传次数</h3>
<p>没错，Linux中确实定义了两个参数来限定超时重传的次数的，以下是源码中Documentation/networking/ip-sysctl.txt文档中的描述  </p>
<pre><code>tcp_retries1 - INTEGER
    This <span class="built_in">value</span> influences <span class="operator">the</span> <span class="built_in">time</span>, <span class="keyword">after</span> which TCP decides, that
    something is wrong due <span class="built_in">to</span> unacknowledged RTO retransmissions,
    <span class="operator">and</span> reports this suspicion <span class="built_in">to</span> <span class="operator">the</span> network layer.
    See tcp_retries2 <span class="keyword">for</span> more details.

    RFC <span class="number">1122</span> recommends <span class="keyword">at</span> least <span class="number">3</span> retransmissions, which is <span class="operator">the</span>
    default.

tcp_retries2 - INTEGER
    This <span class="built_in">value</span> influences <span class="operator">the</span> timeout <span class="operator">of</span> <span class="operator">an</span> alive TCP connection,
    when RTO retransmissions remain unacknowledged.
    Given <span class="operator">a</span> <span class="built_in">value</span> <span class="operator">of</span> N, <span class="operator">a</span> hypothetical TCP connection following
    exponential backoff <span class="operator">with</span> <span class="operator">an</span> initial RTO <span class="operator">of</span> TCP_RTO_MIN would
    retransmit N times <span class="keyword">before</span> killing <span class="operator">the</span> connection <span class="keyword">at</span> <span class="operator">the</span> (N+<span class="number">1</span>)th RTO.

    The default <span class="built_in">value</span> <span class="operator">of</span> <span class="number">15</span> yields <span class="operator">a</span> hypothetical timeout <span class="operator">of</span> <span class="number">924.6</span>
    <span class="built_in">seconds</span> <span class="operator">and</span> is <span class="operator">a</span> <span class="built_in">lower</span> bound <span class="keyword">for</span> <span class="operator">the</span> <span class="keyword">effective</span> timeout.
    TCP will effectively <span class="built_in">time</span> out <span class="keyword">at</span> <span class="operator">the</span> <span class="keyword">first</span> RTO which exceeds <span class="operator">the</span>
    hypothetical timeout.

    RFC <span class="number">1122</span> recommends <span class="keyword">at</span> least <span class="number">100</span> <span class="built_in">seconds</span> <span class="keyword">for</span> <span class="operator">the</span> timeout,
    which corresponds <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">8.</span>
</code></pre><p>就是这样一段话，可能由于过于概括，会令人产生很多疑问，甚至产生一些误解。<br>比如常见的问题有：<br>a. 超过tcp_retries1这个阈值后，到底是report了怎样一种suspicion呢？<br>b. tcp_retries1和tcp_retries2的数字是表示RTO重传的次数上限，对吗？<br>c. 文档中提到，924.6s is a lower bound for the effective timeout。<br>这里的effective timeout是指什么？<br>为什么是lower bound，tcp_retries2不应该是限制重传次数的upper bound吗？  </p>
<p>下面就结合Linux 3.10的源码来逐个解释一下以上几个问题。并在最后给出一个总结。  </p>
<hr>
<h3 id="重传超过tcp_retries1会怎样">重传超过tcp_retries1会怎样</h3>
<p>文档中说的suspicion到底是什么呢？来看一下tcp_retries1相关的代码部分  </p>
<pre><code>// RTO timer的处理函数是tcp_retransmit_timer()，与tcp_retries1相关的代码调用关系如下  
tcp_retransmit_timer()
    =&gt; tcp_write_timeout()  // 判断是否重传了足够的久
        =&gt; retransmit_timed_out(sk, sysctl_tcp_retries1, <span class="number">0</span>, <span class="number">0</span>)  // 判断是否超过了阈值

// tcp_write_timeout()的具体相关内容  
<span class="keyword">...</span>
<span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
    // 如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数
    <span class="keyword">...</span>
} <span class="keyword">else</span> {    // 如果超时发生在数据发送期间
    // 这个函数负责判断重传是否超过阈值，返回真表示超过。后续会详细分析这个函数  
    <span class="keyword">if</span> (retransmits_timed_out(sk, sysctl_tcp_retries1, <span class="number">0</span>, <span class="number">0</span>)) { 
        /* Black hole detection */
        tcp_mtu_probing(icsk, sk);  // 如果开启tcp_mtu_probing(默认关闭)了，则执行PMTU

        dst_negative_advice(sk);    // 更新路由缓存
    }
    <span class="keyword">...</span>
}
</code></pre><p>从以上的代码可以看到，一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存。<br>用以避免由于路由选路变化带来的问题。  </p>
<hr>
<h3 id="重传超过tcp_retries2会怎样">重传超过tcp_retries2会怎样</h3>
<p>会直接放弃重传，关闭TCP流  </p>
<pre><code>// 依然还是在tcp_write_timeout()中，retry_until一般是tcp_retries2
<span class="keyword">...</span>
<span class="keyword">if</span> (retransmits_timed_out(sk, retry_until, syn_set ? <span class="number">0</span> : icsk-&gt;icsk_user_timeout, syn_set)) {
    /* Has it gone just too far? */
    tcp_write_err(sk);      // 调用tcp_done关闭TCP流
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><hr>
<h3 id="retries限制的重传次数吗">retries限制的重传次数吗</h3>
<p>咋一看文档，很容易想到retries的数字就是限定的重传的次数，甚至源码中对于retries常量注释中都写着”This is how many retries it does…”  </p>
<pre><code><span class="comment">#define TCP_RETR1       3   /*</span>
                             * This is how many retries <span class="keyword">it</span> does <span class="keyword">before</span> <span class="keyword">it</span>
                             * tries <span class="built_in">to</span> figure out <span class="keyword">if</span> <span class="operator">the</span> gateway is
                             * down. Minimal RFC <span class="built_in">value</span> is <span class="number">3</span>; <span class="keyword">it</span> corresponds
                             * <span class="built_in">to</span> ~<span class="number">3</span><span class="built_in">sec</span>-<span class="number">8</span><span class="built_in">min</span> depending <span class="command"><span class="keyword">on</span> <span class="title">RTO</span>.</span>
                             */

<span class="comment">#define TCP_RETR2       15  /*</span>
                             * This should take <span class="keyword">at</span> least
                             * <span class="number">90</span> minutes <span class="built_in">to</span> <span class="built_in">time</span> out.
                             * RFC1122 says that <span class="operator">the</span> limit is <span class="number">100</span> <span class="built_in">sec</span>.
                             * <span class="number">15</span> is ~<span class="number">13</span>-<span class="number">30</span><span class="built_in">min</span> depending <span class="command"><span class="keyword">on</span> <span class="title">RTO</span>.</span>
                             */
</code></pre><p>那就就来看看retransmits_timed_out的具体实现，看看到底是不是限制的重传次数  </p>
<pre><code>/* This <span class="reserved">function</span> calculates a <span class="string">"timeout"</span> which <span class="keyword">is</span> equivalent to the timeout <span class="keyword">of</span> a
 * TCP connection after <span class="string">"boundary"</span> unsuccessful, exponentially backed-<span class="literal">off</span>
 * retransmissions <span class="reserved">with</span> an initial RTO <span class="keyword">of</span> TCP_RTO_MIN <span class="keyword">or</span> TCP_TIMEOUT_INIT <span class="keyword">if</span>
 * syn_set flag <span class="keyword">is</span> set.
 */
static bool retransmits_timed_out(struct sock *sk,
                              unsigned int boundary,
                              unsigned int timeout,
                              bool syn_set)
{
    unsigned int linear_backoff_thresh, start_ts;
    <span class="regexp">//</span> 如果是在三次握手阶段，syn_set为真
    unsigned int rto_base = syn_set ? TCP_TIMEOUT_INIT : TCP_RTO_MIN;

    <span class="keyword">if</span> <span class="function"><span class="params">(!inet_csk(sk)-&gt;icsk_retransmits)</span>
            <span class="title">return</span> <span class="title">false</span>;

    // <span class="title">retrans_stamp</span>记录的是数据包第一次发送的时间，在<span class="title">tcp_retransmit_skb</span><span class="params">()</span>中设置
    <span class="title">if</span> <span class="params">(unlikely(!tcp_sk(sk)-&gt;retrans_stamp))</span>
            <span class="title">start_ts</span> = <span class="title">TCP_SKB_CB</span><span class="params">(tcp_write_queue_head(sk))</span>-&gt;</span><span class="keyword">when</span>;
    <span class="keyword">else</span>
            start_ts = tcp_sk<span class="function"><span class="params">(sk)</span>-&gt;</span>retrans_stamp;

    <span class="regexp">//</span> 如果用户态未指定timeout，则算一个出来
    <span class="keyword">if</span> (likely(timeout == <span class="number">0</span>)) {
            /* 下面的计算过程，其实就是算一下如果以rto_base为第一次重传间隔，
             * 重传boundary次需要多长时间
             */
            linear_backoff_thresh = ilog2(TCP_RTO_MAX/rto_base);

            <span class="keyword">if</span> (boundary &lt;= linear_backoff_thresh)
                    timeout = ((<span class="number">2</span> &lt;&lt; boundary) - <span class="number">1</span>) * rto_base;
            <span class="keyword">else</span>
                    timeout = ((<span class="number">2</span> &lt;&lt; linear_backoff_thresh) - <span class="number">1</span>) * rto_base +
                            (boundary - linear_backoff_thresh) * TCP_RTO_MAX;
    }
    <span class="regexp">//</span> 如果数据包第一次发送的时间距离现在的时间间隔，超过了timeout值，则认为重传超于阈值了
    <span class="keyword">return</span> (tcp_time_stamp - start_ts) &gt;= timeout;
}
</code></pre><p>从以上的代码分析可以看到，真正起到限制重传次数的并不是真正的重传次数。<br>而是以tcp_retries1或tcp_retries2为boundary，以rto_base(如TCP_RTO_MIN 200ms)为初始RTO，计算得到一个timeout值出来。如果重传间隔超过这个timeout，则认为超过了阈值。<br>上面这段话太绕了，下面举两个个例子来说明  </p>
<pre><code>以判断是否放弃TCP流为例，如果<span class="variable">tcp_retries2=</span><span class="number">15</span>，那么计算得到的<span class="variable">timeout=</span><span class="number">924600</span>ms。

<span class="number">1</span>. 如果RTT比较小，那么RTO初始值就约等于下限<span class="number">200</span>ms
   由于timeout总时长是<span class="number">924600</span>ms，表现出来的现象刚好就是重传了<span class="number">15</span>次，超过了timeout值，从而放弃TCP流

<span class="number">2</span>. 如果RTT较大，比如RTO初始值计算得到的是<span class="number">1000</span>ms
   那么根本不需要重传<span class="number">15</span>次，重传总间隔就会超过<span class="number">924600</span>ms。
   比如我测试的一个<span class="variable">RTT=</span><span class="number">400</span>ms的情况，当<span class="variable">tcp_retries2=</span><span class="number">10</span>时，仅重传了<span class="number">3</span>次就放弃了TCP流
</code></pre><hr>
<h3 id="另外几个小问题">另外几个小问题</h3>
<p>理解了Linux决定重传次数的真实机制，就不难回答一下几个问题了  </p>
<pre><code><span class="input"><span class="prompt">&gt;&gt;</span> effective timeout指的是什么？  </span>
<span class="input"><span class="prompt">&lt;&lt; 就是retransmits_timed_out计算得到的timeout值

&gt;&gt;</span> <span class="number">924.6</span>s是怎么算出来的？</span>
&lt;&lt; <span class="number">924.6</span>s = (( <span class="number">2</span> &lt;&lt; <span class="number">9</span>) -<span class="number">1</span>) * <span class="number">200</span>ms + (<span class="number">15</span> - <span class="number">9</span>) * <span class="number">120</span>s
<span class="input"><span class="prompt">
&gt;&gt;</span> 为什么<span class="number">924.6</span>s是lower bound？</span>
&lt;&lt; 重传总间隔必须大于timeout值，即 (tcp_time_stamp - start_ts) &gt;= timeout
<span class="input"><span class="prompt">
&gt;&gt;</span> 那<span class="constant">RTO</span>超时的间隔到底是不是源码注释的<span class="string">"15 is ~13-30min depending on RTO."</span>呢？  </span>
&lt;&lt; 显然不是! 虽然<span class="number">924.6</span>s(<span class="number">15</span>min)是一个lower bound，但是它同时也是一个upper bound!
   怎么理解？举例说明  
        <span class="number">1</span>. 如果某个<span class="constant">RTO</span>值导致，在已经重传了<span class="number">14</span>次后，总重传间隔开销是<span class="number">924</span>s
        那么它还需要重传第<span class="number">15</span>次，即使离<span class="number">924.6</span>s只差<span class="number">0</span>.<span class="number">6</span>s。这就是发挥了lower bound的作用
        <span class="number">2</span>. 如果某个<span class="constant">RTO</span>值导致，在重传了<span class="number">10</span>次后，总重传间隔开销是<span class="number">924</span>s
        重传第<span class="number">11</span>次后，第<span class="number">12</span>次超时触发时计算得到的总间隔变为<span class="number">1044</span>s，超过<span class="number">924.6</span>s
        那么此时会放弃第<span class="number">12</span>次重传，这就是<span class="number">924.6</span>s发挥了upper bound的作用
   总的来说，在<span class="constant">Linux3</span>.<span class="number">10</span>中，如果tcp_retres2设置为<span class="number">15</span>。总重传超时周期应该在如下范围内
        [<span class="number">924.6</span>s, <span class="number">1044.6</span>s)
</code></pre><p>所以综合上述，Linux并不是直接拿tcp_retries1和tcp_retries2来限制重传次数的，而是用计算得到<br>的一个timeout值来判断是否要放弃重传的。真正的重传次数同时与RTT相关。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在<a href="http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/" target="_blank" rel="external">RTO的计算方法</a>中，介绍了RFC6298对于RTO的计算和RTO timer的管理算法。<br>但有一个重要的问题RFC没有提到，那就是如果出现了超时重传，那重传多少次可以放弃呢？<br>当然这是一个实现相关的细节，不同的操作系统可能有不同的实现策略。<br>在这篇wiki中，就来介绍一下Linux中是怎么限制超时重传次数的。<br>]]>
    
    </summary>
    
      <category term="rto" scheme="http://perthcharles.github.com/tags/rto/"/>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RTO的计算方法(基于RFC6298和Linux 3.10)]]></title>
    <link href="http://perthcharles.github.com/2015/09/06/wiki-rtt-estimator/"/>
    <id>http://perthcharles.github.com/2015/09/06/wiki-rtt-estimator/</id>
    <published>2015-09-06T04:51:17.000Z</published>
    <updated>2015-09-06T10:03:58.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>RTO的准确计算对于TCP的可靠性传输和性能都具有重要作用。<br>这篇文章首先介绍最新的RFC中对于RTO的计算方法，然后结合Linux 3.10的源码对<br>具体的实现进行分析和理解。  </p>
<a id="more"></a>  

<hr>
<h3 id="RTO计算算法">RTO计算算法</h3>
<pre><code><span class="number">1.1</span>. 在没有任何rtt sample的时候，RTO &lt;- TCP_TIMEOUT_INIT (<span class="number">1</span>s)
   多次重传时同样适用指数回避算法(backoff)增加RTO  

<span class="number">1.2</span>. 获得第一个RTT sample后，
    SRTT &lt;- RTT
    RTTVAR &lt;- RTT/<span class="number">2</span>
    RTO &lt;- SRTT + max(G, K * RTTVAR)
其中K=<span class="number">4</span>, G表示timestamp的粒度(在CONFIG_HZ=<span class="number">1000</span>时，粒度为<span class="number">1</span>ms)

<span class="number">1.3</span>. 后续获得更多RTT sample后，
    RTTVAR &lt;- (<span class="number">1</span> - beta) * RTTVAR + beta * |SRTT - R|
    SRTT &lt;- (<span class="number">1</span> - alpha) * SRTT + alpha * R
其中beta = <span class="number">1</span>/<span class="number">4</span>, alpha = <span class="number">1</span>/<span class="number">8</span>

<span class="number">1.4</span>. Whenever RTO <span class="keyword">is</span> computed, <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">less than</span> <span class="number">1</span> <span class="keyword">second</span>, <span class="keyword">then</span> <span class="keyword">the</span>
   RTO SHOULD be rounder up <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">second</span>.

<span class="number">1.5</span>. A maximum value MAY be placed <span class="function_start"><span class="keyword">on</span></span> RTO provided <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">at</span> least <span class="number">60</span> seconds.
</code></pre><p>RTTVAR表示的是平滑过的平均偏差，SRTT表示的平滑过的RTT。这两个值的具体含义会在后面介绍<br>具体实现的时候进一步的解释。<br>以上是计算一个初始RTO值的过程，当连续出现RTO超时后，<br>RTO值会用一个叫做指数回避的策略进行调整，下面来具体介绍。  </p>
<hr>
<h3 id="RTO_timer的管理">RTO timer的管理</h3>
<pre><code><span class="number">2.1</span>. 发送一个带有数据的包后，如果RTO <span class="built_in">timer</span>未启动，启动RTO <span class="built_in">timer</span>  

<span class="number">2.2</span>. 当所有发送的数据都被确认后，关闭RTO <span class="built_in">timer</span>

<span class="number">2.3</span>. 当收到一个ACK确认了新数据后，重新设置RTO时间为当前RTO值

如果RTO超时了
<span class="number">2.4</span>. 重传最早的一个未被确认的数据包(序号最小的，即tp-&gt;snd_una)

<span class="number">2.5</span>. RTO &lt;- RTO * <span class="number">2</span> (<span class="string">"back off the timer"</span>，即指数回避策略)

<span class="number">2.6</span>. 重现设定RTO时间为当前RTO值

<span class="number">2.7</span>. 如果是在等待SYN包的ACK时RTO超时的，在连接建立之后，会将RTO从TCP_TIMEOUT_INIT
   改为TCP_TIMEOUT_FALLBACK(<span class="number">3</span>s)
   就是如果syn包被重传过，则上一节第一步中的RTO则会从<span class="number">1</span>s被重设为<span class="number">3</span>s。
</code></pre><hr>
<h3 id="RFC6298中的其他要点">RFC6298中的其他要点</h3>
<pre><code>Note that <span class="operator">a</span> TCP implementation MAY <span class="built_in">clear</span> SRTT <span class="operator">and</span> RTTVAR <span class="keyword">after</span>
backing off <span class="operator">the</span> timer multiple times <span class="keyword">as</span> <span class="keyword">it</span> is likely that <span class="operator">the</span> current
SRTT <span class="operator">and</span> RTTVAR are bogus <span class="operator">in</span> this situation.  Once SRTT <span class="operator">and</span> RTTVAR
are cleared, they should be initialized <span class="operator">with</span> <span class="operator">the</span> next RTT sample
taken per (<span class="number">1.2</span>) rather than <span class="keyword">using</span> (<span class="number">1.3</span>). 

<span class="number">1.1</span>和<span class="number">2.7</span>是RFC6298与RFC2988的主要不同，RFC6298在Appendix A中详细解释了为什么将INIT_RTO从
<span class="number">3</span>s降到<span class="number">1</span>s。里面有一些dataset的测试数据证明，有兴趣的话可以看一看。  
</code></pre><hr>
<h3 id="Linux实现之RTO计算">Linux实现之RTO计算</h3>
<p>以下开始分析Linux 3.10关于RTO的具体实现，序号与RFC原理中的需要一一对应。<br>首先是RTO计算相关的部分。<br>在理解这部分代码之前，有几个关键变量需要解释一下。<br>tp-&gt;srtt实际上存的是8<em>SRTT，而tp-&gt;rttvar实际上存储的是4</em>RTTVAR。<br>所以在后续代码注释中，也会使用大小写加以区分。使用大写时与RFC定义的变量含义一致。  </p>
<pre><code><span class="number">1.1</span><span class="built_in">.</span> 对应在net/ipv4/tcp<span class="built_in">.</span>c line372 tcp_init_sock()
    <span class="attribute">...</span>
    tcp_init_xmit_timers(sk);       <span class="comment">// 初始化tcp中timer对应的处理函数</span>
    <span class="attribute">...</span>
    icsk<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> TCP_TIMEOUT_INIT;  <span class="comment">// 初始RTO设为1s</span>
    tp<span class="subst">-&gt;</span>mdev <span class="subst">=</span> TCP_TIMEOUT_INIT;        <span class="comment">// 初始medium deviation为1s</span>
    <span class="attribute">...</span>

<span class="number">1.2</span><span class="built_in">.</span> 对应net/ipv4/tcp_input<span class="built_in">.</span>c line639 tcp_rtt_estimator()
    <span class="attribute">...</span>
    <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">!=</span> <span class="number">0</span>) {
        <span class="attribute">...</span>
    } <span class="keyword">else</span> {    <span class="comment">// 第一次获取RTT sample</span>
        tp<span class="subst">-&gt;</span>srtt <span class="subst">=</span> m <span class="subst">&lt;&lt;</span> <span class="number">3</span>;  <span class="comment">// SRTT = RTT, 需要注意的是tp-&gt;srtt存的是8*SRTT</span>

        <span class="comment">/* RTTVAR = RTT/2, 需要注意的是tp-&gt;rttvar存的是4*RTTVAR
         * tcp_rto_min(sk)限制了rttvar的最小值为TCP_RTO_MIN(HZ/5)=200ms */</span>
        tp<span class="subst">-&gt;</span>mdev <span class="subst">=</span> m <span class="subst">&lt;&lt;</span> <span class="number">1</span>;  
        tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tp<span class="subst">-&gt;</span>rttvar <span class="subst">=</span> <span class="keyword">max</span>(tp<span class="subst">-&gt;</span>mdev, tcp_rto_min(sk));

        <span class="comment">/* 记录引起rttvar改变的序列号，用于后续判断是否过了一个RTT，这是常用技巧 */</span>
        tp<span class="subst">-&gt;</span>rtt_seq <span class="subst">=</span> tp<span class="subst">-&gt;</span>snd_nxt;  <span class="comment">// 注意这里是snd_nxt，不是snd_una</span>
    }

<span class="number">1.3</span><span class="built_in">.</span> 对应net/ipv4/tcp_input<span class="built_in">.</span>c line639 tcp_rtt_estimator()
    long m <span class="subst">=</span> mrtt; <span class="comment">// RTT</span>
    <span class="keyword">if</span> (m <span class="subst">==</span> <span class="number">0</span>)
        m <span class="subst">=</span> <span class="number">1</span>;
    <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">!=</span> <span class="number">0</span>) {
        m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">&gt;&gt;</span> <span class="number">3</span>);   <span class="comment">// m = RTT - SRTT</span>
        tp<span class="subst">-&gt;</span>srtt <span class="subst">+=</span> m;          <span class="comment">// 8SRTT = 7 * SRTT + 1 * RTT</span>
        <span class="keyword">if</span> (m <span class="subst">&lt;</span> <span class="number">0</span>) {
            m <span class="subst">=</span> <span class="attribute">-m</span>;             <span class="comment">// m = |RTT - SRTT|</span>
            m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;&gt;</span> <span class="number">2</span>);   <span class="comment">// m = |RTT - SRTT| - RTTVAR</span>
            <span class="keyword">if</span> (m <span class="subst">&gt;</span> <span class="number">0</span>)  
                <span class="comment">/* 此处m&gt;0意味着，RTT与SRTT之间的波动过大，甚至烧过了RTTVAR
                 * 因此选择使用更小的beta值= 1/(4*8)
                 *      执行下面语句后，再执行tp-&gt;mdev += m则会得到如下结果
                 *      RTTVAR = (1-1/32)RTTVAR + |RTT - SRTT|
                 * 这样做的目的是避免突发的RTT变化，对RTTVAR的历史记录造成过大的影响
                 */</span>
                m <span class="subst">&gt;&gt;=</span> <span class="number">3</span>;    <span class="comment">// m = 1/8 (|RTT - SRTT| - RTTVAR)</span>
        } <span class="keyword">else</span> {
            m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;&gt;</span> <span class="number">2</span>);   <span class="comment">// m = |RTT - SRTT| - RTTVAR</span>
        }
        tp<span class="subst">-&gt;</span>mdev <span class="subst">+=</span> m;              <span class="comment">// 4RTTVAR = 3RTTVAR + |RTT - SRTT|</span>
        <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;</span> tp<span class="subst">-&gt;</span>mdev_max) {
            tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tp<span class="subst">-&gt;</span>mdev;
            <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev_max <span class="subst">&gt;</span> tp<span class="subst">-&gt;</span>rttvar)
                <span class="comment">/* 真正的RTTVAR会取一个RTT中最大的RTTVAR，是一种相对保守的策
                 * 因为计算略微偏大的RTO不会引起大问题，
                 * 但如果计算的RTO偏小则可能引起spurious retransmission
                tp-&gt;rttvar = tp-&gt;mdev_max;  
        }
        /* 如果过了一个RTT，则重置mdev_max，并适当调整rttvar */</span>
        <span class="keyword">if</span> (after(tp<span class="subst">-&gt;</span>snd_una, tp<span class="subst">-&gt;</span>rtt_seq)) {  
            <span class="comment">/* 目前看到的代码里面唯一可能导致mdev_max &lt; rttvar的代码就是
             *      tp-&gt;mdev_max = tcp_rto_min(sk);
             */</span>
            <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev_max <span class="subst">&lt;</span> tp<span class="subst">-&gt;</span>rttvar)
                tp<span class="subst">-&gt;</span>rttvar <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>rttvar <span class="subst">-</span> tp<span class="subst">-&gt;</span>mdev_max) <span class="subst">&gt;&gt;</span> <span class="number">2</span>;
            tp<span class="subst">-&gt;</span>rtt_seq <span class="subst">=</span> tp<span class="subst">-&gt;</span>snd_nxt;
            tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tcp_rto_min(sk);     <span class="comment">// 每过一个RTT重置mdev_max</span>
        }
    }

<span class="number">1.4</span> 根据代码和实际测量值，均未发现Linux有将RTO设置round <span class="keyword">to</span> <span class="number">1</span>s了

<span class="number">1.5</span> net/ipv4/tcp_input<span class="built_in">.</span>c line705 tcp_set_rto()
    <span class="comment">/*1.2和1.3都只是计算srtt和rttvar，并未计算rto */</span>
    inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> __tcp_set_rto(tp);     <span class="comment">// 根据srtt和rttvar计算rto</span>
    tcp_bound_rto(sk);                              <span class="comment">// 限制rto的最大值</span>

其中，__tcp_set_rto(tp)和tcp_bound_rto(sk)的代码如下：
    static <span class="keyword">inline</span> u32 __tcp_set_rto(const struct tcp_sock <span class="subst">*</span>tp)
    {
        <span class="keyword">return</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">&gt;&gt;</span> <span class="number">3</span>) <span class="subst">+</span> tp<span class="subst">-&gt;</span>rttvar;    <span class="comment">// RTO = SRTT + 4 * RTTVAR</span>
    }

    static <span class="keyword">inline</span> <span class="literal">void</span> tcp_bound_rto(const struct sock <span class="subst">*</span>sk)
    {
        <span class="keyword">if</span> (inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">&gt;</span> TCP_RTO_MAX)
            inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> TCP_RTO_MAX;   <span class="comment">// TCP_RTO_MAX = 120s</span>
    }
</code></pre><p>为了更好的理解RTT采样和RTO的整体流程，可以参考<a href="http://blog.csdn.net/zhangskd/article/details/7196707" target="_blank" rel="external">这篇资料</a>，尤其是最后一张函数关系调用图。<br>关键就是理解下面这个函数的调用过程  </p>
<pre><code><span class="keyword">void</span> tcp_valid_rtt_meas(<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *sk, u32 seq_rtt)
</span>{
    tcp_rtt_estimator(sk, seq_rtt);     <span class="comment">// 根据RTT sample，更新SRTT和RTTVAR</span>
    tcp_set_rto(sk);                    <span class="comment">// 重新计算RTO值</span>
    inet_csk(sk)-&gt;icsk_backoff = <span class="number">0</span>;     <span class="comment">// 将backoff清零</span>
}
</code></pre><hr>
<h3 id="Linux实现之RTO_timer的管理">Linux实现之RTO timer的管理</h3>
<pre><code><span class="number">2.1</span> net/ipv4/tcp_output.c line72 tcp_event_new_data_sent()
<span class="keyword">...</span>
unsigned int prior_packets = tp-&gt;packets_out;
<span class="keyword">...</span>
tp-&gt;packets_out += tcp_skb_pcount(skb); // 更新已经发出未被确认的数据包数目
<span class="keyword">if</span> (!prior_packets      // 如果prior_packets=<span class="number">0</span>，表示之前未发送过数据，因此需要启动timer
    ||<span class="keyword">...</span>)
    tcp_rearm_rto(sk);  // 启动RTO timer

<span class="number">2.2</span> net/ipv4/tcp_input.c line2926 tcp_rearm_rto()
<span class="keyword">...</span>
/* 如果packet_out=<span class="number">0</span>，则停掉RTO timer */
<span class="keyword">if</span> (!tp-&gt;packets_out) {
    inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);   
}

<span class="number">2.3</span> net/ipv4/tcp_input.c line3105 tcp_clean_rtx_queue()
<span class="keyword">...</span>
<span class="keyword">if</span> (flag &amp; FLA_ACKED) {
    <span class="keyword">...</span>
    tcp_ack_update_rtt(sk, flag, seq_rtt);  // 得到一个RTT sample，更新RTO
    tcp_rearm_rto(sk);                      // 重设RTO timer
    <span class="keyword">...</span>
}

<span class="number">2.4</span>+<span class="number">2.5</span>+<span class="number">2.6</span> net/ipv4/tcp_timer.c line340 tcp_retransmit_timer()
<span class="keyword">...</span>
tcp_enter_loss(sk, <span class="number">0</span>);  // 进入RTO超时重传阶段
<span class="keyword">if</span> (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; <span class="number">0</span>) // 重传第一个未确认的数据包
<span class="keyword">...</span>

/* 如果这是一个thin的TCP流，则不适用backoff机制 
 * 什么是thin tcp呢？就是网络中in_flight的数据包很少的流
 * 具体请看tcp_stream_is_thin(tp)
 */
<span class="keyword">if</span> (STREAM IS THIN ?) { 
    icsk-&gt;icsk_backoff = <span class="number">0</span>;
    icsk-&gt;icsk_rto = min(__tcp_set_rto(tp), TCP_RTO_MAX);
} <span class="keyword">else</span> {
    /* Use normal (exponential) backoff */  
    icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; <span class="number">1</span>, TCP_RTO_MAX); // 步骤<span class="number">2.5</span>
}
/* 步骤<span class="number">2.6</span> 重设RTO timer */
inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);

<span class="number">2.7</span> net/ipv4/tcp_metrics.c line441 tcp_init_metrics()
/* tcp_init_metrics是在TCP建立连接之后进行的初始化动作
 * 一个明显的例子： tcp_finish_connect() =&gt; tcp_init_metrics()
 */
<span class="keyword">...</span>
<span class="keyword">if</span> (tp-&gt;srtt == <span class="number">0</span>) {
    /* 如果在3WHS阶段没有获得srtt，基本就意味着发生了重传 */
    tp-&gt;mdev = tp-&gt;mdev_max = tp-&gt;rttvar = TCP_TIMEOUT_FALLBACK;
    inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_FALLBACK;
}  
</code></pre><p>至此，基本上把Linux 3.10中关于RTO的基本逻辑弄清楚了。RFC6298中proposed的算法的<br>主要步骤也找到了对应的代码实现位置。   </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="external">RFC 6298</a><br><a href="http://blog.csdn.net/zhangskd/article/details/7196707" target="_blank" rel="external">TCP中RTT的测量和RTO的计算</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>RTO的准确计算对于TCP的可靠性传输和性能都具有重要作用。<br>这篇文章首先介绍最新的RFC中对于RTO的计算方法，然后结合Linux 3.10的源码对<br>具体的实现进行分析和理解。  </p>
]]>
    
    </summary>
    
      <category term="rtt" scheme="http://perthcharles.github.com/tags/rtt/"/>
    
      <category term="rto" scheme="http://perthcharles.github.com/tags/rto/"/>
    
      <category term="rfc6298" scheme="http://perthcharles.github.com/tags/rfc6298/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP timestamp]]></title>
    <link href="http://perthcharles.github.com/2015/08/27/timestamp-intro/"/>
    <id>http://perthcharles.github.com/2015/08/27/timestamp-intro/</id>
    <published>2015-08-27T13:00:35.000Z</published>
    <updated>2015-08-30T13:31:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>tcp_timestamps是在<a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323</a>中定义的一个TCP选项。<br>这篇wiki介绍一下timestamps的设计目的和相关原理，尤其强调一些比较tricky的地方。<br><a id="more"></a>  </p>
<hr>
<h3 id="关于RFC1323">关于RFC1323</h3>
<p>这是一篇介绍针对High-bandwidth, Long delay链路设计的一些TCP扩展选项的资料。强烈推荐阅读！<br>但这篇RFC其实已经被<a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC7323</a>所取代，不过RFC1323对于了解timestamp相关的基本概念来说还是足够了的。关于RFC7323也会在后续的wiki中详细的介绍。  </p>
<p>High-bandiwidth, Long delay链路面临的性能问题  </p>
<pre><code>a. Window Size limit  
TCP头部仅16字节用于存放receive window，这在高BDP的链路中往往是不够用的  
解决办法就是引入window scale选项，然后real<span class="emphasis">_rcv_</span>wnd = rcv<span class="emphasis">_wnd_</span>in<span class="emphasis">_tcp_</span>header * (2^win_scale)  

b. Recovery from Losses  
当BDP很大时，意味着需要更大的cwnd来充分利用带宽。如果发生网络丢包，则对这类链路的影响是巨大的。  
优化办法(真的不能说解决T_T)就是引入[<span class="link_label">SACK</span>](<span class="link_url">https://tools.ietf.org/html/rfc2018</span>)机制，来为发送方重传提供更加准确的信息。  

c. Round-Trip Measurement  
TCP作为可靠的传输协议，一个重要的机制就是超时重传。因此如何计算一个准确(合适)的
RTO对于TCP性能有着重要的影响。而tcp_timestamp选项正是<span class="emphasis">*主要*</span>为此而设计的。  
</code></pre><p>上一句话强调”主要”是因为tcp_timestamp还被用于PAWS机制，而这一重要用途却时常被忽略。<br>作为一个可靠的传输协议，TCP除了考虑如何应对性能问题，还需要考虑可靠性问题。<br>即使这些问题发生的概率较低，PAWS就是其中一个例子。<br>PAWS(Protect Against Wrapped Sequence numbers)一句话解释如下，后面会详细介绍  </p>
<pre><code>在高带宽下，TCP序列号可能在较短的时间内就被重复使用(recycle/wrapped)
就可能导致同一条TCP流在短时间内出现序号一样的两个合法的数据包及其确认包！
</code></pre><p>补充一句：什么用wrapped形容序列号被重复使用？因为压圈了呀 :)  </p>
<hr>
<h3 id="tcp_timestamps_的设计">tcp_timestamps 的设计</h3>
<p>tcp_timestamps的本质是记录数据包的发送时间。基本的步骤如下  </p>
<pre><code><span class="bullet">1. </span>发送方在发送数据时，将一个timestamp(表示发送时间)放在包里面
<span class="bullet">2. </span>接收方在收到数据包后，在对应的ACK包中将收到的timestamp返回给发送方(echo back)
<span class="bullet">3. </span>发送发收到ACK包后，用当前时刻now - ACK包中的timestamp就能得到准确的RTT
</code></pre><p>当然实际运用中要考虑到RTT的波动，因此有了后续的(Round-Trip Time Measurement)RTTM机制</p>
<p>TCP Timestamps Option (TSopt)具体设计如下  </p>
<pre><code>Kind: 8             // 标记唯一的选项类型，比如window scale是3
<span class="header">Length: 10 bytes    // 标记Timestamps选项的字节数
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="header">| Kind=8 | Length=10 | TS Value (TSval) | TS ECho Reply (TSecr) |
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="code">    1          1             4                       4</span>
</code></pre><p>timestamps一个双向的选项，当一方不开启时，两方都将停用timestamps。<br>比如client端发送的SYN包中带有timestamp选项，但server端并没有开启该选项。<br>则回复的SYN-ACK将不带timestamp选项，同时client后续回复的ACK也不会带有timestamp选项。<br>当然，如果client发送的SYN包中就不带timestamp，双向都将停用timestamp。  </p>
<hr>
<h3 id="为什么需要timestamp">为什么需要timestamp</h3>
<p>如果没有timestamp，RTT的计算会怎样？  </p>
<pre><code><span class="number">1</span>. <span class="constant">TCP层</span>在发送出一个<span class="constant">SKB时</span>，使用skb-&gt;<span class="keyword">when</span>记录发送出去的时间
<span class="number">2</span>. <span class="constant">TCP层</span>在收到<span class="constant">SKB数</span>据包的确认时，使用now - skb-&gt;<span class="keyword">when</span>来计算<span class="constant">RTT</span>
</code></pre><p>但上面的机制在丢包发生时会有问题，比如</p>
<pre><code><span class="bullet">1. </span>TCP层第一次发送SKB的时间是send<span class="emphasis">_time1, TCP层重传一个数据包的时间是send_</span>time2
<span class="bullet">2. </span>当TCP层收到SKB的确认包的时间是recv_time
</code></pre><p>但是RTT应该是 (recv_time - send_time1)呢，还是(recv_time - send_time2)呢？  </p>
<p>以上两种方式都不可取！因为无法判断出recv_time对应的ACK是确认第一次数据包的发送还是确认<br>重传数据包。因此TCP协议栈只能选择非重传数据包进行RTT采样。但是当出现严重丢包(比如整个窗口全部丢失)时，就完全没有数据包可以用于RTT采样。这样后续计算SRTT和RTO就会出现较大的偏差。  </p>
<p>timestamp选项很好的解决了上述问题，因为ACK包里面带的TSecr值，一定是触发这个ACK的数据包在发送端发送的时间。不管数据包是否重传都能准确的计算RTT(前提是TSecr遵循RTTM中的计算原则)。  </p>
<p>当然timestamp不仅解决了RTT计算的问题，还很好的为PAWS机制提供的信息依据。  </p>
<hr>
<h3 id="开启timestamp会有什么负面影响?">开启timestamp会有什么负面影响?</h3>
<p>这部分内容以后会根据更多的实际经验来补充。目前列举一些找到的分析。  </p>
<pre><code><span class="number">1.</span> <span class="number">10</span>字节的TCP header开销

<span class="number">2.</span> The TCP Timestamp when enabled will allow you <span class="built_in">to</span> guess <span class="operator">the</span> uptime
   <span class="operator">of</span> <span class="operator">a</span> target <span class="keyword">system</span> (nmap v -O . Knowing how <span class="keyword">long</span> <span class="operator">a</span> <span class="keyword">system</span> has been
   up will enable you <span class="built_in">to</span> determine whether security patches that <span class="built_in">require</span>
   reboot has been applied <span class="operator">or</span> <span class="operator">not</span>.
        引自：<span class="keyword">http</span>://stackoverflow.com/questions/<span class="number">7880383</span>/what-benefit-is-conferred-<span class="keyword">by</span>-tcp-timestamp
        注：如果通过热补丁修复bug，是否就能够避免这个问题？  
</code></pre><hr>
<h3 id="什么是RTTM">什么是RTTM</h3>
<p>RTTM规定了一些使用TSecr计算RTT的原则，具体如下<br>(英文水平有限，为保持原意就使用RFC中的原话了)  </p>
<pre><code><span class="operator">a</span>.  A TSecr <span class="built_in">value</span> received <span class="operator">in</span> <span class="operator">a</span> segment is used <span class="built_in">to</span> update <span class="operator">the</span>
    averaged RTT measurement only <span class="keyword">if</span> <span class="operator">the</span> segment acknowledges
    some <span class="built_in">new</span> data
b.  The data-sender TCP must measure <span class="operator">the</span> <span class="keyword">effective</span> RTT, including <span class="operator">the</span> additional
    <span class="built_in">time</span> due <span class="built_in">to</span> delayed ACKs. Thus, when delayed ACKs are <span class="operator">in</span> use, <span class="operator">the</span> receiver should
    reply <span class="operator">with</span> <span class="operator">the</span> TSval field <span class="built_in">from</span> <span class="operator">the</span> earliest
c.  An ACK <span class="keyword">for</span> <span class="operator">an</span> out-<span class="operator">of</span>-order segment should therefore contain <span class="operator">the</span> 
    timestamp <span class="built_in">from</span> <span class="operator">the</span> most recent segment that advanced <span class="operator">the</span> window
d.  The timestamp <span class="built_in">from</span> <span class="operator">the</span> latest segment (which filled <span class="operator">the</span> hole) must be echoed
        在ACK被重传的数据时，应该使用重传数据包中的TSval进行回复
</code></pre><p>如果对以上的特殊情况有疑问，还请直接去看RFC，里面有example解释。  </p>
<p>最后，实际上计算RTO除了以上使用TSecr的原则外，还有一些更复杂的计算方法<a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC 7323</a>。<br>比如对于每一个RTT采样R，  </p>
<pre><code><span class="constant">RTTVAR</span> = (<span class="number">1</span> - beta) * RTTVAR + beta * |SRTT - R|
<span class="constant">SRTT</span> = (<span class="number">1</span> - alpha) * SRTT + alpha * R
</code></pre><hr>
<h3 id="什么是PAWS">什么是PAWS</h3>
<p>PAWS — Protect Againest Wrapped Sequence numbers<br>目的是解决在高带宽下，TCP序号可能被重复使用而带来的问题。  </p>
<p>PAWS同样依赖于timestamp，并且假设在一个TCP流中，<em>按序</em>收到的所有TCP包的timestamp值<br>都是线性递增的。而在正常情况下，每条TCP流<em>按序</em>发送的数据包所带的timestamp值<br>也确实是线性增加的。<br>至于为什么要强调<em>按序</em>，请先自行思考。:)  </p>
<p>首先给出几个变量的定义，之后具体介绍PAWS的工作过程  </p>
<pre><code>Per-Connection State Variables
<span class="label">    TS.Recent:</span>       Latest received Timestamp
<span class="label">    Last.ACK.sent:</span>   Last ACK field sent

<span class="preprocessor">Option</span> Fields <span class="keyword">in</span> Current <span class="built_in">Segment</span>
<span class="label">    SEG.TSval:</span>   TSval field from TSopt <span class="keyword">in</span> current <span class="built_in">segment</span>.
<span class="label">    SEG.TSecr:</span>   TSecr field from TSopt <span class="keyword">in</span> current <span class="built_in">segment</span>.
</code></pre><p>TS.Recent存放着<em>按序</em>达到的所有TCP数据包的最晚的一个时间戳，即只有在<br><code>SEG.SEQ &lt;= Last.ACK.sent &lt; SEG.SEG + SEG.LEN</code>(有新的数据被按序确认了)时，<br>才会去更新TS.Recent的值。  </p>
<pre><code>假设三个数据包的*第一次*发送时间分别是<span class="literal">A</span>，B和C(<span class="literal">A</span> &lt; B &lt; C)，但<span class="literal">A</span>和C含有相同的序列号。
而<span class="literal">A</span>数据包由于某种原因，在阻塞在了网络中，因此发送方进行了重传，重传时间为A2

PAWS要解决的主要问题就是：
    当接收端在接收到A2后，又接着确认到了数据包B，下一个想接收的数据是数据包C
    此时如果收到了数据包<span class="literal">A</span>(<span class="literal">A</span>从阻塞中恢复过来了，但并未真的丢失)，
    由于<span class="literal">A</span>与C的序列号是相同的。如果没有别的保护措施就会出现数据紊乱，没有做到可靠传输

PAWS的做法就是，如果收到的一个TCP数据包的timestamp值小于TS.Recnt，则会丢弃该数据包。  
因此数据包<span class="literal">A</span>到达接收方后，接收方的TS.Recent应该是数据包B中的timestamp
而<span class="literal">A</span> &lt; B，故<span class="literal">A</span>包就会被丢弃。而真正有效的数据C到达接收后，由于B &lt; C，因此能被正常接收
</code></pre><p>PAWS的更多细节  </p>
<pre><code><span class="number">1.</span> It is recommended that RST segments NOT carry timestamps, <span class="operator">and</span> that
RST segments be acceptable regardless <span class="operator">of</span> their timestamp.

<span class="number">2.</span> PAWS is defined strictly <span class="operator">within</span> <span class="operator">a</span> single connection; <span class="operator">the</span> <span class="keyword">last</span> timestamp is
TS.Recent is kept <span class="operator">in</span> <span class="operator">the</span> connection control block, <span class="operator">and</span>
discarded when <span class="operator">a</span> connection is closed.

<span class="number">3.</span> An additional mechanism could be added <span class="built_in">to</span> <span class="operator">the</span> TCP, <span class="operator">a</span> per-host
cache <span class="operator">of</span> <span class="operator">the</span> <span class="keyword">last</span> timestamp received <span class="built_in">from</span> <span class="keyword">any</span> connection.
This <span class="built_in">value</span> could <span class="keyword">then</span> be used <span class="operator">in</span> <span class="operator">the</span> PAWS mechanism <span class="built_in">to</span> reject
old duplicate segments <span class="built_in">from</span> earlier incarnations <span class="operator">of</span> <span class="operator">the</span>
connection, <span class="keyword">if</span> <span class="operator">the</span> timestamp clock can be guaranteed <span class="built_in">to</span> have
ticked <span class="keyword">at</span> least once since <span class="operator">the</span> old connection was <span class="built_in">open</span>.
</code></pre><p>从第三点可以看到，如果针对per-host的使用PAWS中的机制，则会解决TIME-WAIT中考虑的上一个流<br>的数据包在下一条流中被当做有效数据包的情况，这样就没有必要等待2*MSL来结束TIME-WAIT了。<br>只要等待足够的RTO，解决好需要重传最后一个ACK的情况就可以了。<br>因此Linux就实现了这样一种机制：</p>
<pre><code>当timestamp和tw_recycle两个选项同时开启的情况下，开启per-host的PAWS机制。
从而能快速回收处于<span class="typename">TIME</span>-<span class="keyword">WAIT</span>状态的TCP流。
</code></pre><p>但这样真的就能完美的解决令无数人头疼的TIME-WAIT吗？答案是否定的！<br>因为公网中存在太多的NAT设置，当使用per-host的PAWS机制时，是无法保证timestamp是线性递增这一假设的。因为使用同一个NAT地址的两个真实的机器，他们的timestamp是不能保证同步的(其实一致也没有用，NAT就是per-host PAWS机制的死敌)。<br>关于这个问题也会在以后的一篇介绍TIME-WAIT的wiki中进一步详细介绍。  </p>
<hr>
<h3 id="总结">总结</h3>
<pre><code>timestamp为TCP/IP协议栈提供了两个功能：  
    <span class="operator">a</span>. 更加准确的RTT测量数据，尤其是有丢包时  <span class="comment">-- RTTM  </span>
    b. 保证了在极端情况下，TCP的可靠性        <span class="comment">-- PAWS  </span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">Documentation: ip-sysctl.txt</a><br><a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323: TCP Extensions for High Performance</a><br><a href="http://tools.ietf.org/html/rfc7323" target="_blank" rel="external">RFC 7323: TCP Extensions for High Performance</a><br><a href="https://tools.ietf.org/html/rfc2018" target="_blank" rel="external">SACK</a><br><a href="http://stackoverflow.com/questions/7880383/what-benefit-is-conferred-by-tcp-timestamp" target="_blank" rel="external">What benefit is conferred by TCP timestamp?</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>tcp_timestamps是在<a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323</a>中定义的一个TCP选项。<br>这篇wiki介绍一下timestamps的设计目的和相关原理，尤其强调一些比较tricky的地方。<br>]]>
    
    </summary>
    
      <category term="timestamp" scheme="http://perthcharles.github.com/tags/timestamp/"/>
    
      <category term="RTTM" scheme="http://perthcharles.github.com/tags/RTTM/"/>
    
      <category term="PAWS" scheme="http://perthcharles.github.com/tags/PAWS/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个NAT问题引起的思考]]></title>
    <link href="http://perthcharles.github.com/2015/08/27/timestamp-NAT/"/>
    <id>http://perthcharles.github.com/2015/08/27/timestamp-NAT/</id>
    <published>2015-08-27T12:45:17.000Z</published>
    <updated>2015-08-31T08:11:07.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h3 id="问题">问题</h3>
<p>当服务器同时开启tcp_timestamps和tcp_tw_recycle选项时，会导致客户反馈连接成功率降低的情况。<br>but why ???<br><a id="more"></a>  </p>
<hr>
<h3 id="公网NAT的存在">公网NAT的存在</h3>
<p>NAT的全称是：<a href="https://en.wikipedia.org/wiki/Network_address_translation" target="_blank" rel="external">Network Address Translation</a>。<br>一个具体的例子就是家用的局域网络。<br>当使用一台无线路由器进行上网拨号后，其他的终端设备只要连接进入该无线路由器的WiFi<br>网络内就可以访问外网了。此时正是NAT在发挥作用。<br>每一台终端设备在接入无线路由器后，只是获得一个局域网IP地址，而当你在百度输入我的IP的时候<br>你看到的IP地址则是你无线路由器的公网IP地址。家用无线路由器完成的一个主要工作正是将终端<br>的局域网IP地址进行NAT转换为公网IP地址。  </p>
<p>从上面这个简单的例子可以看到NAT在真实的互联网中是普遍存在的，比如你所在学校，单位都会一定程度上的使用NAT机制。  </p>
<hr>
<h3 id="Per-host_PAWS机制">Per-host PAWS机制</h3>
<p>在<a href="http://perthcharles.github.io/2015/08/27/timestamp-intro/" target="_blank" rel="external">这篇介绍TCP timestamp</a><br>的文章中提到了一种针对per-host的PAWS机制。这种机制要求所有来个同一个host IP的TCP数据包的<br>timestamp值是递增的。当收到一个timestamp值，小于服务端记录的对应值后，则会认为这是一个过期的数据包，然后会将其丢弃。  </p>
<hr>
<h3 id="解答问题">解答问题</h3>
<p>至此就不难解释为什么在同时开启tcp_timestamp和tcp_tw_recycle时，会遇到客户反馈连接成功率降低的情况了，基本的逻辑如下：  </p>
<pre><code><span class="bullet">1. </span>同时开启tcp<span class="emphasis">_timestamp和tcp_</span>tw_recycle会启用TCP/IP协议栈的per-host的PAWS机制
<span class="bullet">2. </span>经过同一NAT转换后的来自不同真实client的数据流，在服务端看来是于同一host打交道
<span class="bullet">3. </span>虽然经过同一NAT转化，但由于不同真实client会携带各自的timestamp值
因而无法保证整过NAT转化后的数据包携带的timestamp值严格递增
<span class="bullet">4. </span>当服务器的per-host PAWS机制被触发后，会丢弃timestamp值不符合递增条件的数据包
</code></pre><p>解决办法就是不建议同时开启tcp_timestamp和tcp_tw_recycle。<br>那到底怎么配置？  </p>
<pre><code>开启tcp_timestamp，但不要开tcp_tw_recycle  
开启tcp_timestamp，但不要开tcp_tw_recycle  
开启tcp_timestamp，但不要开tcp_tw_recycle  
</code></pre><p>因为timestamp有更多其他的作用，而tcp_tw_recycle本身就是依赖于timestamp的。在不开启timestamp的情况下，单独开启tcp_tw_recycle并没有什么用<br>其实上述强调三遍的配置，正是目前Linux的默认配置。所以说啊，不真正搞懂内核的参数选项，就不要盲目修改。尤其是在官方文档对tcp_tw_recycle已经强调了不要盲目修改的情况下  </p>
<pre><code>那为什么有人推荐同时开启tcp_timestamp和tcp_tw_recycle呢？
因为同时开启后，能够更快的回收<span class="typename">TIME</span>-<span class="keyword">WAIT</span>状态的socket    &lt;== 这也正是PAWS从per-conn在配置后扩展到per-host的目的  
只可惜逻辑是对的，但是没有考虑到公网广泛存在的NAT机制可能带来的问题。  
</code></pre><hr>
<h3 id="源码细节分析">源码细节分析</h3>
<p>这部分是linux 3.10源码部分的分析，算是对于以上理论分析提供的依据，不关系细节的话可以忽略本节  </p>
<pre><code><span class="comment">// tcp_v4_conn_request(), net/ipv4/tcp_ipv4.c line 1551</span>
<span class="keyword">if</span> (tmp_opt.saw_tstamp &amp;&amp;      <span class="comment">// 是否见到过tcp_timestamp选项</span>
    tcp_death_row.sysctl_tw_recycle &amp;&amp;   <span class="comment">// 接着判断是否开启recycle</span>
    (dst = inet_csk_route_req(sk, &amp;fl4, req)) != NULL &amp;&amp;    <span class="comment">// 最终判断saddr是否有相关记录在route表中</span>
    fl4.daddr == saffr) {
    <span class="keyword">if</span> (!tcp_peer_is_proven(req, dst, <span class="keyword">true</span>)) {  <span class="comment">// 如果这个建连请求不能被proven，则会被丢弃</span>
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);
        goto drop_and_release;
    }
}

<span class="comment">// tcp_peer_is_proven() net/ipv4/tcp_metrics.c line 536</span>
<span class="comment">// 负责判断接收到的request请求的timestamp是否符合要求，最重要的一段代码如下</span>
<span class="keyword">if</span> (tm &amp;&amp;
    <span class="comment">// 判断保存tcpm_ts_stamp值是否有效，TCP_PAWS_MSL=60</span>
    (<span class="keyword">u32</span>)get_seconds() - tm-&gt;tcpm_ts_stamp &lt; TCP_PAWS_MSL &amp;&amp;
    <span class="comment">// 如果记录值大于当前收到的req中的timestamp值，则丢弃。TCP_PAWS_WINDOW=1</span>
    (<span class="keyword">u32</span>)(tm-&gt;tcpm_ts - req-&gt;ts_recent) &gt; TCP_PAWS_WINDOW) {
        ret = <span class="keyword">false</span>;
}
</code></pre><p>至此可以看到：在tcp_timestamp和tcp_tw_recycle同时开启时，会触发Linux的per-host的PAWS机制  </p>
<p>接下来分析开启tcp_tw_recycle和tcp_timestamp时，是怎么快速回收TIME-WAIT的  </p>
<pre><code>// tcp_time_wait() net/ipv4/tcp_minisocks.c  line <span class="number">267</span>
<span class="keyword">...</span>
// ts_recent_stamp依赖于timestamp选项的开启，可进tcp_minisocks.c验证  
<span class="keyword">if</span> (tcp_death_row.sysctl_tw_recycle &amp;&amp; tp-&gt;rx_opt.ts_recent_stamp)
    recycle_ok = tcp_remember_stamp(s);
<span class="keyword">...</span>
// 如果能够recycle，则使用更短的rto作为timeout，从而更快回收TIME-WAIT
<span class="keyword">if</span> (timeo &lt; rto)
    timeo = rto;
<span class="keyword">if</span> (recycle_ok) {
    tw-&gt;tw_timeout = rto;
} <span class="keyword">else</span> {
    tw-&gt;tw_timeout = TCP_TIMEWAIT_LEN;
    <span class="keyword">if</span> (state == TCP_TIME_WAIT) 
        timeo = TCP_TIMEWAIT_LEN;    
}
inet_twsh_schedule(tw, &amp;tcp_death_row, timeo, TCP_TIMEWAIT_LEN);

// tcp_timewait_state_process() net/ipv4/tcp_minisocks.c line <span class="number">94</span>
// 另一条进入time-wait的路线有类似的代码
<span class="keyword">if</span> (tcp_death_row.sysctl_tw_recycle &amp;&amp;
    tcptw-&gt;tw_ts_recent_stamp &amp;&amp;
    tcp_tw_remember_stamp(tw))
        inet_twsk_schedule(tw, &amp;tcp_death_row, tw-&gt;tw_timeout,
                           TCP_TIMEWAIT_LEN);
<span class="keyword">else</span>
        inet_twsk_schedule(tw, &amp;tcp_death_row, TCP_TIMEWAIT_LEN,
                           TCP_TIMEWAIT_LEN);
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">Documentation: ip-sysctl.txt</a><br><a href="http://tools.ietf.org/html/rfc1323" target="_blank" rel="external">RFC 1323:  TCP Extensions for High Performance</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h3 id="问题">问题</h3>
<p>当服务器同时开启tcp_timestamps和tcp_tw_recycle选项时，会导致客户反馈连接成功率降低的情况。<br>but why ???<br>]]>
    
    </summary>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="NAT" scheme="http://perthcharles.github.com/tags/NAT/"/>
    
      <category term="time_wait" scheme="http://perthcharles.github.com/tags/time-wait/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列五：小知识点及FAQ]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/git-faq/"/>
    <id>http://perthcharles.github.com/2015/08/25/git-faq/</id>
    <published>2015-08-25T07:38:40.000Z</published>
    <updated>2015-08-31T14:20:20.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>git作为一个强大的工具，也就意味着它也同样的复杂。<br>长期使用下来难免会遇到很多奇奇怪怪的问题和一些小的知识点，<br>这个帖子就用来记录一下那些年某人踩过的的坑T_T  </p>
<p>这篇会慢慢更新，当某个点内容较多后，会独立出去成为一篇独立的wiki<br><a id="more"></a>  </p>
<hr>
<h3 id="小知识点">小知识点</h3>
<hr>
<h4 id="Fast_forward_merge">Fast forward merge</h4>
<p>直接上图例，不多解释  </p>
<pre><code>            <span class="comment">master</span>
               <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span>        <span class="comment">issue03</span>
                <span class="comment">\</span>          <span class="comment">↓</span>
                 <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span>

                            <span class="comment">master</span>
                              <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span>
                              <span class="comment">↑</span>
                            <span class="comment">issue03</span>
</code></pre><p>以上就是一个fast forward merge，那什么不是fast forward merge呢？请看下图  </p>
<pre><code>            <span class="comment">master</span>
               <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span>        <span class="comment">issue03</span>
           <span class="comment">\</span>               <span class="comment">↓</span>
            <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">H</span>

                              <span class="comment">master</span>
                              <span class="comment">↓</span>
<span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">I</span>
           <span class="comment">\</span>                <span class="comment">/</span> <span class="comment">↑</span>
            <span class="comment">E</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">F</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">G</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">H</span>  <span class="comment">issue03</span>
</code></pre><h4 id="Three-way_merge">Three-way merge</h4>
<p>two-way merge只用两个档案进行合并(svn默认是 two-way merge)<br>three-way merge 处理要合并的两个档案，还会奖赏两个档案的共同祖先。如此可大大减少人为处理conflict的情况。<br>为什么能减少人为处理conflict的情况呢？一图胜千言。<br><img src="/resources/three-way-merge.png" alt="Three-way merge">  </p>
<h4 id="实用alias">实用alias</h4>
<pre><code>// 每个commit显示一行，显示图形化的commit history，显示简短的SHA1
alias <span class="keyword">log</span>=<span class="string">"git log --oneline --graph --decorate --color=always"</span>
// 显示所有branch的commit history
alias logg=<span class="string">"git log --graph --all --format=format:'<span class="variable">%C</span>(bold blue)<span class="variable">%h</span><span class="variable">%C</span>(reset) - <span class="variable">%C</span>(bold green)(<span class="variable">%ar</span>)<span class="variable">%C</span>(reset) <span class="variable">%C</span>(white)<span class="variable">%s</span><span class="variable">%C</span>(reset) <span class="variable">%C</span>(bold white)—     <span class="variable">%an</span><span class="variable">%C</span>(reset)<span class="variable">%C</span>(bold yellow)<span class="variable">%d</span><span class="variable">%C</span>(reset)' --abbrev-commit --date=relative"</span>
</code></pre><h4 id="坚持新开branch进行开发需要遵循的原则">坚持新开branch进行开发需要遵循的原则</h4>
<pre><code>1. 不要直接在任何已经与远端建立track关系的branch中进行修改  
    目的：便于维护整洁的<span class="operator"><span class="keyword">commit</span> history

<span class="number">2.</span> feature branch的周期越短越好，不要同时开太多feature branch

<span class="number">3.</span> 在push之前先将本地分支与远端分支同步，推荐使用rebase的方式<span class="keyword">merge</span>

<span class="number">4.</span> 只有在需要push时（如，完成一个功能开发），才将开发分支与主干分支进行合并  
    目的：便于识别<span class="keyword">commit</span>是否push到远端，便于维护整洁的主干<span class="keyword">commit</span> history

<span class="number">5.</span> 分支命名规则
    与远端同步的分支，名字与远端分支一样。如dev -&gt; origin/dev
    进行开发的分支命名不严格限制，但不得与上一类分支重名。
        通过git <span class="keyword">log</span> <span class="comment">--graph即可看出开发分支与主干分支的关系</span></span>
</code></pre><hr>
<h3 id="FAQ">FAQ</h3>
<hr>
<h4 id="如何在git中添加空文件夹">如何在git中添加空文件夹</h4>
<p>git木人的情况下空目录是不会commit出去的，这在某些情况下会遇到问题（比如Rails如果少了log或tmp目录会不能启动）。<br>解决办法就是在空目录下面touch一个空的档案，一般是.gitkeep。  </p>
<h4 id="为什么说懂图论对理解git很有帮助">为什么说懂图论对理解git很有帮助</h4>
<p>理解Git最好的办法，就是用图论中的节点和指针来思考，所有的git的指令操作，<br>都是操作这些节点，新增、修改、删除、变更。<br>首先Git对于所有的内容管理可以理解为一张有向无环图，<a href="https://codewords.recurse.com/issues/two/git-from-the-inside-out" target="_blank" rel="external">这是一篇很好解释文章</a>。<br>同时就自身体会而言，rebase中的base可以理解为两个branch的最小公共祖先。<br>而Fast forward merge可以理解为两个branch合并时，有一个branch是指向这个<br>base节点的。  </p>
<h4 id="如何撤销merge操作">如何撤销merge操作</h4>
<p>如果是刚刚merge完，则可以直接<code>git reset --hard HEAD~</code><br>如果已经添加了很多commit后，才想起来撤销merge，那就该好好反省了。  </p>
<h4 id="如何合理的操作处理分支">如何合理的操作处理分支</h4>
<pre><code><span class="comment">// push 操作</span>
<span class="array"># git push origin b</span>1:rb1    <span class="comment">// 将本地的b1分支推送到远端分支rb1，当前分支不需要一定是b1</span>
<span class="array"># git push origin b</span>1        <span class="comment">// 将本地的b1分支推送到远端分支b1，如果远端不存在b1则新建一个</span>
<span class="array"># git push </span>-u origin b1     <span class="comment">// 第一次push时指定好track，之后就可以直接git push了</span>
<span class="array"># git push                  </span><span class="comment">// 如果是在一个已经建立了track关系的local branch，则可直接push</span>
<span class="array"># git push origin </span>:rb1      <span class="comment">// 删除远端分支rb1</span>

<span class="comment">// fetch 操作</span>
<span class="array"># git fetch </span>-a                  <span class="comment">// 获取远端所有分支</span>
<span class="array"># git fetch origin b</span>2           <span class="comment">// 获取远端分支b2</span>
<span class="array"># git branch b</span>2 origin/b2       <span class="comment">// 随后创建一个本地的b2分支与远端分支建立联系，最好名字一样，否则push时要手动指定</span>
<span class="array"># git checkout </span>--track -b b2 origin/b2  <span class="comment">// 或者直接checkout到一个新建的b2分支   </span>

<span class="comment">// merge 操作</span>
<span class="array"># git cherry</span>-pick <span class="number">332</span>sd3f3      <span class="comment">// 仅将选定的commit apply/patch进入当前分支，相当于首先将332sd3fs打包成一个git格式的patch，然后apply进来。很干净的一种用法</span>
<span class="array"># git merge b</span>1                  <span class="comment">// 将b1分支与current分支合并</span>

<span class="comment">// pull 操作 = fetch + merge</span>
<span class="array"># git pull origin b</span>10   <span class="comment">// 将远端的b10分支与当前分支进行合并，等价于下面两句</span>
    <span class="array"># git fetch origin b</span>10
    <span class="array"># git merge origin</span>/b10
<span class="array"># git pull </span>--rebase origin b10  <span class="comment">// 推荐使用rebase方式合并：本地分支及它track的远端分支</span>

<span class="comment">// remote 操作</span>
<span class="array"># git remote prune origin   </span><span class="comment">// 删除不存在远端仓库的分支</span>
</code></pre><h4 id="如何为一个新建的git添加remote">如何为一个新建的git添加remote</h4>
<pre><code><span class="comment">// 添加remote的仓库地址，origin是名字</span>
<span class="array"># git remote add origin git</span>:<span class="comment">//example.com/a.git    </span>
</code></pre><h4 id="如何恢复某个被修改过的文件">如何恢复某个被修改过的文件</h4>
<pre><code><span class="preprocessor"># git checkout file-name    </span>
</code></pre><h4 id="如何整理git_working_area文件">如何整理git working area文件</h4>
<pre><code><span class="array"># git clean </span>-f          <span class="comment">// 删除未被git管理的文件</span>
<span class="array"># git clean </span>-f -d       <span class="comment">// 同时将未被git管理的目录也删除</span>
<span class="array"># git clean </span>-f -X       <span class="comment">// 仅删除被.gitignore忽略的文件</span>
<span class="array"># git clean </span>-f -x       <span class="comment">// 同时删除被.gitignore忽略的文件和未被管理的文件</span>
<span class="array"># git clean </span>-f -x -d    <span class="comment">// 删除所有未被git管理的文件和目录</span>
</code></pre><h4 id="如何创建一个独立的分支？">如何创建一个独立的分支？</h4>
<pre><code><span class="array"># git checkout </span>--orphan newbranch  <span class="comment">// git v1.7.2</span>
</code></pre><h4 id="有哪些经典的git_workflow可以参考学习？">有哪些经典的git workflow可以参考学习？</h4>
<p><a href="https://guides.github.com/introduction/flow/index.html" target="_blank" rel="external">1. Github Flow</a><br><a href="http://nvie.com/posts/a-successful-git-branching-model/" target="_blank" rel="external">2. GitFlow</a>  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://liujin.me/blog/2015/05/25/Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">Git 常用命令</a><br><a href="http://www.slideshare.net/epatey/perforce-convergence-vs-divergence/10" target="_blank" rel="external">The essence of a three-way merge</a><br><a href="https://ihower.tw/blog/archives/2620" target="_blank" rel="external">開branch 分支和操作遠端repo</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>git作为一个强大的工具，也就意味着它也同样的复杂。<br>长期使用下来难免会遇到很多奇奇怪怪的问题和一些小的知识点，<br>这个帖子就用来记录一下那些年某人踩过的的坑T_T  </p>
<p>这篇会慢慢更新，当某个点内容较多后，会独立出去成为一篇独立的wiki<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列四：在push之前对本地commit进行整理]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/clean-commit-log-before-push/"/>
    <id>http://perthcharles.github.com/2015/08/25/clean-commit-log-before-push/</id>
    <published>2015-08-25T03:58:42.000Z</published>
    <updated>2015-08-25T08:12:34.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在系列三中描述了commit消息的规范，但在实际操作中很难时刻做到那么严格的<br>控制，尤其是在本地做一些实验性的工作的时候。<br>但是如果需要push到远端去，则就必须保证commit消息的规范和commit的独立性。<br>因此就有了这样一个需求：在执行git push之前对本地的commit日志进行整理。<br><a id="more"></a>  </p>
<hr>
<h3 id="一个好习惯">一个好习惯</h3>
<p>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>本文讨论的一个重要前提是在执行git push之前，对于在本地还未提交commit进行整理！！！<br>重要的事情说三遍。<br>那为什么在git push之后不宜使用这些命令呢？<br>主要是因为本文设计到的命令都会重新提交commit，尽管有commit msg有时候不会变，但commit对应的SHA1哈希值会被改变。如果是已经push了的commit被改变了SHA1，则会造成比较严重的混乱。    </p>
<p>所以这里推荐一个好习惯  </p>
<pre><code>保持重要分支(如master)与远端的同步，开发一定要新开分支。  
</code></pre><p>这样一来就能够快速的识别那些属于还未push的本地commit。<br>接下来就详细介绍整理本地commit的几个重要命令：amemd, reset和rebase  </p>
<hr>
<h3 id="amend">amend</h3>
<p>amend会使用一个新的commit去替换最近的一次commit。<br>amend适用于：<br>a. 在提交commit后，才发现漏掉了某些修改，文件的情况<br>b. 修正一些typo  </p>
<pre><code><span class="comment">// 先进行一些修改，然后使用--amend选项重新提交一次commit</span>
<span class="array"># git commit </span>-a --amend             <span class="comment">// 弹出编辑窗口，重新提交新commit</span>
<span class="array"># git commit </span>-a --amend -C HEAD     <span class="comment">// 直接上一个commit消息</span>
</code></pre><hr>
<h3 id="reset">reset</h3>
<p>amend仅能替换最近一次commit，功能不够强大。比如想要快速的将working tree的修改和最近的两次commit合并得到一个新的commit则需要用到reset啦。<br>reset适用于：<br>a. 需要修改多个commit的情况，但也受限于修改从HEAD~开始连续的多个commit<br>b. 完全的删除前几个commit  </p>
<pre><code><span class="array"># git reset </span>--soft HEAD~<span class="number">2</span>       <span class="comment">// 删掉前两个commit，并保留文件更改</span>
<span class="array"># git reset </span>--hard HEAD~<span class="number">2</span>       <span class="comment">// 删掉前两个commit，并删除文件更改</span>
</code></pre><p>另外，万一如果需要修改的commit已经push出去了（是否应该避免？），又最好不要reset，那么该怎么做呢？<br>那就需要使用revert命令，revert命令会接着重新提交一个新的commit，用以回滚上一个commit的修改。有点负负得正的感觉。  </p>
<hr>
<h3 id="rebase">rebase</h3>
<p>reset受限于只能将从HEAD~开始的连续多个commit删除或(人工)合并。也还是不够强大。比如想要合并HEAD~2到HEAD~3的commit，删除HEAD~4的commit，则需要使用到rebase命令。<br>那到底什么是rebase呢？  </p>
<pre><code>rebase的核心含义就是重新设定基准！  
</code></pre><p>什么意思呢？<br>git对于commit的管理可以理解为一个有向无环图，你的某个branch一定是从另一个分支的某个节点开始分离出来的。比如下面情况下的dev分支的base就可以理解是B节点。<br>更专业的说法应该是：B是E(dev)和C(master)的最小公共祖先。    </p>
<pre><code><span class="comment">A</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">B</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">C</span>   &lt;<span class="comment">=</span> <span class="comment">master</span>
      <span class="comment">\</span>
       <span class="comment">D</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">E</span> &lt;<span class="comment">=</span> <span class="comment">dev</span>
</code></pre><p>rebase可以用于干什么？<br>a. 仅修改某些commit的msg<br>b. 变更commit顺序<br>c. 删掉某一个commit<br>d. 修改某一个commit对应的内容</p>
<p>rebase的基本命令就是<code>git rebase -i HEAD~n</code>啦，具体的操作流程在执行的时候都有详细的引导，这里就不再重复。想了解细节的推荐看<a href="https://help.github.com/articles/using-git-rebase/" target="_blank" rel="external">这篇tutorial</a> — 其实更推荐找个git仓库实践一把。</p>
<p>下面来介绍一下怎样处理常见的rebas冲突，至于rebase进阶用法，将在后续的wiki上介绍。  </p>
<h4 id="解决rebase冲突">解决rebase冲突</h4>
<p>当发生rebase无法顺利进行的时候，有以下几种选择：  </p>
<pre><code><span class="comment">// a. 放弃rebase  </span>
<span class="preprocessor"># git rebase --abort</span>
<span class="comment">// b. 忽视冲突  -- 一般很少用</span>
<span class="preprocessor"># git rebase --skip</span>

<span class="comment">// c. 解决冲突</span>
<span class="preprocessor"># git status                // 查看冲突类型，常见的是编辑冲突</span>
<span class="preprocessor"># vim conflict-file.md      // 编辑冲突文件</span>
<span class="preprocessor"># git add conflict-file.md  // 重新添加冲突文件</span>
<span class="preprocessor"># git rebase --continue     // 继续rebase</span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html" target="_blank" rel="external">rolling back changes with revert</a><br><a href="https://ihower.tw/blog/archives/2622" target="_blank" rel="external">Git 版本控制系統3 - 還沒 push 前可以做的事</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在系列三中描述了commit消息的规范，但在实际操作中很难时刻做到那么严格的<br>控制，尤其是在本地做一些实验性的工作的时候。<br>但是如果需要push到远端去，则就必须保证commit消息的规范和commit的独立性。<br>因此就有了这样一个需求：在执行git push之前对本地的commit日志进行整理。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列三：commit消息规范]]></title>
    <link href="http://perthcharles.github.com/2015/08/25/git-commit-log-format/"/>
    <id>http://perthcharles.github.com/2015/08/25/git-commit-log-format/</id>
    <published>2015-08-25T03:24:27.000Z</published>
    <updated>2015-08-25T03:52:57.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>维护一个良好的commit消息格式和规范，是一个优秀项目的重要前提。<br>本文就先来谈谈commit消息到底该怎么提交。<br><a id="more"></a>  </p>
<hr>
<h3 id="提交commit的基本原则">提交commit的基本原则</h3>
<pre><code><span class="bullet">1. </span>以一个小功能、小改进或一个bug fixed为单位
<span class="bullet">2. </span>对应的unit test 程序放在同一个commit中
<span class="bullet">3. </span>不相关的代码修改不要放在同一个commit
<span class="bullet">4. </span>语法错误的半成品程序不能commit
</code></pre><hr>
<h3 id="commit消息格式">commit消息格式</h3>
<p>这部分内容已经在具体的例子：<a href="http://perthcharles.github.io/2015/08/14/manage-project-code-like-linux-kernel/" target="_blank" rel="external">像linux kernel一样管理你的项目</a>描述过。<br>这里算是正式的整理进入wiki页面了。<br>至于如何保证做到这么干净利落的commit消息日志，则请移步后续对于rebase等命令的分析。commit的消息格式如下  </p>
<pre><code>第一行用一句简短的话总结这个<span class="operator"><span class="keyword">commit</span>  

第一行最好用一个描述性的前缀开始，比如  
  <span class="string">"net:"</span>表示针对net子系统的修改  
  <span class="string">"fix:"</span>表示这是一个bug fix  

第二行为空行

最后可以增加一些详细的描述，用以解释<span class="keyword">commit</span>具体干了什么，为什么这么干  </span>
</code></pre><p>commit message格式的一个模板如下，为保持原文含义，直接贴上英文版。  </p>
<pre><code>Short (<span class="number">50</span> <span class="keyword">chars</span> <span class="operator">or</span> less) summary <span class="operator">of</span> changes

More <span class="keyword">detailed</span> explanatory <span class="keyword">text</span>, <span class="keyword">if</span> necessary.  Wrap <span class="keyword">it</span> <span class="built_in">to</span>
about <span class="number">72</span> <span class="keyword">characters</span> <span class="operator">or</span> so.  In some contexts, <span class="operator">the</span> <span class="keyword">first</span>
<span class="built_in">line</span> is treated <span class="keyword">as</span> <span class="operator">the</span> subject <span class="operator">of</span> <span class="operator">an</span> email <span class="operator">and</span> <span class="operator">the</span> rest <span class="operator">of</span>
<span class="operator">the</span> <span class="keyword">text</span> <span class="keyword">as</span> <span class="operator">the</span> body.  The blank <span class="built_in">line</span> separating <span class="operator">the</span>
summary <span class="built_in">from</span> <span class="operator">the</span> body is critical (unless you omit <span class="operator">the</span> body
entirely); tools like rebase can <span class="built_in">get</span> confused <span class="keyword">if</span> you run
<span class="operator">the</span> <span class="constant">two</span> together.

Further paragraphs come <span class="keyword">after</span> blank <span class="keyword">lines</span>.

  - Bullet points are okay, too

  - Typically <span class="operator">a</span> hyphen <span class="operator">or</span> asterisk is used <span class="keyword">for</span> <span class="operator">the</span> bullet,
    preceded <span class="keyword">by</span> <span class="operator">a</span> single <span class="constant">space</span>, <span class="operator">with</span> blank <span class="keyword">lines</span> <span class="operator">in</span>
    between, but conventions vary here
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>维护一个良好的commit消息格式和规范，是一个优秀项目的重要前提。<br>本文就先来谈谈commit消息到底该怎么提交。<br>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列二：手动提交一个commit]]></title>
    <link href="http://perthcharles.github.com/2015/08/24/commit-a-simple-manually/"/>
    <id>http://perthcharles.github.com/2015/08/24/commit-a-simple-manually/</id>
    <published>2015-08-24T13:04:02.000Z</published>
    <updated>2015-08-25T03:01:40.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>想要深入的了解一个工具，就必须完一些比较hack的用法。<br>为了更好的了解git内部的工作机制，本文就试图通过手动的编辑.git目录下的<br>文件，来完成一次commit的提交。  </p>
<a id="more"></a>  

<hr>
<h3 id="-git目录下面的文件">.git目录下面的文件</h3>
<pre><code><span class="comment"># git --version  // 当前git版本</span>
    git version 2.3.2 (Apple Git-55)
<span class="comment"># ls -1 .git</span>
<span class="constant">objects</span>     &lt;= 
branches    description info    refs

<span class="constant">HEAD</span>            &lt;= 存放当前branch的HEAD指针
<span class="constant">branches</span>        &lt;= 新版git没有使用该目录
<span class="constant">config</span>          &lt;= 本地git仓库的配置文件
<span class="constant">description</span>     &lt;= 仅用于gitweb程序
<span class="constant">hooks</span>           &lt;= 一定在特定时间发生后被调用的脚本，可理解为钩子函数
<span class="constant">index</span>           &lt;= 文件暂存区信息
info/exclude    &lt;= 功能类似.gitignore的全局性排除文件
<span class="constant">objects</span>         &lt;= 存放真实的数据文件的地方，文件名是SHA1哈希值
refs/heads      &lt;= 存放各个分支的HEAD指针
refs/tags       &lt;= 存放各个tag的commit指针
refs/remotes    &lt;= 存放remote分支的HEAD指针
</code></pre><p>通过分析可以看到，对于一个普通的commit而言，比较相关的应该是objects和HEAD指针  </p>
<hr>
<h3 id="正常的commit过程">正常的commit过程</h3>
<pre><code><span class="preprocessor"># echo "hello world" &gt; hello</span>
<span class="preprocessor"># git add hello</span>
<span class="preprocessor"># git commit -am "add file"</span>
</code></pre><p>在接下来的内容中，将介绍如何在直接编辑.git目录文件的情况下达到与上面命令一样的效果。  </p>
<hr>
<h3 id="手动提交一个commit的步骤">手动提交一个commit的步骤</h3>
<p>git存储内容时，会有一个头部信息一并被保存。<br>比如如果是要存储”hello world\n”字符串，可以通过以下ruby脚本得到  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/ruby</span></div><div class="line"></div><div class="line"><span class="built_in">require</span> <span class="string">'digest/sha1'</span></div><div class="line"><span class="built_in">require</span> <span class="string">'zlib'</span></div><div class="line"><span class="built_in">require</span> <span class="string">'fileutils'</span></div><div class="line"></div><div class="line">content = <span class="string">"hello world\n"</span></div><div class="line">header = <span class="string">"blob #{content.length}\0"</span></div><div class="line">store = header + content</div><div class="line"></div><div class="line">sha1 = Digest::SHA1.hexdigest(store)</div><div class="line">puts <span class="string">"sha1:"</span> + sha1</div><div class="line"></div><div class="line">zlib_content = Zlib::Deflate.deflate(store)</div><div class="line">puts <span class="string">"zlib_contet:"</span> + zlib_content</div><div class="line"></div><div class="line">path = <span class="string">'.git/objects/'</span> + sha1[<span class="number">0</span>,<span class="number">2</span>] + <span class="string">'/'</span> + sha1[<span class="number">2</span>,<span class="number">38</span>]</div><div class="line">FileUtils.mkdir_p(File.dirname(path))</div><div class="line">File.<span class="built_in">open</span>(path, <span class="string">'w'</span>) { |f| f.<span class="built_in">write</span> zlib_content}</div></pre></td></tr></table></figure>



<p>由于hello文件的内容是”hello world\n”，因此可以通过以上脚本首先生成<br>hello文件内容对应的object文件，文件类型是blob。可以通过一下命令判断生成的文件内容是否正确  </p>
<pre><code># git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">p</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad  
# git <span class="keyword">cat</span>-<span class="keyword">file</span> -<span class="keyword">t</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad
</code></pre><p>以上的object也可以通过一下一条命令得到  </p>
<pre><code># echo <span class="string">"hello world"</span> | git hash-<span class="class"><span class="keyword">object</span> -<span class="title">w</span> --<span class="title">stdin</span></span>
</code></pre><p>随后更新生成.git/index文件  </p>
<pre><code># git <span class="keyword">update</span>-<span class="built_in">index</span> --<span class="built_in">add</span> --cacheinfo <span class="number">100644</span> <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad hello
</code></pre><p>以上步骤仅是生成了”hello world” 对应的blob文件，但并没有制定这个内容对应的<br>文件名叫什么，也就是少了tree类型的object。接着执行一下命令  </p>
<pre><code><span class="preprocessor"># git write-tree        // 生成指向3b18e5的tree文件，可以用下面两条命令验证</span>
<span class="preprocessor"># git cat-file -p 7604755fe13e27f5327d6d13dc6663d44847562d</span>
<span class="preprocessor"># git cat-file -t 7604755fe13e27f5327d6d13dc6663d44847562d</span>
</code></pre><p>一个真正的commit还需要创建一个commit类型的object指向一个特定的tree节点  </p>
<pre><code><span class="preprocessor"># git commit-tree 7604755fe -m "add file"</span>
<span class="preprocessor"># git cat-file -p df36f6b4884ecf2ec519ddec85f959a83b4adec8</span>
<span class="preprocessor"># git cat-file -t df36f6b4884ecf2ec519ddec85f959a83b4adec8</span>
</code></pre><p>接着更新master的HEAD指针  </p>
<pre><code># git <span class="operator"><span class="keyword">update</span>-ref refs/heads/<span class="keyword">master</span> df36f6b4884ecf2ec519ddec85f959a83b4adec8
# git <span class="keyword">log</span>  &lt;= 至此就能看到一个完整的<span class="keyword">commit</span> <span class="keyword">log</span>
# git checkout hello  &lt;= 将hello文件从.git库checkout出来，就算彻底的完成了一个<span class="keyword">commit</span>了</span>
</code></pre><hr>
<h3 id="总的来说">总的来说</h3>
<pre><code><span class="comment">// 第一部分是完成git add的操作  </span>
<span class="preprocessor"># echo "hello world" | git hash-object -w --stdin</span>
    <span class="number">3</span>b18e512dba79e4c8300dd08aeb37f8e728b8dad    <span class="comment">// 生成blob文件</span>
<span class="preprocessor"># git update-index --add --cacheinfo 100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad hello</span>

<span class="comment">// 第二部分是完成git  commit的操作</span>
<span class="preprocessor"># git write-tree</span>
    <span class="number">7604755</span>fe13e27f5327d6d13dc6663d44847562d    <span class="comment">// 生成tree文件</span>
<span class="preprocessor"># git commit-tree 7604755fe -m "add file"</span>
    df36f6b4884ecf2ec519ddec85f959a83b4adec8    <span class="comment">// 生成commit</span>
</code></pre><p>可以看出一个commit对应会有三种object文件生成，每种object文件的命名都是以sha1哈希值为依据的。<br>除了commit文件由于带有日期信息所以hash值会变化之外，其他两个文件的hash值都是固定不变的。  </p>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://ihower.tw/git/files/ihower-git-internal.pdf" target="_blank" rel="external">Git internal</a><br><a href="http://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" target="_blank" rel="external">Git 内部原理 - Git 对象</a><br><a href="https://gist.github.com/ihower/6132576" target="_blank" rel="external">Git commit without commit</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>想要深入的了解一个工具，就必须完一些比较hack的用法。<br>为了更好的了解git内部的工作机制，本文就试图通过手动的编辑.git目录下的<br>文件，来完成一次commit的提交。  </p>
]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[GIT系列一：使用gitolite搭建git仓库管理服务]]></title>
    <link href="http://perthcharles.github.com/2015/08/24/setup-gitolite-service-git-1/"/>
    <id>http://perthcharles.github.com/2015/08/24/setup-gitolite-service-git-1/</id>
    <published>2015-08-24T01:40:40.000Z</published>
    <updated>2015-08-25T03:55:11.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>当在工程实践中需要频繁使用git后发现，要达到真正的熟练掌握git并不是学会几个简单的git commit, git push 就能搞得定的。<br>因此开了这样一个系列，来集中梳理各种正确运用git及相关服务的要点。<br>不过既然是梳理，像那种直接man就能查到的简单用法就不会再赘述。重点在于梳理那些在使用git时会遇到的坑。<br>作为git工程实践系列的开篇，则是介绍如何使用gitolite在自己的机器上搭建git仓库管理服务。<br>只有在搭建好了一个良好的后台管理服务，才能为后续的git使用保驾护航。  </p>
<pre><code>如果是想了解git基本操作，这是一个不错的开始：[<span class="link_label">Try git</span>](<span class="link_url">https://www.codeschool.com/courses/try-git</span>)  
</code></pre><a id="more"></a>  

<hr>
<h3 id="安装gitolite">安装gitolite</h3>
<pre><code><span class="comment">// 创建专用账号</span>
@<span class="keyword">server</span> <span class="preprocessor"># adduser -m git -s /bin/bash</span>

<span class="comment">// 将客户端公钥上传服务器</span>
@admin-<span class="keyword">client</span> <span class="preprocessor"># scp ~/.ssh/id_ras.pub git@gitolite-server-ip:/home/git/admin.pub</span>

<span class="comment">// 切换到专用账号git，然后安装gitolite</span>
<span class="preprocessor"># sudo su git</span>
$ mkdir -p ~/bin
$ cd /home/git
$ git clone git:<span class="comment">//github.com/sitaramc/gitolite    // 获取gitolite</span>
$ git checkout -b newest-release v3<span class="number">.6</span><span class="number">.3</span>           <span class="comment">// 换到最新的一次release</span>
$ gitolite/install -ln ~/bin             <span class="comment">// 安装gitolite到指定目录</span>

<span class="comment">// 配置管理员公钥</span>
$ bin/gitolite setup -pk admin.pub
</code></pre><hr>
<h3 id="克隆gitolite">克隆gitolite</h3>
<p>至此可在admin-client克隆gitolite管理仓库</p>
<pre><code>@admin-<span class="keyword">client</span> <span class="preprocessor"># git clone git@gitolite-server-ip:gitolite-admin</span>

    <span class="comment">// MAC电脑下如果是新生成的id_ras.pub，则需要添加管理</span>
    @admin-<span class="keyword">client</span> <span class="preprocessor"># ssh-add -K ~/.ssh/id_ras.pub</span>

<span class="preprocessor"># cd gitolite-admin</span>
<span class="preprocessor"># ls</span>
conf    keydir        <span class="comment">// conf用于配置git项目权限，keydir用于存放git用户公钥</span>
</code></pre><hr>
<h3 id="新建GIT项目">新建GIT项目</h3>
<pre><code><span class="comment">// 回到客户端，在gitolite的配置中，增加project项目，并设置admin访问权限</span>
<span class="preprocessor"># cat conf/gitolite.conf</span>
repo gitolite-admin
    RW+     =   admin

repo testing
    RW+     =   @all

repo git-learning
    RW+     =   admin

<span class="preprocessor"># 提交对gitolite配置文件的修改</span>
<span class="preprocessor"># git commit -am 'add git project'</span>
<span class="preprocessor"># git push origin master    // 至此，管理员可在客户端克隆git@gitolite-server-ip:project</span>

<span class="comment">// 新的project.git会在执行git push自动创建，默认的目录是：/home/git/repositories</span>
</code></pre><hr>
<h3 id="新增GIT用户">新增GIT用户</h3>
<pre><code>// 将要添加的用户的公钥上传到gitolite-admin/kerdir目录下
$ <span class="keyword">ls</span> kerdir/
admin.pub <span class="keyword">new</span>.pub

// 配置用户<span class="keyword">new</span>的权限
$ <span class="keyword">cat</span> <span class="keyword">conf</span>/gitolite.<span class="keyword">conf</span>
repo gitolite-admin
    RW+     =   admin

repo testing
    RW+     =   @all

repo git-learning
    RW+     =   admin
    RW        =    <span class="keyword">new</span>

// 然后提交
$ git <span class="built_in">add</span> kerdir/<span class="keyword">new</span>.pub
$ git commit -<span class="keyword">am</span> <span class="string">'add user new for project'</span>
$ git push origin master
</code></pre><hr>
<h3 id="权限控制管理">权限控制管理</h3>
<pre><code><span class="comment">/* 实例1 */</span>  
repo project
    RW+        =    admin    <span class="comment">// admin 有读，写，强制写的权限</span>
    R        =    <span class="keyword">new</span>        <span class="comment">// new 仅有读权限，如果尝试提交会报错</span>

<span class="comment">/* 实例2 */</span> 
repo project
    RW+            =    admin    <span class="comment">// admin 有读，写，强制写的权限</span>
    <span class="comment">// new 对所有以dev开始的分支都有读写权限。即可以新建dev3，修改dev2分支 </span>
    RW    dev        =    <span class="keyword">new</span>        

<span class="comment">/* 实例3 */</span>
repo project
    RW+            =    admin
    <span class="comment">// new 仅对dev分支有写权限，$表示精确匹配</span>
    RW    dev$    =    <span class="keyword">new</span>

<span class="comment">/* 实例4 */</span>
repo project
    ...
    -    refs/tags/v[<span class="number">0</span>-<span class="number">9</span>]    = <span class="keyword">new</span>    <span class="comment">// new用户仅能创建除了以v加上数字开头之外的其他tag</span>

<span class="comment">/* 实例5 */</span>
repo project
    ...
    <span class="comment">// 除了根目录的Makefile文件外，new对其他文件都具有写权限</span>
    -    NAME/Makefile    = <span class="keyword">new</span>
    RW    Name/            = <span class="keyword">new</span>

<span class="comment">/* 推荐用法 */</span>
repo project
    <span class="comment">// 有效防止误操作：</span>
    <span class="comment">//     指定admin对branch的读写权限，防止误操作将本地的临时性branch推送到服务器端</span>
    <span class="comment">//     如果确定需要新增一个branch，则在下面新增一行，例如新增dev分支</span>
    RW+ master$     =   admin   <span class="comment">// admin 有读，写，强制写master分支的权限</span>
    RW+ dev$        =   admin   <span class="comment">// admin 有读，写，强制写dev分支的权限</span>

    RW  dev$             =  dev1 dev2     <span class="comment">// 普通developer仅能读写dev分支，且不能强制写</span>
    -   refs/tags/v[<span class="number">0</span>-<span class="number">9</span>] =  dev2 dev2     <span class="comment">// 限制普通用户不能创建以v加上数字开头的release tag</span>
    <span class="comment">// 如果不同的用户(组)分别负责完全独立的两个子系统，则可通过类似以下这种方式排除互相干扰</span>
    -   NAME/net/        =  dev1    <span class="comment">// dev1 不能修改net子系统下的文件</span>
    -   NAME/arch/       =  dev2    <span class="comment">// dev2 不能修改arch子系统下的文件</span>
</code></pre><hr>
<h3 id="配置gitweb">配置gitweb</h3>
<p>本节主要参考<a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="external">配置Gitolite+Gitweb+Nginx</a>  </p>
<pre><code><span class="comment">// 安装gitweb 和用于代码高亮的highlight</span>
$ sudo apt-get install -y gitweb highlight

<span class="comment">// 修改文件权限，用于gitweb读取</span>
$ chmod <span class="number">0027</span> /home/git.gitolite.rc
$ sudo usermod -a -G git www-data   <span class="comment">// www-data 是运行nginx服务的用户</span>
$ sudo chmod g+r    /home/git/projects.<span class="keyword">list</span>
$ sudo chmod -R g+rx /home/git/repositories

<span class="comment">// 将要显示的repo写入projects.list文件</span>
$ cat projects.<span class="keyword">list</span>
    testing.git

<span class="comment">// 修改/etc/gitweb.conf，修改以下几个关键值</span>
$ cat /etc/gitweb.conf
    <span class="comment"># path to git projects (&lt;project&gt;.git)</span>
    <span class="variable">$projectroot</span> = <span class="string">"/home/git/repositories/"</span>;

    <span class="comment"># directory to use for temp files</span>
    <span class="variable">$git_temp</span> = <span class="string">"/tmp"</span>;

    <span class="comment"># target of the home link on top of all pages</span>
    <span class="comment">#$home_link = $my_uri || "/";</span>

    <span class="comment"># html text to include at home page</span>
    <span class="comment">#$home_text = "indextext.html";</span>

    <span class="comment"># file with project list; by default, simply scan the projectroot dir.</span>
    <span class="variable">$projects_list</span> = <span class="string">"/home/git/projects.list"</span>;
    <span class="variable">$strict_export</span> = <span class="number">1</span>;

    <span class="comment"># stylesheet to use</span>
    <span class="comment">#@stylesheets = ("static/gitweb.css");</span>

    <span class="comment"># javascript code for gitweb</span>
    <span class="variable">$javascript</span> = <span class="string">"static/gitweb.js"</span>;

    <span class="comment"># logo to use</span>
    <span class="variable">$logo</span> = <span class="string">"static/git-logo.png"</span>;

    <span class="comment"># the 'favicon'</span>
    <span class="comment">#$favicon = "static/git-favicon.png";</span>

    <span class="comment"># git-diff-tree(1) options to use for generated patches</span>
    <span class="comment">#@diff_opts = ("-M");</span>
    @diff_opts = ();

    <span class="variable">$feature</span> {<span class="string">'blame'</span>}{<span class="string">'default'</span>} = [<span class="number">1</span>];
    <span class="variable">$feature</span> {<span class="string">'blame'</span>}{<span class="string">'override'</span>} = <span class="number">1</span>;

    <span class="variable">$feature</span> {<span class="string">'snapshot'</span>}{<span class="string">'default'</span>} = [<span class="string">'zip'</span>, <span class="string">'tgz'</span>];
    <span class="variable">$feature</span> {<span class="string">'snapshot'</span>}{<span class="string">'override'</span>} = <span class="number">1</span>;

    <span class="variable">$feature</span>{<span class="string">'highlight'</span>}{<span class="string">'default'</span>} = [<span class="number">1</span>];

<span class="comment">// 配置nginx</span>
$ sudo apt-get install spawn-fcgi fcgiwrap
<span class="comment">// 修改/etc/init/d/fcgi.fcgiwrap,将FCGI_USER FCGI_GROUP FCGI_SOCKET_OWNER FCGI_SOCKET_GROUP 都修改为运行web服务的用户</span>
<span class="comment">// 在nginx的配置文件中添加一个新的server段</span>
    server {
        listen <span class="number">80</span>;
        server_name gitweb.example.com;
        access_log  /home/wwwlogs/access.log  main;

        location / {
            root /usr/share/gitweb;
            index index.cgi;
            <span class="keyword">include</span> fastcgi_params;
            gzip off;
            fastcgi_param GITWEB_CONFIG /etc/gitweb.conf;

            <span class="keyword">if</span> (<span class="variable">$uri</span> ~ <span class="string">"/index.cgi"</span>) {
                fastcgi_pass unix:/<span class="keyword">var</span>/run/fcgiwrap.socket;
            }
        }
    }

<span class="comment">// 重启fcgiwrap和nginx</span>
$ sudo service fcgiwrap restart
$ sudo nginx -s reload
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.ossxp.com/doc/git/gitolite.html" target="_blank" rel="external">Gitolite 构建 Git 服务器</a><br><a href="http://zodiacg.net/2014/05/gitolite_gitweb_nginx/" target="_blank" rel="external">配置Gitolite+Gitweb+Nginx</a><br><a href="http://gitolite.com/gitolite/gitolite.html" target="_blank" rel="external">gitolite all-in-one page</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>当在工程实践中需要频繁使用git后发现，要达到真正的熟练掌握git并不是学会几个简单的git commit, git push 就能搞得定的。<br>因此开了这样一个系列，来集中梳理各种正确运用git及相关服务的要点。<br>不过既然是梳理，像那种直接man就能查到的简单用法就不会再赘述。重点在于梳理那些在使用git时会遇到的坑。<br>作为git工程实践系列的开篇，则是介绍如何使用gitolite在自己的机器上搭建git仓库管理服务。<br>只有在搭建好了一个良好的后台管理服务，才能为后续的git使用保驾护航。  </p>
<pre><code>如果是想了解git基本操作，这是一个不错的开始：[<span class="link_label">Try git</span>](<span class="link_url">https://www.codeschool.com/courses/try-git</span>)  
</code></pre>]]>
    
    </summary>
    
      <category term="git" scheme="http://perthcharles.github.com/tags/git/"/>
    
      <category term="wiki-GIT" scheme="http://perthcharles.github.com/categories/wiki-GIT/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[像linux kernel一样管理你的项目]]></title>
    <link href="http://perthcharles.github.com/2015/08/14/manage-project-code-like-linux-kernel/"/>
    <id>http://perthcharles.github.com/2015/08/14/manage-project-code-like-linux-kernel/</id>
    <published>2015-08-14T02:34:06.000Z</published>
    <updated>2015-08-14T09:47:29.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>坚持良好的代码管理习惯，将极大的帮助我们做出更好的项目。<br>本文用于记录如何有效的使用git进行代码管理，像诸多优秀的项目一样。<br>本文尤其适合需要向其他项目提交patch的情形。不懂这句话的请参考标题，哈哈。  </p>
<a id="more"></a>  

<hr>
<h3 id="1-_如何正确的对待commit_？">1. 如何正确的对待commit ？</h3>
<p>commit是一个项目的变更史，如何维持一个高质量的commit log对于项目的质量<br>至关重要。<br>那么什么样的commit log是合格的呢？  </p>
<h4 id="1-1_避免初级的错误">1.1 避免初级的错误</h4>
<pre><code><span class="array"># git diff </span>--check   <span class="comment">// identifies possible whitespace errors  </span>
</code></pre><h4 id="1-2_坚持一个commit对应一个功能">1.2 坚持一个commit对应一个功能</h4>
<p>这点在实践的过程中可能很难满足，但是git提供了其他的方式让你可以在事后<br>进行弥补<a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external">[1]</a>。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。<br>尽管如此，这些弥补措施只能在将代码与他人共享(git push)之前使用。  </p>
<pre><code>// 方式1：修改最近的一次<span class="operator"><span class="keyword">commit</span>信息  
// 同时也会将已进行的更改添加进入修改后的<span class="keyword">commit</span>  
// 典型应用场景：<span class="keyword">commit</span>后才发现遗漏了某个文件  
# git <span class="keyword">commit</span> <span class="comment">--amend  </span>

// 方式<span class="number">2</span>：修改最近的多次<span class="keyword">commit</span>信息  
// 正式使用该方法前，最好用一个测试分支先体验一下。  
# git rebase -i HEAD~n    // 修改最近的n个<span class="keyword">commit</span>  
&lt;&lt; 将需要被修改的<span class="keyword">commit</span>信息对应行的<span class="string">"pick"</span>改为<span class="string">"edit"</span>  
# git <span class="keyword">commit</span> <span class="comment">--amend      // 真实的修改选择的commit信息  </span>
# git rebase <span class="comment">--continue   // 让rebase自动完成后续(未修改)的commit  </span>

// 方式<span class="number">3</span>：将最近的多个<span class="keyword">commit</span>替换为一个<span class="keyword">commit</span>
# git rebase -i HEAD~n  
&lt;&lt; 将需要被合并的前n-<span class="number">1</span>个<span class="keyword">commit</span>对应行的<span class="string">"pick"</span>改为<span class="string">"squash"</span>  
&lt;&lt; 之后会自动进入修改<span class="keyword">commit</span>的文本编辑页面，让你编辑新的<span class="keyword">commit</span> message  

// 方式<span class="number">4</span>：使用相对人工的方式合并多个<span class="keyword">commit</span>  
# git <span class="keyword">reset</span> <span class="comment">--soft HEAD~n  // 使用soft选项，仅将commit log回退n个记录  </span>
# git <span class="keyword">commit</span> -a // 提交正式的<span class="keyword">commit</span> message  </span>
</code></pre><h4 id="1-3_使用更规范的commit_message格式">1.3 使用更规范的commit message格式</h4>
<p>在确保了一个commit对应一个功能后，最后就是确保commit message的规范性了。<br>首先贴一下写一个合格commit message的规则，最后贴一下Tim Pope给出来的一个<br>模板<a href="http://git-scm.com/book/ch5-2.html" target="_blank" rel="external">[2]</a>。  </p>
<pre><code>第一行用一句简短的话总结这个<span class="operator"><span class="keyword">commit</span>  

第一行最好用一个描述性的前缀开始，比如  
  <span class="string">"net:"</span>表示针对net子系统的修改  
  <span class="string">"fix:"</span>表示这是一个bug fix  

第二行为空行

最后可以增加一些详细的描述，用以解释<span class="keyword">commit</span>具体干了什么，为什么这么干  </span>
</code></pre><p>commit message格式的一个模板如下，为保持原文含义，直接贴上英文版。  </p>
<pre><code>Short (<span class="number">50</span> <span class="keyword">chars</span> <span class="operator">or</span> less) summary <span class="operator">of</span> changes

More <span class="keyword">detailed</span> explanatory <span class="keyword">text</span>, <span class="keyword">if</span> necessary.  Wrap <span class="keyword">it</span> <span class="built_in">to</span>
about <span class="number">72</span> <span class="keyword">characters</span> <span class="operator">or</span> so.  In some contexts, <span class="operator">the</span> <span class="keyword">first</span>
<span class="built_in">line</span> is treated <span class="keyword">as</span> <span class="operator">the</span> subject <span class="operator">of</span> <span class="operator">an</span> email <span class="operator">and</span> <span class="operator">the</span> rest <span class="operator">of</span>
<span class="operator">the</span> <span class="keyword">text</span> <span class="keyword">as</span> <span class="operator">the</span> body.  The blank <span class="built_in">line</span> separating <span class="operator">the</span>
summary <span class="built_in">from</span> <span class="operator">the</span> body is critical (unless you omit <span class="operator">the</span> body
entirely); tools like rebase can <span class="built_in">get</span> confused <span class="keyword">if</span> you run
<span class="operator">the</span> <span class="constant">two</span> together.

Further paragraphs come <span class="keyword">after</span> blank <span class="keyword">lines</span>.

  - Bullet points are okay, too

  - Typically <span class="operator">a</span> hyphen <span class="operator">or</span> asterisk is used <span class="keyword">for</span> <span class="operator">the</span> bullet,
    preceded <span class="keyword">by</span> <span class="operator">a</span> single <span class="constant">space</span>, <span class="operator">with</span> blank <span class="keyword">lines</span> <span class="operator">in</span>
    between, but conventions vary here
</code></pre><hr>
<h3 id="2-_如何通过commit生成patch_？">2. 如何通过commit生成patch ？</h3>
<p>在得到合格的commit log后，则可以通过commit log直接得到想要的patch。<br>这里推荐使用format-patch格式的，理由自行理解。  </p>
<pre><code><span class="comment">// 生成前两个commit对应的patch，一个commit生成一个patch  </span>
<span class="comment">//     -s 表示添加签名</span>
<span class="comment">//     -n 表示patch里面会有[patch n/m]类似的标记 </span>
<span class="preprocessor"># git format-patch -sn -2</span>
<span class="comment">// 与上一条命令含义相同</span>
<span class="preprocessor"># git format-patch -sn HEAD HEAD~2..HEAD  </span>
<span class="comment">// 忽略掉diff里面的prefix  </span>
<span class="preprocessor"># git format-patch -sn --no-prefix -1  </span>
</code></pre><p>由于git format-patch会将每一个commit单独生成一个patch，这也就更加依赖<br>在上一步中是否严格控制好commit log的风格了。  </p>
<hr>
<h3 id="3-_如何检查patch的代码风格？">3. 如何检查patch的代码风格？</h3>
<p>坚持良好的代码风格是长久做项目的基石，所以在提交patch前最好自行检查好<br>代码是否符合目标项目的代码风格。<br>以Linux kernel为例，它提供了scripts/checkpatch.pl脚本用于检查代码风格。  </p>
<pre><code><span class="preprocessor"># scripts/checkpatch.pl PATCH-NAME</span>
<span class="preprocessor"># scripts/checkpatch.pl --terse PATCH-NAME   // 生成简单的报告  </span>
</code></pre><hr>
<h3 id="4-_如何使用tag管理重要的发行版？">4. 如何使用tag管理重要的发行版？</h3>
<p>项目在进行到一定阶段后，可能需要对外进行发布。长久下来，实际作业环境下<br>可能同时使用着不同的发布版本。但是项目本身的git管理肯定不会同时维护多<br>个分支。当然要求项目的所有开发人员都凭脑力记住特定发型版本对应的commit<br>也不太现实。这就是我理解的tag的用途：通过tag标识诸多发行版本与git仓库<br>某个时期状态的关系。<br>git中tag分为lightweight tag和annotated tag，建议仅使用annotated tag。<br>以下便是tag常见的用法：  </p>
<pre><code><span class="array"># git tag                </span><span class="comment">// 显示当前所有的tag  </span>
<span class="array"># git tag </span>-l <span class="string">'v1.0.*'</span>    <span class="comment">// 仅显示满足特定pattern的tag  </span>

<span class="array"># git tag </span>-a v1<span class="number">.5</span> -m <span class="string">'my version 1.5'</span>   <span class="comment">// 创建一个带标签的tag  </span>
<span class="array"># git tag </span>-a v1<span class="number">.6</span>        <span class="comment">// 如果不适用-m，则会进入文本编辑器进行编辑  </span>

<span class="array"># git show v</span>1<span class="number">.5</span>          <span class="comment">// 查看v1.5的信息  </span>

<span class="array"># git log </span>--pretty=oneline      <span class="comment">// 查看commit log  </span>
<span class="array"># git tag </span>-a v1<span class="number">.7</span> abcdef        <span class="comment">// 为特定的commit添加tag</span>

<span class="array"># git push origin v</span>1<span class="number">.7</span>   <span class="comment">// 提交tag v1.7  </span>
<span class="array"># git push origin </span>--tags <span class="comment">// 提交所有的tag</span>

<span class="array"># git checkout </span>-b version <span class="number">2.0</span> v2<span class="number">.0</span>   <span class="comment">// 新建一个branch查看v2.0源码  </span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html" target="_blank" rel="external">A Note About Git Commit Messages</a><br><a href="http://git-scm.com/book/ch5-2.html" target="_blank" rel="external">Distributed Git - Contributing to a Project</a><br><a href="http://git-scm.com/book/en/v2/Git-Tools-Rewriting-History" target="_blank" rel="external">Git Tools - Rewriting History</a><br><a href="http://linux.koolsolutions.com/2011/02/26/howto-create-and-submit-your-first-linux-kernel-patch/" target="_blank" rel="external">HOWTO: Create and submit your first Linux kernel patch using GIT</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>坚持良好的代码管理习惯，将极大的帮助我们做出更好的项目。<br>本文用于记录如何有效的使用git进行代码管理，像诸多优秀的项目一样。<br>本文尤其适合需要向其他项目提交patch的情形。不懂这句话的请参考标题，哈哈。  </p>
]]>
    
    </summary>
    
      <category term="Git" scheme="http://perthcharles.github.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ISO镜像配置yum源]]></title>
    <link href="http://perthcharles.github.com/2015/07/08/iso-yum/"/>
    <id>http://perthcharles.github.com/2015/07/08/iso-yum/</id>
    <published>2015-07-08T01:28:18.000Z</published>
    <updated>2015-07-08T01:47:57.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="问题">问题</h2>
<hr>
<p>在无网络连接时，需要安装常见的工具软件。如果每次都先下好然后拷贝到这台机器，则太繁琐。何况很多常见的工具看似简单，但却有许多依赖，从源码安装太麻烦而且易出错。最典型的例子就是GCC（不要问我是怎么知道的T_T）  </p>
<a id="more"></a>  

<h2 id="解决方法">解决方法</h2>
<hr>
<p>目前常见的Linux发行版本的ISO镜像都可以在挂载后配置为yum源。这样就能直接从ISO镜像中带的rpm包中安装到大部分常用的软件。以下以CentOS 6.5为例进行说明：  </p>
<p>第一步：下载CentOS6.5的ISO镜像<br>第二步：挂载ISO镜像  </p>
<pre><code><span class="preprocessor"># mkdir -p /cdrom/iso  </span>
<span class="preprocessor"># mount -o loop ISO-FILE-PATH /cdrom/iso</span>
</code></pre><p>第三步：配置yum源  </p>
<pre><code><span class="comment"># cd /etc/yum.repos.d</span>
<span class="comment"># mkdir BAK; mv *.repo BAK  // 备份现有yum源配置  </span>
<span class="comment"># vim ISO.repo  </span>
  [base]
  <span class="variable">name=</span>CentOS-ISO1
  <span class="variable">baseurl=</span>file:///cdrom/iso
  <span class="variable">enabled=</span><span class="number">1</span>
  <span class="variable">gpgcheck=</span><span class="number">1</span>
  <span class="variable">gpgkey=</span>file:///cdrom/iso/RPM-GPG-KEY-CentOS-<span class="number">6</span>
</code></pre><p>第四步：检查yum源配置  </p>
<pre><code><span class="preprocessor"># yum list  </span>
</code></pre><p>至此应该能看到ISO镜像中RPM包已经配置好了yum源。对于CentOS6.5来说，可以看到它有repodata文件夹，这意味着它的ISO镜像能够直接配置为yum源而不用额外的动作。<br>而如果ISO没有repodata文件夹或手头仅有RPM包时，则需要借助辅助工具createrepo来创建正确的yum源。<br>在安装好createrepo后，仅需在RPM包所在的目录执行以下命令就可以创建一个可用的yum源。  </p>
<pre><code><span class="preprocessor"># createrepo .</span>
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://blog.csdn.net/gzh0222/article/details/6724142" target="_blank" rel="external">如何使用yum工具从iso镜像文件上安装</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="问题">问题</h2>
<hr>
<p>在无网络连接时，需要安装常见的工具软件。如果每次都先下好然后拷贝到这台机器，则太繁琐。何况很多常见的工具看似简单，但却有许多依赖，从源码安装太麻烦而且易出错。最典型的例子就是GCC（不要问我是怎么知道的T_T）  </p>
]]>
    
    </summary>
    
      <category term="yum" scheme="http://perthcharles.github.com/tags/yum/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Random early detection]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-tcp-random-early-drop/</id>
    <published>2015-06-18T09:05:52.000Z</published>
    <updated>2015-06-18T10:03:06.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resources/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikipedia.org/?title=Random_early_detection" target="_blank" rel="external">Random Early Detection: wiki</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是RED机制的工作原理流程图<br><img src="/resources/RED_algorithm.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://en.wikipe]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Understand the Performance of Pacing]]></title>
    <link href="http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/"/>
    <id>http://perthcharles.github.com/2015/06/18/wiki-network-paper-understand-the-performance-of-pacing/</id>
    <published>2015-06-18T05:20:22.000Z</published>
    <updated>2015-06-18T09:56:26.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br><a id="more"></a>  </p>
<h2 id="1-_What_is_Pacing_?">1. What is Pacing ?</h2>
<hr>
<p>TCP的数据发送目前有三种策略：<br>a. ACK-Clocking: 这是Linux TCP/IP协议栈现有的实现策略。每一个数据包的发送<br>都是由收到的确认包触发的。当数据确认包ACK由于网络拥塞无法及时达到发送端时，<br>发送方是不会发送数据的，除非timeout。总的来说就是，ack控制数据发送的时机，<br>min(cwnd, rwnd)控制发送数据的多少。  </p>
<p>b. Rate-based: pure的rate-based的方法使用一个估计的瓶颈链路带宽rate来控制<br>数据发送的多少和时机。  </p>
<p>c. Pacing: pacing算是以上两种方法的一个hybrid。pure的rate-based的方法最大的<br>缺点就是可能造成瓶颈链路的over-subscribed，而不能及时的发现。而在Pacing方法<br>中，发送数据量的多少还是由min(cwnd, rwnd)控制，而数据的发送时机则由timer控制。<br>timer控制的目的就是保证在一个RTT内，数据是比较平滑的发送出去的。  </p>
<h2 id="why_needs_pacing_?">why needs pacing ?</h2>
<hr>
<p>Pacing的提出主要是为了解决传统协议栈中存在的bursty transmission的情况。<br>文章总结的TCP中可能产生burst的情况有：  </p>
<pre><code><span class="tag">a</span>. <span class="tag">Slow</span> <span class="tag">Start</span>：慢启动阶段<span class="tag">cwnd</span>的增长是指数级的  
<span class="tag">b</span>. <span class="tag">Losses</span>: 当<span class="tag">rwnd</span>用完后，在丢包发生时无法发送新数据，重传结束后会引发<span class="tag">burst</span>。  
  <span class="tag">Note</span>: 这种<span class="tag">burst</span>可以用<span class="tag">opportunistic</span> <span class="tag">retransmission</span> 解决 <span class="pseudo">:)</span>  
<span class="tag">c</span>. <span class="tag">ACK</span> <span class="tag">Compression</span>: 当存在双向的数据流时，<span class="tag">ACK</span>包可能会在瓶颈链路中排队，破坏<span class="tag">ack-clocking</span>机制。  
<span class="tag">d</span>. <span class="tag">Multiplexing</span>: 当多条流共享一个高速瓶颈链路时，尽管同一条流数据包可能到达瓶颈链路的时间不同(细小的维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>)，但当数据包经历在瓶颈链路排队后，维持<span class="tag">ack-clocking</span>的<span class="tag">gap</span>被完全的破坏了。最终导致的结果就是数据包的发送都是突发性的。  
</code></pre><h2 id="Results">Results</h2>
<hr>
<p>Pacing的实现：  </p>
<pre><code>Timeouts are scheduled <span class="keyword">at</span> regular intervals <span class="operator">of</span> duration RTT/window.  
A packet is transmitted <span class="built_in">from</span> <span class="operator">the</span> window whenever <span class="operator">the</span> timer fires.  
</code></pre><p>单条流的情况：  </p>
<pre><code>a. 当瓶颈链路<span class="keyword">buffer</span>小于BDP时，reno会更早的遭遇丢包，因此pacing在throughput方面表现更好  
b. 当瓶颈链路<span class="keyword">buffer</span>超过BDP时，pacing的throughput更差，这主要是由于pacing会delay congestion <span class="keyword">signal</span>  
</code></pre><p>多条流的情况：  </p>
<pre><code><span class="keyword">a</span>. 在initial period，reno反而性能更好。主要是pacing流几乎同时丢包造成的性能下降，即synchronization effect现象。  
    synchronization effect：pacing流由于将数据包打散，当瓶颈链路<span class="keyword">buffer</span>溢出时，  
    许多pacing流都会产生丢包，进而许多pacing流都会下降cwnd。  
    而reno由于数据包相对是以burst的形式发送的，要么有一条流丢很多包，  
    要么可能某些流一个包都不丢。 

<span class="keyword">b</span>. 在steady state，pacing反而性能更好。主要是de-synchronization effect现象导致的。  
    de-synchronization effect：在稳定状态，Reno每个RTT会将cwnd加<span class="number">1</span>。  
    在<span class="keyword">buffer</span>用满后，每个Reno流多发的这个数据包(burst最后一个包)很大概率就会<span class="keyword">drop</span>。  
    而pacing由于将数据包打散了，丢包的发生有一定的随机性。对于单条pacing流而言就可能没有包被<span class="keyword">drop</span>  
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p>Understanding the Performance of TCP Pacing, INFOCOM’2000  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章给出了对于TCP Pacing技术的详细评测分析结果。<br>对于pacing想要解决的问题和实际效果给出了详细的实验数据分析，是理解pacing<br>技术的一篇很好的入门文章。<br>]]>
    
    </summary>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP FRTO机制]]></title>
    <link href="http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/"/>
    <id>http://perthcharles.github.com/2015/06/16/wiki-network-tcp-frto/</id>
    <published>2015-06-16T10:16:18.000Z</published>
    <updated>2015-06-16T10:23:07.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.csdn.net/zhangskd/article/details/7446441" target="_blank" rel="external">FRTO—虚假超时剖析</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>下图是根据参考文献整理的FRTO选项的工作机制流程图<br><img src="/resources/TCP-FRTO.png" alt="">  </p>
<h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://blog.]]>
    </summary>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[服务器负载压力测试相关工具]]></title>
    <link href="http://perthcharles.github.com/2015/06/15/server-load-test/"/>
    <id>http://perthcharles.github.com/2015/06/15/server-load-test/</id>
    <published>2015-06-15T02:30:56.000Z</published>
    <updated>2015-07-07T03:33:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <span class="string">multiprocessing http test client  </span>
<span class="attribute">SIEGE</span>: <span class="string">http load testing and benchmarking utility</span>
<span class="attribute">webbench</span>: <span class="string">据文档描述，可以monitor3万个并发连接去测试网站的负载能力  </span>
<span class="attribute">ab</span>: <span class="string">apache benchmark，Apache自带的测试工具  </span>
</code></pre><h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://acme.com/software/http_load/" target="_blank" rel="external">HTTP_LOAD homepage</a><br><a href="https://www.joedog.org/siege-home/" target="_blank" rel="external">SIEGE homepage</a><br><a href="http://home.tiscali.cz/~cz210552/webbench.html" target="_blank" rel="external">Web Bench 1.5</a><br><a href="http://httpd.apache.org/docs/2.2/programs/ab.html" target="_blank" rel="external">ab - Apache HTTP server benchmarking tool</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="工具列表">工具列表</h2>
<hr>
<p>下面这些工具都比较小巧，用法也比较简单。<br>基本看看—help就知道怎么用了。  </p>
<pre><code><span class="attribute">HTTP_LOAD</span>: <s]]>
    </summary>
    
      <category term="http_load" scheme="http://perthcharles.github.com/tags/http-load/"/>
    
      <category term="test" scheme="http://perthcharles.github.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TC 实践]]></title>
    <link href="http://perthcharles.github.com/2015/06/12/tc-tutorial/"/>
    <id>http://perthcharles.github.com/2015/06/12/tc-tutorial/</id>
    <published>2015-06-12T01:32:51.000Z</published>
    <updated>2015-06-15T02:30:38.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br><a id="more"></a>  </p>
<h2 id="队列类型">队列类型</h2>
<hr>
<p>Linux内核中支持的常见队列有：  </p>
<ol>
<li>pfifo_fast: 先进先出队列<br><img src="/resources/tc-fifo-qdisc.png" alt=""><br><img src="/resources/tc-pfifo_fast-qdisc.png" alt="">  </li>
<li>TBF(Token Bucket Filter): 令牌桶过滤器<br><img src="/resources/tc-tbf-qdisc.png" alt="">  </li>
<li>SFQ(Stochastic Fairness Queueing): 随机公平队列<br><img src="/resources/tc-sfq-qdisc.png" alt="">  </li>
<li>HTB(Hierarchy Token Bucket): 分层令牌桶<br><img src="/resources/tc-htb-borrow.png" alt="">  </li>
</ol>
<h2 id="TC应用场景">TC应用场景</h2>
<hr>
<p>本节摘抄自<a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/overview.html" target="_blank" rel="external">Traffic Control HOWTO</a>.  </p>
<pre><code>Common traffic control solutions  
  <span class="number">1.</span> Limit total bandwidth <span class="built_in">to</span> <span class="operator">a</span> known rate; TBF, HTB <span class="operator">with</span> child class(es).
  <span class="number">2.</span> Limit <span class="operator">the</span> bandwidth <span class="operator">of</span> <span class="operator">a</span> particular user, service <span class="operator">or</span> client; HTB classes <span class="operator">and</span> classifying <span class="operator">with</span> <span class="operator">a</span> <span class="built_in">filter</span>. traffic.
  <span class="number">3.</span> Maximize TCP throughput <span class="command"><span class="keyword">on</span> <span class="title">an</span> <span class="title">asymmetric</span> <span class="title">link</span>; <span class="title">prioritize</span> <span class="title">transmission</span> <span class="title">of</span> <span class="title">ACK</span> <span class="title">packets</span>, <span class="title">wondershaper</span>.</span>
  <span class="number">4.</span> Reserve bandwidth <span class="keyword">for</span> <span class="operator">a</span> particular application <span class="operator">or</span> user; HTB <span class="operator">with</span> children classes <span class="operator">and</span> classifying.
  <span class="number">5.</span> Prefer latency sensitive traffic; PRIO inside <span class="operator">an</span> HTB class.
  <span class="number">6.</span> Managed oversubscribed bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">7.</span> Allow equitable distribution <span class="operator">of</span> unreserved bandwidth; HTB <span class="operator">with</span> borrowing.
  <span class="number">8.</span> Ensure that <span class="operator">a</span> particular type <span class="operator">of</span> traffic is dropped; policer attached <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">filter</span> <span class="operator">with</span> <span class="operator">a</span> drop action.
</code></pre><h2 id="实践案例">实践案例</h2>
<hr>
<h3 id="pfifo_fast">pfifo_fast</h3>
<p>pfifo_fast是系统默认的队列类型，只起到调度的作用，不对数据流量进行控制。<br>其中pfifo中的p是packet的缩写，表示queue的大小计量单位为packet。<br>可以通过ip命令查看当前网络队列设置  </p>
<pre><code><span class="preprocessor"># ip link list</span>
</code></pre><h3 id="TBF">TBF</h3>
<p>TBF队列通过设置令牌的产生速度来限制数据包的发送。  </p>
<pre><code><span class="comment">// 在eth0上设置一个tbf队列，网络带宽为200kbit，延迟50ms，缓冲区为1540个字节</span>
<span class="comment">// rate表示令牌的产生速率</span>
<span class="comment">// latency表示数据包在队列中的最长等待时间</span>
<span class="comment">// 对burst参数解释一下：</span>
<span class="comment">//   burst means the maximum amount of bytes that tokens can be available for instantaneously.</span>
<span class="comment">//   如果数据包的到达速率与令牌的产生速率一致，即200kbit，则数据不会排队，令牌也不会剩余</span>
<span class="comment">//   如果数据包的到达速率小于令牌的产生速率，则令牌会有一定的剩余。</span>
<span class="comment">//   如果后续某一会数据包的到达速率超过了令牌的产生速率，则可以一次性的消耗一定量的令牌。</span>
<span class="comment">//   burst就是用于限制这“一次性”消耗的令牌的数量的，以字节数为单位。</span>
<span class="preprocessor"># tc qdisc add dev eth0 root tbf rate 200kbit latency 50ms burst 1540  </span>

<span class="preprocessor"># tc qdisc ls dev eth0 // 查看eth0上的队列规则  </span>
</code></pre><h3 id="SFQ">SFQ</h3>
<p>SFQ队列通过一个hash函数将不同会话(如TCP流)分到不同的FIFO队列中，从而保证<br>数据流的公平性。  </p>
<pre><code><span class="comment">// perturb表示每10秒更新一次hash函数  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root sfq perturb 10  </span>
</code></pre><h3 id="HTB">HTB</h3>
<pre><code><span class="comment">// handle是一组用户指定的标示符，格式为major:minor。  </span>
<span class="comment">// 如果是一条queueing discipline，minor需要一直为0。  </span>
<span class="preprocessor"># tc qdisc add dev eth0 root handle 1:0 htb  </span>

<span class="comment">// parent指明该新增的class添加到那一个父handle上去  </span>
<span class="comment">// classid指明该class handle的唯一ID，minor需要是非零值  </span>
<span class="comment">// ceil定义rate的上界  </span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:6 htb rate 256kbit ceil 512kbit</span>

<span class="comment">// 新建一个带宽为100kbps的root class, 其classid为1:1</span>
<span class="preprocessor"># tc class add dev eth0 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps</span>
<span class="comment">// 接着建立两个子class，指定其parent为1:1，ceil用来限制子类最大的带宽</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:10 htb rate 40kbps ceil 100kbps</span>
<span class="preprocessor"># tc class add dev eth0 parent 1:1 classid 1:11 htb rate 60kbps ceil 100kbps</span>
<span class="comment">// 随后建立filter指定哪些类型的packet进入那个class</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 match ip dport 80 0xffff flowid 1:10</span>
<span class="preprocessor"># tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32 match ip src 1.2.3.4 flow 1:11</span>
<span class="comment">// 最后为这些class添加queuing disciplines</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:10 handle 20: pfifo limit 5</span>
<span class="preprocessor"># tc qdisc add dev eth0 parent 1:11 handle 30: sfq perturb 10</span>
</code></pre><h3 id="其他">其他</h3>
<pre><code><span class="comment">// 同时模拟20Mbps带宽，50msRTT和0.1%丢包率  </span>
<span class="preprocessor"># tc qdisc add dev eth5 root handle 1:0 tbf rate 20mbit burst 10kb limit 300000  </span>
<span class="preprocessor"># tc qdisc add dev eth5 parent 1:0 handle 10:0 netem delay 50ms loss 0.1 limit 300000  </span>
</code></pre><h2 id="Rules,_Guidelines_and_Approaches">Rules, Guidelines and Approaches</h2>
<hr>
<p>‘’’<br>A device can only shape traffic in transmits<br>HTB is an ideal qdisc to use on a link with a know bandwidth<br>In theory, the PRIO scheduler is an ideal match for links with variable bandwidth<br>Sharing/splitting bandwidth based on flows or IP<br>‘’’</p>
<h2 id="参考资料">参考资料</h2>
<hr>
<p><a href="http://www.turbolinux.com.cn/turbo/wiki/doku.php?id=traffic-control:tc%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86%E7%AE%80%E4%BB%8B" target="_blank" rel="external">traffic-control:tc流量管理简介</a><br><a href="http://tldp.org/HOWTO/Traffic-Control-HOWTO/index.html" target="_blank" rel="external">Traffic Control HOWTO</a><br><a href="http://luxik.cdi.cz/~devik/qos/htb/manual/userg.htm" target="_blank" rel="external">HTB Linux queuing discipline manual - user guide</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="TC简介">TC简介</h2>
<hr>
<p>TC全称为Traffic Control，是Linux进行流量控制的工具。<br>更多的内容可阅读参考资料中的第一篇文章。<br>]]>
    
    </summary>
    
      <category term="tc" scheme="http://perthcharles.github.com/tags/tc/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[技艺培养(基于知道创宇技能表v2.2)]]></title>
    <link href="http://perthcharles.github.com/2015/05/07/skill-list/"/>
    <id>http://perthcharles.github.com/2015/05/07/skill-list/</id>
    <published>2015-05-07T10:36:53.000Z</published>
    <updated>2015-05-10T15:46:01.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre><a id="more"></a>  

<h3 id="通用技能">通用技能</h3>
<h4 id="公司与个人">公司与个人</h4>
<ul>
<li>[X] 公司是盈利组织  </li>
<li>[X] 个人与公司必须双赢  </li>
<li>[X] 个人：在认同公司理念且能够为公司创造足够价值的基础上，<strong>为个人发展而工作</strong>    </li>
</ul>
<h4 id="沟通、反馈、责任">沟通、反馈、责任</h4>
<ul>
<li>[X] 一个无沟通能力的人，要么是天才，要么是不可爱的人  </li>
<li>[X] 反馈要及时  <ul>
<li>[X] 避免出问题不反馈，影响进度  </li>
<li>[X] 方式  <ul>
<li>[X] 正式的：邮件  </li>
<li>[X] 临时的：QQ等即时通信  </li>
<li>[X] 礼貌的：给个电话，短信  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 工作有大小，责任心无大小  </li>
<li>[X] 周报的透明  <ul>
<li>[X] 意义：大家互相了解工作与心得，有利于自己的判断与成长  </li>
<li>[X] 不是单纯的给领导汇报工作  </li>
</ul>
</li>
</ul>
<h4 id="任务四象限，决定优先级">任务四象限，决定优先级</h4>
<ul>
<li>[X] 紧急重要  </li>
<li>[X] 重要不紧急  </li>
<li>[X] 紧急不重要  </li>
<li>[X] 不紧急不重要  </li>
</ul>
<h4 id="新事物的敏感性">新事物的敏感性</h4>
<ul>
<li>[X] 保持好奇心  </li>
<li>[X] 不要局限在自己的圈子，适当跨界吸收灵感  </li>
<li>[X] 订阅国内外优秀博客/资源（详见附录一）  <ul>
<li>[X] 鲜果RSS，Readkit，Pocket和Evernote等工具  </li>
<li>[X] 英文很重要  </li>
</ul>
</li>
<li>[X] 选择性的参与一些必要的回忆，听必要的主题，讨论必要的话题  </li>
</ul>
<h4 id="成长">成长</h4>
<ul>
<li>[X] 对知识的渴望程度决定了前进动力的大小  <ul>
<li>[X] 对知识保持狂热和贪婪。为避免过度，因此也需要学会甄别和取舍。</li>
</ul>
</li>
<li>[X] 不要矫情，不要浮夸  </li>
<li>[X] 和比你厉害的人在一起，和一流的人工作  <ul>
<li>[X] 指点往往是精华  </li>
<li>[X] 杜绝笨蛋爆炸：二流的人招进来的人不太可能是一流的  </li>
</ul>
</li>
<li>[X] 思考  <ul>
<li>[X] 批判性思考  </li>
<li>[X] 换位思考  </li>
</ul>
</li>
<li>[X] 提问的智慧     <ul>
<li>[X] 遇到问题先独立思考，尽最大努力后再提问  </li>
</ul>
</li>
<li>[X] 小事心态  <ul>
<li>[X] 越基础的事越关键，需要越细心  </li>
<li>[X] 不要一味盲目追求”高级感”，而忽视”小事”/“简单事”/“基础事”</li>
<li>[X] 基础不牢，地动山摇  </li>
<li>[X] 小事做不好，别提大事  </li>
</ul>
</li>
<li>[ ] 任务拆分  — 逐步领会<ul>
<li>[X] 成长过程会经历：能力越大、责任越大、事情越多  </li>
<li>[X] 思路  <ul>
<li>[X] 拆分细化为多个点  </li>
<li>[X] 排好优先级  — 参考”任务四象限”  </li>
<li>[X] 加入时间维度：何时完成什么  — 参考”完成的定义”</li>
<li>[X] 是否需要寻求帮助，谁能帮你，自己单干？ — 参考”沟通、反馈、责任”  </li>
<li>[X] 任务是否可以切换/并发  </li>
<li>[X] 自己缺陷什么，立马发现  </li>
</ul>
</li>
</ul>
</li>
<li>[ ] 方法论  — 逐步领会<ul>
<li>[X] 完成一件事有好几条途径，优秀的人能选出最短的一条  </li>
<li>[X] 任务拆分很容易得出做事的方法论  </li>
<li>[X] 好的”方法论”会让你具备更强的”创造力”  </li>
</ul>
</li>
</ul>
<h4 id="牛人姿态">牛人姿态</h4>
<ul>
<li>[X] 即使现在不是牛人，也得具备这样的姿态  </li>
<li>[X] 这种感觉只能意会  </li>
<li>[X] 没有一定扎实内功与远见的人，很少有这样的姿态  </li>
</ul>
<h4 id="完成的定义">完成的定义</h4>
<ul>
<li>[ ] 比如写个POC  </li>
<li>搞懂了目标WEB应用漏洞的原理  </li>
<li>熟练运用Python各相关模块和机制  </li>
<li>熟练了解了HTTP协议：HTTP请求，HTTP相应  </li>
<li>代码写的够规范，让人看起来就是爽  </li>
<li>程序经过足够的测试：黑/白测试  </li>
<li>及时反馈进度  <ul>
<li>我遇到困难了</li>
<li>我搞定了  </li>
</ul>
</li>
<li>更新相关文档，沉淀  </li>
</ul>
<h4 id="熟练的定义">熟练的定义</h4>
<ul>
<li>[ ] 比如熟练SQL注入  <ul>
<li>SQL语句这门”语言”能脱离文档顺手写出  </li>
<li>主流数据库的SQL特有函数、存储过程、机制我都了如指掌  <ul>
<li>MySQL/MSSQL/Oracal/Postgre/Access/SQLite/…  </li>
</ul>
</li>
<li>牛逼的工具我不仅用的顺其自然，源码还读过几遍，我能修改  <ul>
<li>sqlmap/…  </li>
</ul>
</li>
<li>我具备创造性，而不仅仅是跟在大牛身后  <ul>
<li>研究出了几个不错的技巧  </li>
<li>发了几篇不错的paper  </li>
<li>对外会议/沙龙等进行了几次分享  </li>
<li>写出了自己的相关工具，爽  </li>
</ul>
</li>
<li>我实战了N回，遇到了许多奇葩环境，我有足够的信心饶过  </li>
<li>以上这些之后，这才叫熟练！其他同理  </li>
</ul>
</li>
</ul>
<h4 id="好书推荐">好书推荐</h4>
<ul>
<li>[X] 推荐理由  <ul>
<li>[X] 打通任督二脉的书，怎能不看？  </li>
<li>[X] 任何科学研究最终必须至少到哲学层面，触碰到上帝的脚  </li>
<li>[X] 具体技术类书籍请见”专业技能”相关部分  </li>
</ul>
</li>
<li>[ ] 鸡汤类  <ul>
<li>[ ] 黑客与画家  </li>
<li>[X] 浪潮之巅</li>
<li>[X] MacTalk</li>
</ul>
</li>
<li>[ ] 洁癖类  <ul>
<li>[ ] 重构  </li>
<li>[ ] 代码整洁之道  </li>
<li>[ ] 代码大全2  </li>
<li>[X] 数学之美</li>
<li>[X] 编写可读代码的艺术  </li>
</ul>
</li>
<li>[ ] 敏捷类  <ul>
<li>[ ] Rework中文版：37signals团队的敏捷经验  </li>
<li>[ ] 高效程序员的45个习惯  </li>
</ul>
</li>
<li>[ ] 产品类  <ul>
<li>[ ] 人人都是产品经理  </li>
<li>[ ] 结网  </li>
</ul>
</li>
<li>[ ] 神书  <ul>
<li>[ ] 自私的基因  </li>
<li>[ ] 失控  </li>
<li>[ ] 万物由来  </li>
</ul>
</li>
</ul>
<hr>
<h3 id="专业技能">专业技能</h3>
<h4 id="原则">原则</h4>
<ul>
<li>[X] 至少完整看完与练习好一本书  </li>
<li>[X] 至少过一遍官方文档  </li>
</ul>
<h4 id="基础必备">基础必备</h4>
<p>HTTP抓包与调试  </p>
<ul>
<li>[ ] Fiddler: 浏览器代理神器  </li>
<li>[X] wireshark + tshark(terminal wireshark， 脚本分析trace利器)  </li>
<li>[X] tcpdump  </li>
</ul>
<p>编码规范  </p>
<ul>
<li>[X] C/C++  </li>
<li>[ ] Python  </li>
</ul>
<p>office能力  </p>
<ul>
<li>[X] Word文档编写，看上去要专业，尤其对外的  </li>
<li>[X] Excel里面大量的统计、图标功能，需要善于使用  </li>
<li>[X] PPT演讲，培训等必备，如何做好PPT？Google一下。。。  </li>
<li>[X] 进一步：Visio，FreeMind, Latex, Markdown  </li>
</ul>
<p>熟练VIM  </p>
<p>算法  </p>
<ul>
<li>[X] 详见<a href="http://en.wikipedia.org/wiki/List_of_algorithms" target="_blank" rel="external">List of algorithms</a>  </li>
<li>[X] 熟练掌握常见算法和数据结构  </li>
<li>[X] 了解常见高级算法和数据结构，如红黑树，跳表，bloom filter等  </li>
</ul>
<p>正则表达式  </p>
<ul>
<li>[ ] 调试工具：Kodos，RegexBuddy</li>
<li>[ ] 各种正则表达式入门资料，自行Google。。。  </li>
</ul>
<p>研发能力  </p>
<ul>
<li>[X] 瀑布模型：需求-&gt;需求分析-&gt;设计-&gt;开发-&gt;测试-&gt;上线-&gt;运维/运营  </li>
<li>[X] 需求分析能力  <ul>
<li>[X] 给你一个需求，如何给出一个优美的执行思路  — 方法论  </li>
<li>[X] 这个能力非常非常的关键  </li>
</ul>
</li>
<li>[X] 调试能力  <ul>
<li>[X] 只要能定位，就没有解决不了的BUG  </li>
<li>[X] 肉眼看到的都是假象  <ul>
<li>[X] 一定要专业的工具与经验配合  </li>
</ul>
</li>
<li>[X] BUG在哪出现，最终就在哪进行真实模拟调试  </li>
<li>[X] 缩小范围  <ul>
<li>[X] 构建自己的测试样例：排除网络复杂未知情况  </li>
<li>[X] 关联模块一个个排除  </li>
<li>[X] 单步调试</li>
<li>[X] 粗暴调试：print  </li>
</ul>
</li>
</ul>
</li>
<li>[X] 敏捷思想  <ul>
<li>[X] 快速迭代  </li>
<li>[X] 任务拆细  </li>
<li>[X] V1原则：定义好V1的目标，快速完成V1为优先  </li>
<li>[X] 习惯WIKI记录，利于沉淀和分享  — 个人选择：博客  </li>
</ul>
</li>
</ul>
<p>翻墙  </p>
<ul>
<li>[X] Goagent, VPN, VPS, SSH Tunnel, shadowsock…  </li>
</ul>
<h4 id="Web安全">Web安全</h4>
<ul>
<li>[ ] 书  <ul>
<li>[ ] 黑客攻防技术宝典（WEB实战篇）  </li>
<li>[ ] 白帽子讲WEB安全  </li>
<li>[ ] WEB前端黑客技术揭秘  </li>
<li>[ ] SQL注入攻击与防御  </li>
</ul>
</li>
<li>[ ] Papers  <ul>
<li>[ ] <a href="https://www.exploit-db.com/papers/" target="_blank" rel="external">Offensive security exploit database archive</a>  </li>
</ul>
</li>
</ul>
<h4 id="研发清单">研发清单</h4>
<p>编码环境  </p>
<ul>
<li>[ ] pip  </li>
<li>[ ] vagrant  </li>
<li>[X] tmux/screen  </li>
<li>[X] vim  </li>
<li>[ ] zsh + oh-my-zsh  </li>
<li>[X] python 2.7  </li>
<li>[ ] &gt;Django 1.4  </li>
<li>[ ] web.py  </li>
<li>[ ] node.js  </li>
<li>[X] ubuntu/gentoo/centos  </li>
<li>[ ] ipython  </li>
<li>[X] 版本控制：git/svn  </li>
<li>[ ] nginx + uWSGI  </li>
</ul>
<p>Python: 官方手册  </p>
<ul>
<li>[X] 至少过一遍，这都没过一遍，视野会局限  </li>
<li>[X] 行之说：”我没看过Python的书，却熟读官方手册”  </li>
</ul>
<p>Linux：熟练使用常见命令和shell脚本  </p>
<ul>
<li>[ ] 高级Bash脚本编程指南 Mendel Cooper  </li>
<li>[ ] Linux设备驱动第三版  </li>
</ul>
<p>前端：JavaScript DOM编程艺术  </p>
<p>爬虫进阶  </p>
<ul>
<li>[ ] 代理池：爬虫”稳定”需要  </li>
<li>[ ] 网络请求  <ul>
<li>[X] wget/curl  </li>
<li>[ ] urllib2/httplib2/requests  </li>
<li>[ ] scrapy  </li>
</ul>
</li>
<li>[ ] 验证码破解：pytesser  </li>
</ul>
<p>调度  </p>
<ul>
<li>[X] crontab是最原生的定时调度  </li>
<li>[ ] 基于redis实现的分布式调度  </li>
<li>[ ] 就rpyc实现的分布式调度  </li>
<li>[ ] celery/gearman等调度框架  </li>
</ul>
<p>并发  </p>
<ul>
<li>[X] 线程池：进程内优美的并发方案  </li>
<li>[ ] 协程：进程内另一种优美的并发方案  </li>
<li>[X] 多线程：os.fork, multiprocessing  </li>
</ul>
<p>数据结构  </p>
<ul>
<li>[X] JSON</li>
<li>[ ] cPickle  </li>
<li>[ ] protobuf  </li>
</ul>
<p>数据库  </p>
<ul>
<li>[ ] MySQL  </li>
<li>[ ] MongoDB  </li>
<li>[ ] Cassandra  </li>
<li>[ ] Hadoop体系  </li>
<li>[ ] Redis  </li>
<li>[ ] Sqlite  </li>
</ul>
<p>调试  </p>
<ul>
<li>[ ] gdb, pdb  </li>
<li>[X] logging  </li>
<li>[ ] Sentry  </li>
<li>[ ] strace/ltrace  </li>
<li>[X] lsof  </li>
<li>[X] 性能  <ul>
<li>[ ] Python性能分析指南  </li>
<li>[X] top/htop/free/iostat/vmstat/ifconfig…  </li>
</ul>
</li>
</ul>
<p>持续集成  </p>
<ul>
<li>[ ] 自测试：nose  </li>
<li>[ ] Jenkins  </li>
</ul>
<p>协作：Trello, WeiXin  </p>
<h4 id="设计思想">设计思想</h4>
<ul>
<li>[ ] 人人都是架构师：具备架构思想是一件多酷的事  </li>
<li>[X] 实战出真知  — 100%认同啊，且适用于任何技术领域  </li>
<li>[ ] 如何设计  <ul>
<li>[ ] 松耦合，紧内聚  </li>
<li>[ ] 单元与单元属性  </li>
<li>[X] 生产者与消费者  </li>
<li>[X] 结构：队列/LRU  </li>
<li>[ ] 分布式：存储、计算</li>
<li>[X] 资源考虑：CPU, 内存，带宽  </li>
</ul>
</li>
</ul>
<h4 id="牛人1，2，3">牛人1，2，3</h4>
<ul>
<li>[X] 1研究：研究东西，有足够的洞察力，研究水准不错  </li>
<li>[X] 2研发：hack idea自己有魄力实现，不懂研发的黑客如同不会游泳的海盗  </li>
<li>[X] 3工程：研发出来的需要实战、需要工程化，否则只是玩具，而不能成为真正的武器  </li>
</ul>
<hr>
<hr>
<h3 id="附录一：国内外优秀博客/资源">附录一：国内外优秀博客/资源</h3>
<hr>
<p>说道这个点，首先必须吐槽一下Google reader的关闭，其次吐槽一下现在快消费讯息的泛滥！  </p>
<ul>
<li>阮一峰的网络日志  </li>
<li>Vimer的程序世界  </li>
<li>阳志平的网志  </li>
<li>[推荐]弯曲评论  </li>
<li>酷壳CoolShell.cn  </li>
<li>[推荐]伯乐在线-博客  </li>
<li>月光博客  </li>
<li>IT技术博客大学习  </li>
<li>WooYun知识库  </li>
<li>PingWest  </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>说明：  
<span class="bullet">1. </span>该checklist主要基于知道创宇的研发技能表v2.2制作，算是个人技能发展的一个roadmap吧。  

<span class="bullet">2. </span>该清单需要逐步的结合自身的经历和经验，进行调整。毕竟这并不是通用列表。  

<span class="bullet">3. </span>个人重点关注网络相关领域。    
</code></pre>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux内核编码风格]]></title>
    <link href="http://perthcharles.github.com/2015/05/06/coding-style/"/>
    <id>http://perthcharles.github.com/2015/05/06/coding-style/</id>
    <published>2015-05-06T09:49:38.000Z</published>
    <updated>2015-05-10T04:59:31.000Z</updated>
    <content type="html"><![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p><a id="more"></a>  </p>
<h3 id="缩进">缩进</h3>
<hr>
<p>所有的缩进均应是8字符格式。</p>
<pre><code><span class="keyword">If</span> you need more than <span class="number">3</span> levels indentation, you<span class="attribute">'re</span> screwed anyway, <span class="keyword">and</span> should 
fix your program.
</code></pre><p>注：关于这点保留意见，目前我(也)比较习惯用4字符格式的TAB。  </p>
<pre><code>Don't <span class="keyword">put</span> multiple assignments <span class="function_start"><span class="keyword">on</span></span> a single line.

Get a decent editor <span class="keyword">and</span> don't leave whitespace <span class="keyword">at</span> <span class="keyword">the</span> <span class="keyword">end</span> <span class="keyword">of</span> lines.
</code></pre><h3 id="换行">换行</h3>
<hr>
<p>每行的长度限制在80各字符</p>
<pre><code>However， never <span class="keyword">break</span> user-visible strings such <span class="keyword">as</span> printk <span class="keyword">messages</span>, because 
that breaks the ability <span class="keyword">to</span> <span class="keyword">grep</span> <span class="keyword">for</span> them.  
</code></pre><h3 id="括号和空格">括号和空格</h3>
<hr>
<pre><code>As shown <span class="built_in">to</span> us <span class="keyword">by</span> <span class="operator">the</span> prophets Kernighan <span class="operator">and</span> Ritchie, <span class="operator">the</span> preferred way is <span class="built_in">to</span> 
<span class="built_in">put</span> <span class="operator">the</span> opening brace <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">line</span>, <span class="title">and</span> <span class="title">push</span> <span class="title">the</span> <span class="title">closing</span> <span class="title">brace</span> <span class="title">first</span>, <span class="title">thusly</span>:</span>
<span class="keyword">if</span> (x is <span class="constant">true</span>) {
        we <span class="built_in">do</span> y
}
</code></pre><p>上面的规则适用于所有的代码块，除了函数。  </p>
<pre><code><span class="keyword">Do</span> <span class="keyword">not</span> unnecessarily use braces <span class="keyword">where</span> a <span class="built_in">single</span> statement will <span class="keyword">do</span>.

        <span class="keyword">if</span> (condition)
                action();

<span class="keyword">and</span>
        <span class="keyword">if</span> (condition)
                do_this();
        <span class="keyword">else</span>
                do_that();

This does <span class="keyword">not</span> apply <span class="keyword">if</span> only one branch <span class="keyword">of</span> a conditional statement <span class="keyword">is</span> a <span class="built_in">single</span> 
statement; <span class="keyword">in</span> the latter <span class="keyword">case</span> use braces <span class="keyword">in</span> both braches.
</code></pre><p>注：这个规则我保留意见。由于任何under-developing的代码片段都没办法保证在“现在和将来”都仅包含一条语句。因此我的选择是：在任何代码片段/分支处，均使用括号。  </p>
<p>在Linux kernel的编程风格中，空格的使用主要依赖于function-versus-keyword的使用。</p>
<pre><code><span class="operator"><span class="keyword">Use</span> a <span class="keyword">space</span> <span class="keyword">after</span> (most) keywords.
The notable exceptions <span class="keyword">are</span> sizeof, typeof, alignof, <span class="keyword">and</span> __attribute__,
which look somewhat <span class="keyword">like</span> functions.

<span class="keyword">Do</span> <span class="keyword">not</span> <span class="keyword">add</span> spaces around (inside) parenthesized expressions.

<span class="keyword">When</span> declaring pointer <span class="keyword">data</span> <span class="keyword">or</span> a <span class="keyword">function</span> that <span class="keyword">returns</span> a pointer type, the 
preferred usd <span class="keyword">of</span> <span class="string">'*'</span> <span class="keyword">is</span> adjacent <span class="keyword">to</span> the <span class="keyword">data</span> name <span class="keyword">or</span> <span class="keyword">function</span> name <span class="keyword">and</span> <span class="keyword">not</span> 
adjacent <span class="keyword">to</span> the type name. Examples:
    <span class="built_in">char</span> *line_banner;</span>
    char *match__strdup(substring_t *s);

<span class="operator"><span class="keyword">Use</span> one <span class="keyword">space</span> around (<span class="keyword">on</span> <span class="keyword">each</span> side <span class="keyword">of</span>) most <span class="built_in">binary</span> <span class="keyword">and</span> ternary operators, 
but <span class="keyword">no</span> <span class="keyword">space</span> <span class="keyword">after</span> unary operators.</span>
</code></pre><h3 id="命名">命名</h3>
<hr>
<pre><code>GLOBAL variables need to have descriptive names, as <span class="operator"><span class="keyword">do</span> <span class="keyword">global</span> functions.

Encoding the types <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">into</span> the name (so-called Hungarian notaion) 
<span class="keyword">is</span> brain damaged - the compiler knows the types anyway <span class="keyword">and</span> can <span class="keyword">check</span> those, <span class="keyword">and</span> 
it <span class="keyword">only</span> confuses the programmer. <span class="keyword">No</span> wonder MicroSoft makes buggy programs.
=.= 黑的漂亮  

<span class="keyword">LOCAL</span> variable <span class="keyword">names</span> should be short, <span class="keyword">and</span> <span class="keyword">to</span> the point.</span>
</code></pre><h3 id="自定义类型">自定义类型</h3>
<hr>
<p>typedefs应尽量少用。仅在满足一下条件之一时，typedefs才算是能适当提高可读性的选择。</p>
<ul>
<li>totally opaque objects (where the typedef is actively used to _hide_ what the<br>object is).  </li>
<li>clear integer types, where the abstaction _helps_ avoid confusion whether it<br>is ‘int’ or ‘long’. 例如 u8/u16/u32就是很好的抽象  </li>
<li>when you use sparse to literally create a _new_ type for type-checking.<br>— 暂时不太理解:-(  </li>
<li>New types which are identical to standard C99 types, in certain exceptional<br>circumstances.  </li>
<li>Types safe for use in userspace. — 暂时不太理解:-(  </li>
</ul>
<h3 id="函数">函数</h3>
<hr>
<pre><code>Functions should be short and sweet, and <span class="operator"><span class="keyword">do</span> just one thing. 
They should fit <span class="keyword">on</span> one <span class="keyword">or</span> two screenfuls <span class="keyword">of</span> <span class="built_in">text</span>.

The maximum length <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> inversely proportional <span class="keyword">to</span> the complexity 
<span class="keyword">and</span> indentation <span class="keyword">level</span> <span class="keyword">of</span> that <span class="keyword">function</span>.
<span class="comment">-- 当函数逻辑简单时，稍微长一点没有关系；</span>
<span class="comment">-- 当函数逻辑复杂时，可以通过helper函数缩短函数的长度。同时如果需要考虑性能，inline是个不错的选择。</span>

Another measure <span class="keyword">of</span> the <span class="keyword">function</span> <span class="keyword">is</span> the <span class="built_in">number</span> <span class="keyword">of</span> <span class="keyword">local</span> <span class="keyword">variables</span>. 
They shouldn<span class="string">'t exceed 5-10, or you'</span>re doing something wrong.
依据：A human brain can generally easily keep track about <span class="number">7</span> different things.

<span class="keyword">In</span> source file, seperate functions <span class="keyword">with</span> one blank line.

<span class="keyword">If</span> the <span class="keyword">function</span> <span class="keyword">is</span> exported, the EXPORT macro <span class="keyword">for</span> it should follow immediately 
<span class="keyword">after</span> the closing <span class="keyword">function</span> brace line.

<span class="keyword">In</span> <span class="keyword">function</span> prototype, include parameter <span class="keyword">names</span> <span class="keyword">with</span> their <span class="keyword">data</span> types.</span>
</code></pre><h3 id="集中管理函数的退出条件">集中管理函数的退出条件</h3>
<hr>
<p>这部分主要是讨论goto的实用技巧(goto反对党请绕道)。  </p>
<pre><code>The <span class="keyword">goto</span> statement comes <span class="keyword">in</span> handy <span class="keyword">when</span> a <span class="keyword">function</span> exits <span class="keyword">from</span> multiple locations 
<span class="keyword">and</span> some common works such <span class="keyword">as</span> cleanup has <span class="keyword">to</span> be done.

Choose label names which say what the <span class="keyword">goto</span> does <span class="keyword">or</span> why the <span class="keyword">goto</span> exits.
</code></pre><p>goto语句在以下情况下，可以合理的使用：  </p>
<ul>
<li>unconditional statements are easier to understand and follow  </li>
<li>nesting is reduced  </li>
<li>errors by not updating individual exit points when making modifications are prevented — 暂时不理解:-(  </li>
<li>save the compiler work to optimize redundant code away  </li>
</ul>
<h3 id="注释">注释</h3>
<hr>
<p>这部分主要是一些避免over-commenting的原则。  </p>
<pre><code>NEVER <span class="keyword">try</span> <span class="keyword">to</span> explain HOW your code works <span class="keyword">in</span> a commment:
<span class="keyword">it</span>'s much better <span class="keyword">to</span> <span class="command">write</span> <span class="keyword">the</span> code so <span class="keyword">the</span> \_working\_ <span class="keyword">is</span> obvious, <span class="keyword">and</span> <span class="keyword">it</span>'s a 
waste <span class="keyword">of</span> <span class="property">time</span> <span class="keyword">to</span> explain badly written code.

Generally, you want your comments <span class="keyword">to</span> <span class="keyword">tell</span> WHAT your code <span class="keyword">does</span>, <span class="keyword">not</span> HOW. <span class="comment">--发人深省啊！</span>

Try <span class="keyword">to</span> avoid putting comments inside a function body.
Instead, <span class="keyword">put</span> <span class="keyword">the</span> comments <span class="keyword">at</span> <span class="keyword">the</span> head <span class="keyword">of</span> <span class="keyword">the</span> function, telling people what <span class="keyword">it</span> <span class="keyword">does</span>,
<span class="keyword">and</span> possibly WHY <span class="keyword">it</span> <span class="keyword">does</span> <span class="keyword">it</span>.  

Linux style <span class="keyword">for</span> comments <span class="keyword">is</span> <span class="keyword">the</span> C89 <span class="string">"/* ... */"</span> style.
Don't use C99-style <span class="string">"// ..."</span> comments.

The preferred style <span class="keyword">for</span> long (multi-line) comments <span class="keyword">is</span>:
/*
 * This <span class="keyword">is</span> <span class="keyword">the</span> preferred style <span class="keyword">for</span> multi-line
 * comments <span class="keyword">in</span> <span class="keyword">the</span> Linux kernel source code.
 * Please use <span class="keyword">it</span> consistently.
 */
</code></pre><h3 id="宏，枚举">宏，枚举</h3>
<hr>
<pre><code>Names <span class="operator">of</span> macros defining constants <span class="operator">and</span> labels <span class="operator">in</span> enums are capitalized.

Enums are preferred when defining serveral related constants.

CAPITALIZED macro names are appreciated but macros resembling functions may be  
named <span class="operator">in</span> <span class="built_in">lower</span> <span class="keyword">case</span>.

Generally, inline functions are preferable <span class="built_in">to</span> macros resembling functions. <span class="comment">-- 个人更认同这一原则。</span>

Macros <span class="operator">with</span> multiple statements should be eclosed <span class="operator">in</span> <span class="operator">a</span> <span class="built_in">do</span>-which block.
</code></pre><h3 id="打印内核消息">打印内核消息</h3>
<pre><code>Make the messages concise, clear, <span class="keyword">and</span> unambiguous.

<span class="keyword">For</span> messages that aren<span class="comment">'t associated with a particular device, <span class="xmlDocTag">&lt;linux/printk.h&gt;</span> </span>
defines pr_notice(), pr_info(), pr_warn(), pr_err(), etc.
</code></pre><h3 id="inline的使用">inline的使用</h3>
<hr>
<pre><code>Abundant use <span class="operator">of</span> <span class="operator">the</span> inline keyword leads <span class="built_in">to</span> <span class="operator">a</span> much bigger kernel, which <span class="operator">in</span> turn 
slows <span class="operator">the</span> <span class="keyword">system</span> <span class="keyword">as</span> <span class="operator">a</span> <span class="keyword">whole</span> down, due <span class="built_in">to</span> <span class="operator">a</span> bigger icache footprint <span class="keyword">for</span> <span class="operator">the</span> CPU 
<span class="operator">and</span> simply because there is less memory available <span class="keyword">for</span> <span class="operator">the</span> pagecache.

A reasonable rule <span class="operator">of</span> thumb is <span class="built_in">to</span> <span class="operator">not</span> <span class="built_in">put</span> inline <span class="keyword">at</span> functions that have more 
than <span class="number">3</span> <span class="keyword">lines</span> <span class="operator">of</span> code <span class="operator">in</span> them.  <span class="comment">--即，inline应限制用于小函数 </span>
</code></pre><h3 id="函数返回值">函数返回值</h3>
<hr>
<pre><code><span class="keyword">If</span> the name <span class="keyword">of</span> a <span class="keyword">function</span> <span class="keyword">is</span> an action <span class="keyword">or</span> an imperative command, the <span class="keyword">function</span> 
should <span class="keyword">return</span> an <span class="keyword">error</span>-code <span class="built_in">integer</span>.
<span class="keyword">If</span> the name <span class="keyword">is</span> a predicate, the <span class="keyword">function</span> should <span class="keyword">return</span> a <span class="string">"succeeded"</span> <span class="built_in">boolean</span>.
</code></pre><h3 id="不要重复发明内核宏定义">不要重复发明内核宏定义</h3>
<pre><code>The header <span class="built_in">file</span> <span class="built_in">include</span>/linux/kernel.h <span class="operator">contains</span> <span class="operator">a</span> <span class="built_in">number</span> <span class="operator">of</span> macros that you 
should use, rather than explicitly coding some variant <span class="operator">of</span> them yourself.
</code></pre><h3 id="条件编译">条件编译</h3>
<hr>
<pre><code>Wherever possible, don't <span class="operator"><span class="keyword">use</span> preprocessor conditional (#<span class="keyword">if</span>, #ifdef) <span class="keyword">in</span> .c files, 
doing so makes code harder <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">and</span> logic harder <span class="keyword">to</span> follow.

Prefer <span class="keyword">to</span> compile out entire functions, rather than portions <span class="keyword">of</span> functions <span class="keyword">or</span> 
portions <span class="keyword">of</span> expressions.

Within code, <span class="keyword">where</span> possible, <span class="keyword">use</span> the IS_ENABLED macro <span class="keyword">to</span> <span class="keyword">convert</span> a Kconfig 
symbol <span class="keyword">into</span> a C <span class="built_in">boolean</span> expression, <span class="keyword">and</span> <span class="keyword">use</span> it <span class="keyword">in</span> a normal C conditional.

<span class="keyword">At</span> the <span class="keyword">end</span> <span class="keyword">of</span> <span class="keyword">any</span> non-trivial #<span class="keyword">if</span> <span class="keyword">or</span> #ifdef block (more than a few <span class="keyword">lines</span>), 
place a comment <span class="keyword">after</span> the #endif <span class="keyword">on</span> the same line, noting the conditional 
expression used. <span class="keyword">For</span> instance:
    #ifdef CONFIG_SOMETHING
    ...
    #endif <span class="comment">/* CONFIG_SOMETHING */</span></span>
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="https://www.kernel.org/doc/Documentation/CodingStyle" target="_blank" rel="external">Linux kernel coding style</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<pre><code>Coding style <span class="keyword">is</span> <span class="keyword">all</span> about readability <span class="built_in">and</span> maintainability using commonly available tools.  
</code></pre><p>]]>
    
    </summary>
    
      <category term="wiki-编程技艺" scheme="http://perthcharles.github.com/categories/wiki-%E7%BC%96%E7%A8%8B%E6%8A%80%E8%89%BA/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Alfred 使用记录]]></title>
    <link href="http://perthcharles.github.com/2015/03/27/alfred/"/>
    <id>http://perthcharles.github.com/2015/03/27/alfred/</id>
    <published>2015-03-27T07:34:58.000Z</published>
    <updated>2015-05-10T04:57:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br><a id="more"></a>  </p>
<hr>
<h3 id="1-_搜索">1. 搜索</h3>
<hr>
<p>Alfred的核心功能之一就是搜索，所以先简单介绍一下。<br>默认的热键组合是：option + space。<br>比如你想打开chrome浏览器，就可以直接在Alfred中输入chrome了。<br>相比于Spotlight它的显示结果更简单，更易于操作（特别是你想要的结果不是第一个结果时）。  </p>
<p>下面查找文件的方法来自<a href="http://macshuo.com/?p=625" target="_blank" rel="external">http://macshuo.com/?p=625</a>, 其实就是先输个空格，囧。  </p>
<pre><code>简单查找文件：用快捷键呼出Alfred，键入空格，输入你要查找文件名，
即可定位文件，回车打开，<span class="command"><span class="keyword">command</span>+回车打开文件所在文件夹。</span>
</code></pre><h3 id="2-_自定义搜索">2. 自定义搜索</h3>
<hr>
<p>上面只是搜索本地的资源，如果你想在某个特定网站进行搜索呢？<br>Alfred同样提供的custom search的功能，具体的方法可参考<a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br>我自己的案例就是用这个功能实现了在github中进行搜索。具体步骤如下：  </p>
<pre><code><span class="number">1</span>. 进入github页面，在输入框中随便输入一个关键字  
<span class="number">2</span>. 在得到的页面链接中，将你的关键字替换为{query}  
   如：https:<span class="comment">//github.com/search?utf8=%E2%9C%93&amp;q={query}  </span>
<span class="number">3</span>. 依次进入：Alfred的配置-&gt;Features -&gt;Web Search -&gt; Add custom search  
<span class="number">4</span>. 将search URL填写为第二步中得到的链接，其他表项也比较直观。  
   如：我的keyword设为了git, 这样我以后只要在Alfred中输入<span class="string">"git keyword"</span>
       就能直接在默认浏览器中打开github上面的搜索结果。  
</code></pre><h3 id="3-_我还是太年轻了">3. 我还是太年轻了</h3>
<hr>
<p>Alfred真是过于强大了，而且有不少作者总结的很好。这篇文章就写到这里吧，把参考资料都大概瞄一瞄，跟着学一遍基本差不多了。  </p>
<h3 id="4-_我的需求">4. 我的需求</h3>
<hr>
<p>算是TODO list吧，等学完了再回来填坑。  </p>
<pre><code><span class="number">0</span>. 学会用Python写workflow
<span class="number">1</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> VPN
<span class="number">2</span>. workflo<span class="variable">w:</span> <span class="keyword">open</span>/<span class="keyword">close</span> wifi AP
</code></pre><h3 id="参考资料">参考资料</h3>
<hr>
<p><a href="http://zhuanlan.zhihu.com/pinapps/19985861" target="_blank" rel="external">如何使用Alfred提升操作效率</a><br><a href="http://zhuanlan.zhihu.com/pinapps/19986749" target="_blank" rel="external">用Alfred大幅提升操作效率 - workflow</a><br><a href="https://github.com/hzlzh/AlfredWorkflow.com" target="_blank" rel="external">Alfred workflow collection</a><br><a href="http://wellsnake.com/jekyll/update/2014/06/15/001/" target="_blank" rel="external">丢掉鼠标－Mac神软Alfred使用手册1</a><br><a href="http://www.alfredworkflow.com/" target="_blank" rel="external">Alfred workflow list</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>最早是在MacTalk 中了解到的Alfred，但一直仅仅是把它当做一个启动软件的快捷方式来用。<br>趁着在网上看到了几个比较精彩的帖子，发现之前真实太浪费Alfred了。<br>本文就记录一下我从中学到的一些使用Alfred的技巧。<br>Alfred官网：<a href="http://www.alfredapp.com/" target="_blank" rel="external">http://www.alfredapp.com/</a><br>]]>
    
    </summary>
    
      <category term="Tools" scheme="http://perthcharles.github.com/tags/Tools/"/>
    
  </entry>
  
</feed>
