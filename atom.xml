<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[天赋  无与伦比的坚持]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://perthcharles.github.com/"/>
  <updated>2015-11-17T02:55:56.859Z</updated>
  <id>http://perthcharles.github.com/</id>
  
  <author>
    <name><![CDATA[Perth Charles]]></name>
    <email><![CDATA[zhongbincharles@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[使用ntopng监控网络信息]]></title>
    <link href="http://perthcharles.github.com/2015/11/15/wiki-tool-ntopng/"/>
    <id>http://perthcharles.github.com/2015/11/15/wiki-tool-ntopng/</id>
    <published>2015-11-15T10:43:43.000Z</published>
    <updated>2015-11-15T14:46:43.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>ntopng(ntop next generation)能够有效的监控网络信息，<br>即使是free版本功能也十分强大。  </p>
<a id="more"></a>  

<hr>
<h3 id="安装">安装</h3>
<p>在MAC上安装ntopng  </p>
<pre><code><span class="preprocessor"># brew install ntopng   // 失败，坑！</span>

<span class="comment">/* install nDPI */</span>
<span class="preprocessor"># git clone https://github.com/ntop/nDPI.git</span>
<span class="preprocessor"># cd nDPI; ./autogen.sh; make</span>

<span class="comment">/* install MYSQL */</span>
<span class="preprocessor"># brew install mysql</span>

<span class="comment">/* install ntopng */</span>
<span class="preprocessor"># wget http://sourceforge.net/projects/ntop/files/ntopng/ntopng-2.0.tar.gz/download</span>
<span class="preprocessor"># move download ntopng-2.0.tar.gz; tar zxvf ntopng-2.0.tar.gz</span>
<span class="preprocessor"># cd ntopng-2.0; ./autogen.sh; ./configure;</span>
<span class="preprocessor"># make; make geoip</span>
</code></pre><hr>
<h3 id="运行ntopng">运行ntopng</h3>
<pre><code><span class="array"># redis</span>-server          <span class="comment">// 在一个terminal开启redis-server</span>
<span class="array"># ntopng                </span><span class="comment">// 在另一个terminal开启ntopng</span>
</code></pre><p>之后网页打开localhost:3000，然后使用默认账号(admin)和密码(admin)登陆即可  </p>
<hr>
<h3 id="ntopng常用用法">ntopng常用用法</h3>
<pre><code><span class="operator">a</span>. 指定监听网卡
    <span class="comment"># ntopng -i eth0,eth1</span>

b. Ntopng is also able <span class="built_in">to</span> compute statistics based <span class="command"><span class="keyword">on</span> <span class="title">pcap</span> <span class="title">traffic</span> <span class="title">files</span></span>
    <span class="comment"># ntopng -i example.pcap</span>
</code></pre><p>更多的使用方法，可查看参考资料中的user guide  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://github.com/ntop/ntopng/blob/dev/doc/UserGuide.pdf" target="_blank" rel="external">Ntopng User Guide</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>ntopng(ntop next generation)能够有效的监控网络信息，<br>即使是free版本功能也十分强大。  </p>
]]>
    
    </summary>
    
      <category term="ntopng" scheme="http://perthcharles.github.com/tags/ntopng/"/>
    
      <category term="wiki-tools" scheme="http://perthcharles.github.com/categories/wiki-tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[获取亚太地区IP库]]></title>
    <link href="http://perthcharles.github.com/2015/11/15/apnic-ip-list/"/>
    <id>http://perthcharles.github.com/2015/11/15/apnic-ip-list/</id>
    <published>2015-11-15T08:11:36.000Z</published>
    <updated>2015-11-15T09:59:12.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>想要玩转网络，当然得要有一些基本的数据来源，这篇就先介绍一下如何获得某地区的IP库  </p>
<a id="more"></a>  

<hr>
<h3 id="获取最新的亚太地区IP库">获取最新的亚太地区IP库</h3>
<pre><code><span class="array"># wget http</span>:<span class="comment">//ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest  </span>
</code></pre><hr>
<h3 id="抽取CN地区的IP库">抽取CN地区的IP库</h3>
<pre><code><span class="comment"># cat parsh.sh</span>
<span class="shebang">#!/bin/sh</span>
<span class="comment"># Get IP allocated to CN</span>
grep <span class="string">'apnic|CN|ipv4'</span> delegated-apnic-latest |
cut <span class="operator">-f</span> <span class="number">4</span>,<span class="number">5</span> <span class="operator">-d</span> <span class="string">'|'</span> |
tr <span class="string">'|'</span> <span class="string">' '</span> |
awk <span class="string">'{
    ip=$1;
    mask = 32 - log($2)/log(2);
    print ip"/"mask
}'</span> &gt; china-ip-list.txt

<span class="comment"># head -n 5 china-ip-list.txt</span>
<span class="number">1.0</span>.<span class="number">1.0</span>/<span class="number">24</span>
<span class="number">1.0</span>.<span class="number">2.0</span>/<span class="number">23</span>
<span class="number">1.0</span>.<span class="number">8.0</span>/<span class="number">21</span>
<span class="number">1.0</span>.<span class="number">32.0</span>/<span class="number">19</span>
<span class="number">1.1</span>.<span class="number">0.0</span>/<span class="number">24</span>
</code></pre><hr>
<h3 id="使用whois查看IP具体归属">使用whois查看IP具体归属</h3>
<pre><code><span class="comment"># whois 1.0.1.0/24</span>
<span class="keyword">...</span>
% Information related to <span class="string">'1.0.1.0 - 1.0.1.255'</span>

inetnum:        <span class="number">1.0</span><span class="number">.1</span><span class="number">.0</span> - <span class="number">1.0</span><span class="number">.1</span><span class="number">.255</span>
netname:        CHINANET-FJ
descr:          CHINANET FUJIAN PROVINCE NETWORK
descr:          China Telecom
<span class="keyword">...</span>
</code></pre><hr>
<h3 id="使用zmap扫描IP">使用zmap扫描IP</h3>
<p>在我的一台机器上面，扫描全部CN范围内开放80端口的IP数花了大概25min，得到92万个结果</p>
<pre><code><span class="array"># head </span>-n <span class="number">20</span> china-ip-list.txt &gt; top20.txt  <span class="comment">// 作为演示，仅扫描部分网段</span>
<span class="array"># zmap </span>-w <span class="number">1.</span>txt -p <span class="number">80</span> -o <span class="number">80.</span>txt             <span class="comment">// 扫描80端口开启的IP地址 </span>
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>想要玩转网络，当然得要有一些基本的数据来源，这篇就先介绍一下如何获得某地区的IP库  </p>
]]>
    
    </summary>
    
      <category term="ip" scheme="http://perthcharles.github.com/tags/ip/"/>
    
      <category term="apnic" scheme="http://perthcharles.github.com/tags/apnic/"/>
    
      <category term="zmap" scheme="http://perthcharles.github.com/tags/zmap/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记(第五期)]]></title>
    <link href="http://perthcharles.github.com/2015/11/10/wiki-weekly-readlist-20151110/"/>
    <id>http://perthcharles.github.com/2015/11/10/wiki-weekly-readlist-20151110/</id>
    <published>2015-11-10T15:56:22.000Z</published>
    <updated>2015-11-15T07:15:03.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h3 id="使用HTTP/2提升性能的7个建议"><a href="http://toutiao.com/i6214953977478382082/" target="_blank" rel="external">使用HTTP/2提升性能的7个建议</a></h3>
<pre><code>摘要：
    1. HTTP/2是二进制协议，因此更简洁高效
    2. 它针对每个域只使用一个多路复用的连接，而不是每个文件一个连接
    3. 首部使用特制的HPACK协议压缩
    4. HTTP/2设计了复杂的优先级排定规则，帮助浏览器首先请求最急需的文件，而NGINX已经支持
点评：
    HTTP/2仅使用一个连接是一个重要的改变，对于客户端可以省去多次建连时间，
    对于服务器端能少建立和维护大量的连接(尤其是HTTP/1中那些什么数据也没传过的流)
</code></pre><a id="more"></a>  

<hr>
<h3 id="从理论到实践，全方位认识DNS（理论篇）"><a href="http://blog.jobbole.com/94132/" target="_blank" rel="external">从理论到实践，全方位认识DNS（理论篇）</a></h3>
<pre><code>点评：
    介绍DNS的，逻辑比较清晰。适合作为入门读物
</code></pre><hr>
<h3 id="TCP_Fast_Open:_expediting_web_services"><a href="https://lwn.net/Articles/508865/" target="_blank" rel="external">TCP Fast Open: expediting web services</a></h3>
<p>TFO技术暂时还未正式成为标准，不过已经进入了Linux内核的源码中。<br>了解一下基本原理还是很有必要的，下面摘录三张图来展示TFO的原理和过程。 </p>
<p><img src="/resources/tfo-normal-3whs.png" alt="正常三次握手过程"><br><img src="/resources/tfo-generating-cookies.png" alt="第一次建连生成cookie"><br><img src="/resources/tfo-enploying-cookies.png" alt="后续建连使用cookie"></p>
<p>另外需要注意的是，目前TFO还不推荐在服务设备上开启(LINUX3.10内核默认关闭)，<br>这是因为有些middlebox可能会丢弃携带它不认识的选项的SYN包。<br><a href="http://packetpushers.net/tcp-fast-curious-a-look-at-tcp-fast-open/" target="_blank" rel="external">这里是一篇比较好的参考资料</a>  </p>
<hr>
<h3 id="Some_relevant_networking_concepts"><a href="http://careers.directi.com/display/tu/Understanding+and+optimizing+Network+utilization" target="_blank" rel="external">Some relevant networking concepts</a></h3>
<pre><code>点评：
    这篇文章中介绍的一些网络工具和网络调优思路很值得借鉴的
</code></pre><hr>
<h3 id="A_few_things_about_Redis_security"><a href="http://www.antirez.com/news/96" target="_blank" rel="external">A few things about Redis security</a></h3>
<pre><code>点评：
    再来点安全的东西，开开脑洞
    看完这个作者的文章没几天，国内各大安全厂商就开始爆料国内的该漏洞的安全状态
    还真不好是喜是忧的好。
</code></pre><hr>
<h3 id="What_Your_Computer_Does_While_You_Wait"><a href="http://duartes.org/gustavo/blog/post/what-your-computer-does-while-you-wait/" target="_blank" rel="external">What Your Computer Does While You Wait</a></h3>
<pre><code>摘要：
    <span class="number">1.</span> The <span class="keyword">first</span> thing that jumps out is how absurdly fast our processors are. 
       Most simple instructions <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">Core</span> <span class="title">2</span> <span class="title">take</span> <span class="title">one</span> <span class="title">clock</span> <span class="title">cycle</span> <span class="title">to</span> <span class="title">execute</span>,</span>
       hence <span class="operator">a</span> <span class="keyword">third</span> <span class="operator">of</span> <span class="operator">a</span> nanosecond <span class="keyword">at</span> <span class="number">3.0</span>Ghz.
       For reference, light only travels ~<span class="number">4</span> inches (<span class="number">10</span> cm) <span class="operator">in</span> <span class="operator">the</span> <span class="built_in">time</span> taken <span class="keyword">by</span> <span class="operator">a</span> clock cycle.
       It’s worth keeping this <span class="operator">in</span> mind when you’re thinking <span class="operator">of</span> optimization – instructions are comically cheap <span class="built_in">to</span> execute nowadays.

    <span class="number">2.</span> As <span class="operator">the</span> CPU works away, <span class="keyword">it</span> must <span class="built_in">read</span> <span class="built_in">from</span> <span class="operator">and</span> <span class="built_in">write</span> <span class="built_in">to</span> <span class="keyword">system</span> memory,
       which <span class="keyword">it</span> accesses via <span class="operator">the</span> L1 <span class="operator">and</span> L2 caches. The caches use static RAM,
       <span class="operator">a</span> much faster (<span class="operator">and</span> expensive) type <span class="operator">of</span> memory than <span class="operator">the</span> DRAM memory used <span class="keyword">as</span> <span class="operator">the</span> main <span class="keyword">system</span> memory.
       The caches are part <span class="operator">of</span> <span class="operator">the</span> processor itself <span class="operator">and</span> <span class="keyword">for</span> <span class="operator">the</span> pricier memory we <span class="built_in">get</span> very low latency. 

    <span class="number">3.</span> Here we see our <span class="keyword">first</span> major hit, <span class="operator">a</span> massive ~<span class="number">250</span> cycles <span class="operator">of</span> latency that often leads <span class="built_in">to</span> <span class="operator">a</span> stall,
       when <span class="operator">the</span> CPU has no work <span class="built_in">to</span> <span class="built_in">do</span> <span class="keyword">while</span> <span class="keyword">it</span> waits.
       To <span class="built_in">put</span> this <span class="keyword">into</span> perspective, reading <span class="built_in">from</span> L1 cache is like grabbing <span class="operator">a</span> piece <span class="operator">of</span> paper <span class="built_in">from</span> your desk (<span class="number">3</span> <span class="built_in">seconds</span>),
       L2 cache is picking up <span class="operator">a</span> book <span class="built_in">from</span> <span class="operator">a</span> nearby shelf (<span class="number">14</span> <span class="built_in">seconds</span>),
       <span class="operator">and</span> main <span class="keyword">system</span> memory is taking <span class="operator">a</span> <span class="number">4</span>-minute walk down <span class="operator">the</span> hall <span class="built_in">to</span> buy <span class="operator">a</span> Twix bar.

点评：
    了解各个部件之间的latency概况，算是一个*专业人士*的必备知识吧，哈哈
    本文写的非常的生动，解释访问速度时都有非常智能能理解的例子做对比。
    既然如此，那就再贴张文章中的图.
</code></pre><p><img src="/resources/latencyAndThroughputFull.png" alt="latency and throughput">  </p>
<hr>
<h3 id="我是如何从3亿IP中找到CISCO后门路由器的"><a href="http://www.tuicool.com/articles/BFZj6nA" target="_blank" rel="external">我是如何从3亿IP中找到CISCO后门路由器的</a></h3>
<pre><code>点评：再开开脑洞<span class="keyword">...</span>  
不过freebuf的原文被删了，吓得我赶紧备份了网页原文。  
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h3 id="使用HTTP/2提升性能的7个建议"><a href="http://toutiao.com/i6214953977478382082/" target="_blank" rel="external">使用HTTP/2提升性能的7个建议</a></h3>
<pre><code>摘要：
    1. HTTP/2是二进制协议，因此更简洁高效
    2. 它针对每个域只使用一个多路复用的连接，而不是每个文件一个连接
    3. 首部使用特制的HPACK协议压缩
    4. HTTP/2设计了复杂的优先级排定规则，帮助浏览器首先请求最急需的文件，而NGINX已经支持
点评：
    HTTP/2仅使用一个连接是一个重要的改变，对于客户端可以省去多次建连时间，
    对于服务器端能少建立和维护大量的连接(尤其是HTTP/1中那些什么数据也没传过的流)
</code></pre>]]>
    
    </summary>
    
      <category term="http2" scheme="http://perthcharles.github.com/tags/http2/"/>
    
      <category term="fastopen" scheme="http://perthcharles.github.com/tags/fastopen/"/>
    
      <category term="redis" scheme="http://perthcharles.github.com/tags/redis/"/>
    
      <category term="cpu" scheme="http://perthcharles.github.com/tags/cpu/"/>
    
      <category term="security" scheme="http://perthcharles.github.com/tags/security/"/>
    
      <category term="wiki-阅读周记" scheme="http://perthcharles.github.com/categories/wiki-%E9%98%85%E8%AF%BB%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wiki-tool-iptraf]]></title>
    <link href="http://perthcharles.github.com/2015/11/10/wiki-tool-iptraf/"/>
    <id>http://perthcharles.github.com/2015/11/10/wiki-tool-iptraf/</id>
    <published>2015-11-10T15:30:05.000Z</published>
    <updated>2015-11-11T02:25:56.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>本文介绍一个实时监控网络流量的工具iptraf。</p>
<a id="more"></a>  

<hr>
<h3 id="基本功能分析">基本功能分析</h3>
<pre><code><span class="number">1</span>. Configure...能够设置是否开启日志文件，以及屏幕数据的刷新周期、日志数据的统计周期
    一般可以将屏幕数据的刷新间隔拉长一点，减小开销
<span class="number">2</span>. Filters...能够用于配置统计的一些过滤器，可以用tcpdump的filter来类比理解
    这个功能属于iptraf监控设备的一大优点，具体filter设置方法可参考：http://iptraf.seul.org/<span class="number">2.7</span>/manual.html
<span class="number">3</span>. <span class="number">5</span>种监控与统计数据可供选择
        <span class="literal">IP</span> traffic <span class="keyword">monitor</span>
        General interface statistics
        Detailed interface statistics
        Statistical breakdowns...
        LAN station <span class="keyword">monitor</span>
    一般看看<span class="literal">IP</span> traffic <span class="keyword">monitor</span>，Statistical breakdowns就好了
</code></pre><hr>
<h3 id="filter使用经验">filter使用经验</h3>
<p>这部分等这个工具用的熟练了再来总结  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://iptraf.seul.org/2.7/manual.html" target="_blank" rel="external">IPTraf User’s Manual</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>本文介绍一个实时监控网络流量的工具iptraf。</p>
]]>
    
    </summary>
    
      <category term="iptraf" scheme="http://perthcharles.github.com/tags/iptraf/"/>
    
      <category term="tools" scheme="http://perthcharles.github.com/tags/tools/"/>
    
      <category term="net" scheme="http://perthcharles.github.com/tags/net/"/>
    
      <category term="wiki-tools" scheme="http://perthcharles.github.com/categories/wiki-tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netstat -st输出解析(二)]]></title>
    <link href="http://perthcharles.github.com/2015/11/10/wiki-netstat-proc/"/>
    <id>http://perthcharles.github.com/2015/11/10/wiki-netstat-proc/</id>
    <published>2015-11-10T02:30:40.000Z</published>
    <updated>2015-11-15T05:56:08.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>netstat -st输出的两个重要信息来源分别是/proc/net/snmp和/proc/net/netstat<br>本文将分类整理这些counterd的含义以及一些注意事项。</p>
<p><a id="more"></a><br>在整理的过程中，发现<a href="http://blog.chinaunix.net/uid/20043340.html" target="_blank" rel="external">Rover Yu</a>前辈已经<br>对这些counter做过详细的整理。关于Rover Yu前辈的整理请查看参考资料中的前三篇。<br>本着不重复造轮子的原则。本文将尽量遵循以下原则，以期从不同的角度呈现对这些counter的理解。  </p>
<pre><code>a. 分类整理：根据涉及的不同<span class="type">TCP</span>细节，对counter做更细致的分类
b. 结合sysctl配置：强调sysctl配置与counter之间的关联
<span class="built_in">c</span>. 强调异常：哪些counter出现非零值，往往就意味着出现了值得关注的问题
d. 信息抽取： 如何从counter中获取有价值的信息
e. 仅关注<span class="type">TCP</span>相关计数器
</code></pre><hr>
<h3 id="计数器分类">计数器分类</h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>涉及counters</th>
</tr>
</thead>
<tbody>
<tr>
<td>常量</td>
<td>RtoAlgorithm、RtoMin、RtoMax、MaxConn</td>
</tr>
<tr>
<td>建连统计</td>
<td>ActiveOpens、PassiveOpens、AttemptFails、CurrEstab、EstabResets</td>
</tr>
<tr>
<td>数据包统计</td>
<td>InSegs、OutSegs、RetransSegs、InErrs、OutRsts、InCsumErrors、EmbryonicRsts</td>
</tr>
<tr>
<td>syncookies功能</td>
<td>SyncookiesSent、SyncookiesRecv、SyncookiesFailed</td>
</tr>
<tr>
<td>TIME_WAIT回收</td>
<td>TW、TWRecycled、TWKilled、TCPTimeWaitOverflow</td>
</tr>
<tr>
<td>RTO次数</td>
<td>TCPTimeouts、TCPSpuriousRTOs、TCPLossProbes、TCPLossProbeRecovery、<br>TCPRenoRecoveryFail、TCPSackRecoveryFail、<br>TCPRenoFailures、TCPSackFailures、<br>TCPLossFailures</td>
</tr>
<tr>
<td>Retrans数量</td>
<td>TCPFastRetrans、TCPForwardRetrans、<br>TCPSlowStartRetrans、TCPLostRetransmit、<br>TCPRetransFail</td>
</tr>
<tr>
<td>FastOpen</td>
<td>TCPFastOpenActive、TCPFastOpenPassive、<br>TCPFastOpenPassiveFail、TCPFastOpenListenOverflow、<br>TCPFastOpenCookieReqd</td>
</tr>
<tr>
<td>MD5</td>
<td>TCPMD5NotFound、TCPMD5Unexpected</td>
</tr>
<tr>
<td>DelayedACK</td>
<td>DelayedACKs、DelayedACKLocked、DelayedACKLost、<br>TCPSchedulerFailed</td>
</tr>
<tr>
<td>DSACK</td>
<td>TCPDSACKOldSent、TCPDSACKOfoSent、<br>TCPDSACKRecv、TCPDSACKOfoRecv、<br>TCPDSACKIgnoredOld、TCPDSACKIgnoredNoUndo</td>
</tr>
<tr>
<td>Reorder</td>
<td>TCPFACKReorder、TCPSACKReorder、<br>TCPRenoReorder、TCPTSReorder</td>
</tr>
<tr>
<td>Recovery</td>
<td>TCPRenoRecovery、TCPSackRecovery、<br>TCPRenoRecoveryFail、TCPSackRecoveryFail</td>
</tr>
<tr>
<td>Abort</td>
<td>TCPAbortOnData、TCPAbortOnClose、<br>TCPAbortOnMemory、TCPAbortOnTimeout、<br>TCPAbortOnLingerTCPAbortFailed</td>
</tr>
</tbody>
</table>
<p>|reset相关          | |<br>|内存prune          | PruneCalled、RcvPruned、OfoPruned、<br>TCPMemoryPressures |<br>|PAWS相关           | PAWSPassive、PAWSActive、PAWSEstab                |<br>|Listen相关         | ListenOverflows、ListenDrops                      |<br>|undo相关           | TCPFullUndo、TCPPartialUndo、<br>TCPDSACKUndo、TCPLossUndo |<br>|快速路径与慢速路径 | TCPHPHits、TCPHPHitsToUser、<br>TCPPureAcks、TCPHPAcks |</p>
<hr>
<hr>
<h4 id="常量">常量</h4>
<p>这些常量是Linux3.10中的默认值，仅在升级了内核版本时才需要关心一下这些值的变化。  </p>
<pre><code><span class="label">RtoAlgorithm:</span>
    默认为<span class="number">1</span>，RTO算法与RFC2698一致
<span class="label">RtoMin:</span>
    默认值为HZ/<span class="number">5</span>，即<span class="number">200</span>ms
<span class="label">RtoMax:</span>
    默认值为<span class="number">120</span>HZ，即<span class="number">120</span>s
<span class="label">MaxConn:</span>
    协议栈本身并不会限制TCP连接总数，默认值为-<span class="number">1.</span>
</code></pre><hr>
<h4 id="建连统计">建连统计</h4>
<p>这些统计值中，只有CurrEstab反应的是系统当前状态，而其他值则是反应的历史状态<br>同时需要注意的是，这些计数器将ESTABLISHED和CLOSE-WAIT状态都作为当前连接数。<br>可以这么理解：这两个状态都以为这local=&gt;peer方向的连接未被关闭  </p>
<pre><code>ActiveOpen<span class="variable">s:</span>
    主动建连次数，CLOSE =&gt; SYN-SENT次数
PassiveOpen<span class="variable">s:</span>
    被动建连次数，RFC原意是LISTEN =&gt; SYN-RECV次数，但Linux选择在三次握手成功后才加<span class="number">1</span>
AttemptFail<span class="variable">s:</span>
    建连失败次数
EstabReset<span class="variable">s:</span>
    连接被reset次数，ESTABLISHED =&gt; CLOSE次数 + CLOSE-WAIT =&gt; CLOSE次数
CurrEsta<span class="variable">b:</span>
    当前TCP连接数，ESTABLISHED个数 + CLOSE-WAIT个数
</code></pre><hr>
<h4 id="数据包统计">数据包统计</h4>
<p>这些统计值也是历史值，独立的来看意义并不大。一般可统计一段时间内的变化，关注以下几个指标<br>a. TCP层的重传率: ΔRetransSegs / ΔOutSegs — 越小越好，如果超过20%(这个值根据实际情况而定)则应该引起注意<br>b. Reset发送频率: ΔOutRsts / ΔOutSegs     — 越小越好，一般应该在1%以内<br>c. 错误包占比:    ΔInErrs / ΔInSegs       — 越小越好，一般应该在1%以内，同时由checksum导致的问题包应该更低</p>
<pre><code>InSeg<span class="variable">s:</span>
    收到的数据包个数，包括有错误的包个数
OutSeg<span class="variable">s:</span>
    发送的数据包个数
RetransSeg<span class="variable">s:</span>
    重传的包个数
InErr<span class="variable">s:</span>
    收到的有问题的包个数
OutRst<span class="variable">s:</span>
    发送的带reset标记的包个数
InCsumError<span class="variable">s:</span>
    收到的checksum有问题的包个数，InErrs中应该只有*小部分*属于该类型
EmbryonicRst<span class="variable">s:</span>
    在SYN-RECV状态收到带RST/SYN标记的包个数
</code></pre><hr>
<h4 id="syncookies功能">syncookies功能</h4>
<p>syncookies一般不会被触发，只有在tcp_max_syn_backlog队列被占满时才会被触发<br>因此SyncookiesSent和SyncookiesRecv一般应该是0。<br>但是SyncookiesFailed值即使syncookies机制没有被触发，也很可能不为0。<br>这是因为一个处于LISTEN状态的socket收到一个不带SYN标记的数据包时，就会调<br>用cookie_v4_check()尝试验证cookie信息。而如果验证失败，Failed次数就加1。</p>
<pre><code>SyncookiesSen<span class="variable">t:</span>
    使用syncookie技术发送的syn/ack包个数
SyncookiesRecv
    收到携带有效syncookie信息包个数
SyncookiesFailed
    收到携带无效syncookie信息包个数
</code></pre><p>注: syncookies机制是为应对synflood攻击而被提出来的。</p>
<hr>
<h4 id="TIME-WAIT回收">TIME-WAIT回收</h4>
<p>TIME-WAIT状态是TCP协议状态机中的重要一环，服务器设备一般都有非常多处于TIME-WAIT状态的socket<br>如果是在主要提供HTTP服务的设备上，TW值应该接近TcpPassiveOpens值。<br>一般情况下，sysctl_tcp_tw_reuse和sysctl_tcp_tw_recycle都是不推荐开启的。<a href="http://perthcharles.github.io/2015/08/27/timestamp-NAT/" target="_blank" rel="external">这里解释了为什么</a>。<br>所以TWKilled和TWRecycled都应该是0。<br>同时TCPTimeWaitOverflow也应该是0，否则就意味着内存使用方面出了大问题。  </p>
<pre><code>TW:
    经过正常的TCP_TIMEWAIT_LEN(60s)结束TW状态的socket数量
TWKilled:
    经过更短的时间结束TW状态的socket数量。
    只有在net.ipv4.tcp_tw_recycle开启时，调度TW timer时才可能用更短的timeout值。
TWRecycled:
    Port从TIMEWAIT socket中复用的次数。
    只有在sysctl_tcp_tw_reuse开启时，才可能加<span class="number">1</span>
    郁闷的是上面两个counter的命名与sysctl的命名真是超级不一致啊。囧<span class="keyword">...</span>
TCPTimeWaitOverflow:
    如果没有内存分配TIME-WAIT结构体，则加<span class="number">1</span>
</code></pre><hr>
<h4 id="RTO次数">RTO次数</h4>
<p>RTO超时对TCP性能的影响是巨大的，因此关心RTO超时的次数也非常必要。<br>当然3.10中的TLP机制能够减少一定量的TCPTimeouts数，将其转换为快速重传。<br>关于TLP的原理部分，可参考<a href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-tlp/" target="_blank" rel="external">我的这篇wiki</a>。</p>
<pre><code><span class="label">TCPTimeouts:</span>
    RTO timer第一次超时的次数，仅包含直接超时的情况
<span class="label">TCPSpuriousRTOs:</span>
    通过F-RTO机制发现的虚假超时个数
<span class="label">TCPLossProbes:</span>
    Probe Timeout(PTO)导致发送Tail Loss Probe (TLP)包的次数
<span class="label">TCPLossProbeRecovery:</span>
    丢失包刚好被TLP探测包修复的次数

<span class="comment">/* 由以下计数器可以看出，进入RTO被触发时，TCP是可能处于多种不同状态的 */</span>
<span class="label">TCPRenoRecoveryFail:</span> (也放到了Recovery类别)
    先进入Recovery阶段，然后又RTO的次数，对端不支持SACK选项
<span class="label">TCPSackRecoveryFail:</span>(也放到了Recovery类别)
    先进入Recovery阶段，然后又RTO的次数，对端支持SACK选项
<span class="label">TCPRenoFailures:</span>
    先进TCP_CA_Disorder阶段，然后又RTO超时的次数，对端不支持SACK选项
<span class="label">TCPSackFailures:</span>
    先进TCP_CA_Disorder阶段，然后又RTO超时的次数，对端支持SACK选项
<span class="label">TCPLossFailures:</span>
    先进TCP_CA_Loss阶段，然后又RTO超时的次数
</code></pre><hr>
<h4 id="Retrans数量">Retrans数量</h4>
<p>这些计数器统计的重传包，都不是由于RTO超时导致进行的重传<br>如果结合RetransSegs统计来看，如果这些非RTO导致的重传占比较大的话，也算是不幸中的万幸。<br>另外LostRetransmit的数量应该偏低比较好，重传包如果都大量被丢弃，则真的要注意了。  </p>
<pre><code><span class="label">TCPLostRetransmit:</span>
    丢失的重传SBK数量，没有TSO时，等于丢失的重传包数量
<span class="label">TCPFastRetrans:</span>
    成功快速重传的SKB数量
<span class="label">TCPForwardRetrans:</span>
    成功ForwardRetrans的SKB数量，Forward Retrans重传的序号高于retransmit_high的数据
    TODO: retransmit_high目前的理解是被标记为lost的SKB中，最大的end_seq值
<span class="label">TCPSlowStartRetrans:</span>
    成功在Loss状态发送的重传SKB数量，而且这里仅记录非RTO超时进入Loss状态下的重传数量
    目前找到的一种非RTO进入Loss状态的情况就是：tcp_check_sack_reneging()函数发现
    接收端违反(renege)了之前的SACK信息时，会进入Loss状态
<span class="label">TCPRetransFail:</span>
    尝试FastRetrans、ForwardRetrans、SlowStartRetrans重传失败的次数
</code></pre><hr>
<h4 id="FastOpen">FastOpen</h4>
<p><a href="https://tools.ietf.org/html/rfc7413" target="_blank" rel="external">TCP FastOpen(TFO)技术</a>是Google提出来减少三次握手开销的技术，<br>核心原理就是在第一次建连时server计算一个cookies发给client，之后client向<br>server再次发起建连请求时就可以携带cookies信息验明正身。如果cookies验证通过，<br>server可以不等三次握手的最后一个ACK包就将client放在SYN包里面的数据传递给application layer。</p>
<p>在3.10内核中，TFO由sysctl_tcp_fastopen开关控制，默认值为0(关闭)。<br>而且sysctl_tcp_fastopen目前也是推荐关闭的，因为网络中有些middlebox会丢弃那些带有不认识的option的SYN包.<br>所以正常情况下这些值也应该都是0，当然如果收到过某些不怀好意带TFO cookies信息的SYN包，<br>TCPFastOpenPassive计数器就可能不为0。</p>
<pre><code><span class="label">TCPFastOpenActive:</span>
    发送的带TFO cookie的SYN包个数
<span class="label">TCPFastOpenPassive:</span>
    收到的带TFO cookie的SYN包个数
<span class="label">TCPFastOpenPassiveFail:</span>
    使用TFO技术建连失败的次数
<span class="label">TCPFastOpenListenOverflow:</span>
    TFO请求数超过listener queue设置的上限则加<span class="number">1</span>
<span class="label">TCPFastOpenCookieReqd:</span>
    收到一个请求TFO cookies的SYN包时加<span class="number">1</span>
</code></pre><hr>
<h4 id="MD5">MD5</h4>
<p>TCP MD5 Signature选项是为提高BGP Session的安全性而提出的，<a href="https://tools.ietf.org/html/rfc2385" target="_blank" rel="external">详见RFC 2385</a>。<br>因此内核中是以编译选项，而不是sysctl接口来配置是否使用该功能的。<br>如果内核编译是的CONFIG_TCP_MD5SIG选项未配置，则不会支持TCPMD5Sig，下面两个计数器也就只能是0  </p>
<pre><code><span class="label">TCPMD5NotFound:</span>
    希望收到带MD5选项的包，但是包里面没有MD5选项
<span class="label">TCPMD5Unexpected:</span>
    不希望收到带MD5选项的包，但是包里面有MD5选项
</code></pre><hr>
<h4 id="DelayedACK">DelayedACK</h4>
<p>DelayedACK是内核中默认支持的，但即使使用DelayedACKs，每收到两个数据包也<br>必须发送一个ACK。所以DelayedACKs可以估算为发送出去的ACK数量的一半。<br>同时DelayedACKLocked反应的是应用与内核争抢socket的次数，<br>如果占DelayedACKs比例过大可能就需要看看应用程序是否有问题了。  </p>
<pre><code><span class="label">DelayedACKs:</span>
    尝试发送delayed ack的次数，包括未成功发送的次数
<span class="label">DelayedACKLocked:</span>
    由于usr锁住了sock，而无法发送delayed ack的次数
<span class="label">DelayedACKLost:</span>
    TODO 暂时不理解准确含义
<span class="label">TCPSchedulerFailed:</span>
    如果在delay ack处理函数中发现prequeue还有数据，就加<span class="number">1</span>。
    数据放到prequeue，就是想user能尽快处理。如果任由数据，
    则可能user行为调度效果不好
    这个值应该非常接近于零才正常
</code></pre><hr>
<h4 id="DSACK">DSACK</h4>
<p>该类型计数器统计的是收/发DSACK信息次数。<br>DSACKOldSent + DSACKOfoSent可以当做是发送出的DSACK信息的次数，而且概率上来讲<br>OldSent应该占比更大。<br>同理DSACKRecv的数量也应该远多于DSACKOfoRecv的数量。<br>另外DSACK信息的发送是需要sysctl_tcp_dsack开启的，如果发现sent两个计数器为零，则要检查一下了。<br>一般还是建议开启dsack选项  </p>
<pre><code><span class="label">TCPDSACKOldSent:</span>
    如果收到的重复数据包序号比rcv_nxt(接收端想收到的下一个序号)小，则增加oldsent
<span class="label">TCPDSACKOfoSent:</span>
    如果收到的重复数据包序号比rcv_nxt大，则是一个乱序的重复数据包，增加ofosent
<span class="label">TCPDSACKRecv:</span>
    收到的old dsack信息次数，判断old的方法：dsack序号小于ACK号
<span class="label">TCPDSACKOfoRecv:</span>
    收到的Ofo dsack信息次数
<span class="label">TCPDSACKIgnoredOld:</span>
    当一个dsack block被判定为无效，且设置过undo_marker，则加<span class="number">1</span>
<span class="label">TCPDSACKIgnoredNoUndo:</span>
    当一个dsack block被判定为无效，且未设置undo_marker，则加<span class="number">1</span>
</code></pre><hr>
<h4 id="Reorder">Reorder</h4>
<p>当发现了需要更新某条TCP流的reordering值(乱序值)时，以下计数器可能被使用到。<br>不过下面四个计数器为互斥关系，最少见的应该是TCPRenoReorder，毕竟sack已经被<br>广泛部署使用了。<br>TODO: 什么情况下能准确的判断出要更新reorder值呢？  </p>
<pre><code><span class="label">TCPTSReorder:</span>
    如果是被一个partial ack确认后需要更新reorder值，则加<span class="number">1</span>
    这个地方取个TS的名字，还真是费解。不知道是什么的缩写表示了partial ack的含义。
<span class="label">TCPRenoReorder:</span>
    如果被不支持SACK的dupack确认后，需要更新reorder值，则加<span class="number">1</span>
<span class="label">TCPFACKReorder:</span>
    如果在需要更新时判断支持FACK，则加<span class="number">1</span>
<span class="label">TCPSACKReorder:</span>
    如果仅支持SACK，则该计数器加<span class="number">1</span>
</code></pre><p>关于partial ack的完整内容可参考<a href="https://tools.ietf.org/html/rfc6582" target="_blank" rel="external">RFC6582</a>，这里摘要定义部分  </p>
<pre><code>In <span class="operator">the</span> <span class="keyword">case</span> <span class="operator">of</span> multiple packets dropped <span class="built_in">from</span> <span class="operator">a</span> single window <span class="operator">of</span> data,
<span class="operator">the</span> <span class="keyword">first</span> <span class="built_in">new</span> information available <span class="built_in">to</span> <span class="operator">the</span> sender comes when <span class="operator">the</span>
sender receives <span class="operator">an</span> acknowledgment <span class="keyword">for</span> <span class="operator">the</span> retransmitted packet (that
is, <span class="operator">the</span> packet retransmitted when fast retransmit was <span class="keyword">first</span> entered).
If there is <span class="operator">a</span> single packet drop <span class="operator">and</span> no reordering, <span class="keyword">then</span> <span class="operator">the</span>
acknowledgment <span class="keyword">for</span> this packet will acknowledge all <span class="operator">of</span> <span class="operator">the</span> packets
transmitted <span class="keyword">before</span> fast retransmit was entered.  However, <span class="keyword">if</span> there
are multiple packet drops, <span class="keyword">then</span> <span class="operator">the</span> acknowledgment <span class="keyword">for</span> <span class="operator">the</span>
retransmitted packet will acknowledge some but <span class="operator">not</span> all <span class="operator">of</span> <span class="operator">the</span> packets
transmitted <span class="keyword">before</span> <span class="operator">the</span> fast retransmit.  We call this acknowledgment
<span class="operator">a</span> partial acknowledgment.
</code></pre><hr>
<h4 id="Recovery">Recovery</h4>
<p>该类型计数器统计的进入快速重传阶段的总次数及失败次数，失败次数是指先进入了<br>recovery阶段，然后有RTO超时了。Fast Recovery没有成功。<br>首先由于SACK选项已经大面积使用，RenoRecovery的次数应该远小于SackRecovery的次数<br>另外fail的次数应该比例较小才比较理想</p>
<pre><code><span class="label">TCPRenoRecovery:</span>
    进入Recovery阶段的次数，对端不支持SACK选项
<span class="label">TCPSackRecovery:</span>
    进入Recovery阶段的次数，对端支持SACK选项
<span class="label">TCPRenoRecoveryFail:</span> (也放到了RTO次数类别)
    先进入Recovery阶段，然后又RTO的次数，对端不支持SACK选项
<span class="label">TCPSackRecoveryFail:</span>(也放到了RTO次数类别)
    先进入Recovery阶段，然后又RTO的次数，对端支持SACK选项
</code></pre><hr>
<h4 id="Abort">Abort</h4>
<p>abort本身是一种很严重的问题，因此是否有必要关心这些计数器<br>后三个计数器如果不为0，则往往意味着系统发生了较为严重的问题，需要格外注意  </p>
<pre><code><span class="label">TCPAbortOnClose:</span>
    如果调用tcp_close()关闭socket时，recv buffer中还有数据，则加<span class="number">1</span>
    此时会主动发送一个reset包给对端
<span class="label">TCPAbortOnData:</span>
    如果在FIN_WAIT_1和FIN_WAIT_2状态下收到后续数据，或TCP_LINGER2设置小于<span class="number">0</span>，则计数器加<span class="number">1</span>
<span class="label">TCPAbortOnTimeout:</span>
    因各种计时器(RTO/PTO/keepalive)的重传次数超过上限，而关闭连接时，计数器加<span class="number">1</span>
<span class="label">TCPAbortOnMemory:</span>
    如果orphan socket数量或者tcp_memory_allocated超过上限，则加<span class="number">1</span>
    一般值为<span class="number">0</span>
<span class="label">TCPAbortOnLinger:</span>
    tcp_close()中，因tp-&gt;linger2被设置小于<span class="number">0</span>，导致FIN_WAIT_2立即切换到CLOSE状态的次数
    一般值为<span class="number">0</span>
<span class="label">TCPAbortFailed:</span>
    如果在准备发送reset时，分配SKB或者发送SKB失败，则加<span class="number">1</span>
    一般值为<span class="number">0</span>
</code></pre><hr>
<pre><code><span class="built_in">c</span>. 当rcv_buf不足时可能需要prune ofo queue, 这种情况就会导致<span class="type">PruneCalled</span>计数器增加；
   当一般都应该通过collapse节省内存就可以了，并不需要真正的prune掉被<span class="type">SACK</span>的数据。
   所以<span class="type">OfoPruned</span>和更严重的<span class="type">RcvPruned</span>都应该计数为<span class="number">0</span>。
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://blog.chinaunix.net/uid-20043340-id-2984198.html" target="_blank" rel="external">TCP SNMP counters一</a><br><a href="http://blog.chinaunix.net/uid-20043340-id-3016560.html" target="_blank" rel="external">TCP SNMP counters二</a><br><a href="http://blog.chinaunix.net/uid-20043340-id-3017972.html" target="_blank" rel="external">TCP SNMP counters三</a><br><a href="http://tools.ietf.org/html/rfc2012" target="_blank" rel="external">RFC 2012:  SNMPv2 Management Information Base for the Transmission Control Protocol using SMIv2</a><br><a href="https://lwn.net/Articles/508865/" target="_blank" rel="external">TCP Fast Open: expediting web services</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>netstat -st输出的两个重要信息来源分别是/proc/net/snmp和/proc/net/netstat<br>本文将分类整理这些counterd的含义以及一些注意事项。</p>
<p>]]>
    
    </summary>
    
      <category term="snmp" scheme="http://perthcharles.github.com/tags/snmp/"/>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="netstat" scheme="http://perthcharles.github.com/tags/netstat/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[netstat -s输出解析(一)]]></title>
    <link href="http://perthcharles.github.com/2015/11/09/wiki-rfc2012-snmp-proc/"/>
    <id>http://perthcharles.github.com/2015/11/09/wiki-rfc2012-snmp-proc/</id>
    <published>2015-11-09T05:31:40.000Z</published>
    <updated>2015-11-10T02:48:13.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>当执行以下命令查看netstat统计信息来源时，发现一个重要的来源是/proc/net/snmp接口的输出信息<br>因此在刨根问底分析源码的过程中，找到了这个接口对应的RFC2012文档。本wiki就记录下<br>相关的解读，以便后续更加透彻的立即netstat的统计信息。  </p>
<pre><code><span class="preprocessor"># strace -e open netstat -s</span>
</code></pre><p>注：netstat -s的另一个重要的数据来源是/proc/net/netstat下的信息，但鉴于<br>该接口信息量较大，因此会单独独立整理。<br><a id="more"></a>  </p>
<hr>
<h3 id="snmp4_tcp_list数组元素解析">snmp4_tcp_list数组元素解析</h3>
<p>netstat -s的Tcp类选的数据均来自内核中定义的snmp4_tcp_list数组。<br>snmp4_tcp_list数组的每一个成员都是一个snmp_mib结构体  </p>
<pre><code><span class="keyword">struct</span> snmp_mib {
    <span class="keyword">const</span> <span class="keyword">char</span> *name;
    <span class="keyword">int</span> entry;
};
</code></pre><p>snmp4_tcp_list数组就是/proc/net/snmp接口输出的TCP部分内容  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>Linux 3.10实现</th>
</tr>
</thead>
<tbody>
<tr>
<td>RtoAlgorithm</td>
<td>用于计算RTO的算法</td>
<td>RTO算法遵循RFC2698，对应值为1.</td>
</tr>
<tr>
<td>RtoMin</td>
<td>限定RTO的最小值</td>
<td>使用常量HZ/5限定，即200ms</td>
</tr>
<tr>
<td>RtoMax</td>
<td>限定RTO的最大值</td>
<td>使用常量120HZ限定，即120s</td>
</tr>
<tr>
<td>MaxConn</td>
<td>TCP流数量的上限</td>
<td>并不会在协议栈层限制，默认值为-1</td>
</tr>
<tr>
<td>ActiveOpens</td>
<td>CLOSE =&gt; SYN-SENT次数<br>可理解为主动建联数</td>
<td>在tcp_connect()函数中计数<br>相当于SYN包的发送次数(但不包含重传次数)</td>
</tr>
<tr>
<td>PassiveOpens</td>
<td>LISTEN =&gt; SYN-RECV次数<br>可理解为被动建联数</td>
<td>实现上则是在三次握手成功后，<br>建立tcp_sock结构体后才加1  <br> 在tcp_create_openreq_child()函数中调用</td>
</tr>
<tr>
<td>AttemptFails</td>
<td>SYN-SENT =&gt; CLOSE次数 <br> 加上SYN-RECV =&gt; CLOSE次数 <br> 加上SYN-RECV =&gt; LISTEN次数<br> 建联失败的次数</td>
<td>回CLOSE部分在tcp_done()函数中计数，<br>回LISTEN部分在tcp_check_req()中计数</td>
</tr>
<tr>
<td>EstabResets</td>
<td>ESTABLISHED =&gt; CLOSE次数<br> 加上CLOSE-WAIT =&gt; CLOSE次数 <br> 这些情况，基本都是reset导致的</td>
<td>在tcp_set_state()函数中，如果之前的状态是<br>TCP_CLOSE_WAIT或TCP_ESTABLISHED就加1</td>
</tr>
<tr>
<td>CurrEstab</td>
<td>ESTABLISHED和CLOSE-WAIT<br>状态的TCP流数</td>
<td>在tcp_set_state()中处理 <br>实现体现的是进入ESTABLISHED之后<br>进入CLOSE之前的TCP流数</td>
</tr>
<tr>
<td>InSegs</td>
<td>所有收到的TCP包<br>即使是个错误包</td>
<td>在tcp_v4_rcv()和tcp_v6_rcv()中计数</td>
</tr>
<tr>
<td>OutSegs</td>
<td>所有发送出去的TCP包<br>包括新数据包、重传数据包<br>、syn包、synack包和reset包</td>
<td>tcp_v4_send_reset()中统计reset包<br>tcp_v4_send_ack()中统计SYN-RECV和TIME-WAIT状态下发送的ACK包<br>tcp_v6_send_response()中统计ipv6相应数据<br>tcp_make_synack()中统计发送的SYNACK包<br><br>tcp_transmit_skb()中统计所有的其他包</td>
</tr>
<tr>
<td>RetransSegs</td>
<td>所有重传出去的TCP包</td>
<td>tcp_v4_rtx_synack()和tcp_v6_rtx_synack()中<br>统计重传的SYNACK包，<br>tcp_retransmit_skb()中统计其他重传包</td>
</tr>
<tr>
<td>InErrs</td>
<td>所有收到的有问题的TCP包数量<br>比如checksum有问题</td>
<td>tcp_validate_incoming()中统计seq有问题的包<br>tcp_rcv_established()、tcp_v4_do_rcv()、tcp_v4_rcv()、<br>tcp_v6_do_rcv()、tcp_v6_rcv()中根据checksum来判断出错误包</td>
</tr>
<tr>
<td>OutRsts</td>
<td>发送的带RST标记的TCP包数量</td>
<td>在tcp_v4_send_reset()、tcp_send_active_reset()、<br>tcp_v6_send_response()中统计</td>
</tr>
<tr>
<td>InCsumErrors</td>
<td>checksum有问题的数据包数量</td>
<td>是3.10相对于2.6.32新增的内容，算是细化InErrs统计</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="snmp4_tcp_list统计结果实例一则">snmp4_tcp_list统计结果实例一则</h3>
<pre><code><span class="preprocessor"># cat /proc/net/snmp |grep Tcp  /* 适当调整了输个格式，以增加可读性 */</span>
<span class="label">Tcp:</span> RtoAlgorithm RtoMin RtoMax MaxConn ActiveOpens PassiveOpens AttemptFails
<span class="label">Tcp:</span> <span class="number">1</span>            <span class="number">200</span>    <span class="number">120000</span> -<span class="number">1</span>      <span class="number">818674494</span>   <span class="number">564859834</span>    <span class="number">83498657</span>

EstabResets CurrEstab InSegs       OutSegs      RetransSegs InErrs   OutRsts   InCsumErrors
<span class="number">38663863</span>    <span class="number">4790</span>      <span class="number">213696000469</span> <span class="number">253602471635</span> <span class="number">2134386615</span>  <span class="number">18675977</span> <span class="number">171550781</span> <span class="number">125433</span>
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tools.ietf.org/html/rfc2012" target="_blank" rel="external">RFC 2012:  SNMPv2 Management Information Base for the Transmission Control Protocol using SMIv2</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>当执行以下命令查看netstat统计信息来源时，发现一个重要的来源是/proc/net/snmp接口的输出信息<br>因此在刨根问底分析源码的过程中，找到了这个接口对应的RFC2012文档。本wiki就记录下<br>相关的解读，以便后续更加透彻的立即netstat的统计信息。  </p>
<pre><code><span class="preprocessor"># strace -e open netstat -s</span>
</code></pre><p>注：netstat -s的另一个重要的数据来源是/proc/net/netstat下的信息，但鉴于<br>该接口信息量较大，因此会单独独立整理。<br>]]>
    
    </summary>
    
      <category term="snmp" scheme="http://perthcharles.github.com/tags/snmp/"/>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="netstat" scheme="http://perthcharles.github.com/tags/netstat/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记(第四期)]]></title>
    <link href="http://perthcharles.github.com/2015/11/03/wiki-weekly-readlist-20151103/"/>
    <id>http://perthcharles.github.com/2015/11/03/wiki-weekly-readlist-20151103/</id>
    <published>2015-11-03T01:46:38.000Z</published>
    <updated>2015-11-06T10:46:33.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="Wireshark网络分析就这么简单"><a href="http://book.douban.com/subject/26268767/" target="_blank" rel="external">Wireshark网络分析就这么简单</a></h2>
<pre><code>点评：
    这本书比较短小精悍，断断续续花几个小时就看完了。通过介绍一些使用wireshark分析网络
    问题的实例，展现了wireshark工具的强大。但可能是由于篇幅所限，难免有些技术
    细节没有更多的介绍。整体来看，更像是几篇博客的一个小集合，不过作为介绍wireshark
    的入门图书，还是非常值得一看的。  
    尤其是要细细体会作者在面对实际问题时使用wireshark工具辅助分析的思路。
</code></pre><a id="more"></a>          

<hr>
<h2 id="被人遗忘的Memcached内存注射"><a href="http://drops.wooyun.org/web/8987" target="_blank" rel="external">被人遗忘的Memcached内存注射</a></h2>
<pre><code>点评:
    对网络攻击还是纯小白，看看这种简单的实例还是挺有意思的。
    攻击者确实要脑洞大开才行啊，哈哈
</code></pre><hr>
<h2 id="HTTP_archive"><a href="http://httparchive.org/index.php" target="_blank" rel="external">HTTP archive</a></h2>
<pre><code>点评：
    这个网站太有意思了，而且<span class="tag">code</span>和data都开源了。
    作为路过的过客，看看一些图像化的统计数据就很有意思。图也真的是好多。  
    下面列举一些个人比较感兴趣的，数据是发博文这天看到的统计数据：
        <span class="tag">a</span>. 网页的平均大小为2191KB，其中最大的是<span class="function">images</span>(1399KB，好看)，
           其次是<span class="function">scripts</span>(353KB, 动画，本地执行)，第三名是<span class="function">video</span>(186KB，平均后的结果，因为77%的网页没有视频)
        <span class="tag">b</span>. pages with <span class="function">errors</span>(4xx,5xx)占比36%  -- 不低啊
        c. HTTPS占比只有23%  -- 绝大多数还是HTTP的啊  
        d. 网页中图片格式使用最多的是<span class="function">JPG</span>(45%)，其次是<span class="function">PNG</span>(30%)和<span class="function">GIF</span>(23%)
        e. 网页中使用Google API的占比达到了51%   -- 膜拜
        f. 84%的网页建立的连接数(connections)超过10  -- 真的不知道是该笑还是哭

    其实这个网站更值得关注的是trend这项和具体网页的相应数据(这个具体有什么用，就不解释了)
    要不是httparchive这个网页本身访问有点问题(哎)，这个网站绝对是测试某个网站加载速度的最佳工具！  
</code></pre><hr>
<h2 id="接着过QCon的PPT">接着过QCon的PPT</h2>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="Wireshark网络分析就这么简单"><a href="http://book.douban.com/subject/26268767/" target="_blank" rel="external">Wireshark网络分析就这么简单</a></h2>
<pre><code>点评：
    这本书比较短小精悍，断断续续花几个小时就看完了。通过介绍一些使用wireshark分析网络
    问题的实例，展现了wireshark工具的强大。但可能是由于篇幅所限，难免有些技术
    细节没有更多的介绍。整体来看，更像是几篇博客的一个小集合，不过作为介绍wireshark
    的入门图书，还是非常值得一看的。  
    尤其是要细细体会作者在面对实际问题时使用wireshark工具辅助分析的思路。
</code></pre>]]>
    
    </summary>
    
      <category term="wireshark" scheme="http://perthcharles.github.com/tags/wireshark/"/>
    
      <category term="memcached" scheme="http://perthcharles.github.com/tags/memcached/"/>
    
      <category term="http archive" scheme="http://perthcharles.github.com/tags/http-archive/"/>
    
      <category term="wiki-阅读周记" scheme="http://perthcharles.github.com/categories/wiki-%E9%98%85%E8%AF%BB%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TCP Tail Loss Probe(TLP)]]></title>
    <link href="http://perthcharles.github.com/2015/10/31/wiki-network-tcp-tlp/"/>
    <id>http://perthcharles.github.com/2015/10/31/wiki-network-tcp-tlp/</id>
    <published>2015-10-31T11:01:45.000Z</published>
    <updated>2015-11-02T14:47:53.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>Early Retransmit机制解决了dupack较少，无法触发快速重传的问题。<br>但是如果发生了尾丢包，由于尾包后面没有更多的数据包，也就没有办法触发任何的dupack。<br>为解决这种尾丢包的问题，Google的几位大神提出了TLP算法。通过TLP算法，发送一个loss probe包，来产生足够的SACK/FACK的信息来触发RF。根据Google的测试，TLP能够有效的避免较长的RTO超时，进而提高TCP性能。  </p>
<a id="more"></a>  

<hr>
<h3 id="RFC解读">RFC解读</h3>
<hr>
<h4 id="TLP基本策略">TLP基本策略</h4>
<p>TLP算法会在TCP还是Open状态的时候，设置一个Probe TimeOut (PTO)。<br>当链路中有未被确认的数据包，同时在PTO时间内未收到任何ACK，则会触发PTO<br>超时处理机制。<br>TLP会选择传输序号最大的一个数据包作为tail loss probe包，这个序号最大的包可能是<br>一个可以发送的新的数据包，也可能是一个重传包。<br>TLP通过这样一个tail loss probe包，如果能够收到相应的ACK，则会触发FR机制，而不是RTO机制。  </p>
<hr>
<h4 id="触发超时机制的常见场景">触发超时机制的常见场景</h4>
<p>这些case还是用大神们的原文描述比较准确:)</p>
<pre><code>a. <span class="operator"><span class="keyword">Drop</span> tail <span class="keyword">at</span> the <span class="keyword">end</span> <span class="keyword">of</span> transactions.
b. <span class="keyword">Mid</span>-<span class="keyword">transaction</span> loss <span class="keyword">of</span> an entire window <span class="keyword">of</span> <span class="keyword">data</span> <span class="keyword">or</span> ACKs.
c. Insufficient <span class="built_in">number</span> <span class="keyword">of</span> duplicate ACKs <span class="keyword">to</span> <span class="keyword">trigger</span> <span class="keyword">fast</span> recovery <span class="keyword">at</span> sender.
    <span class="comment">-- 基本被Eearly Retransmit机制解决了</span>
d. An unexpectedly long <span class="keyword">round</span>-trip <span class="keyword">time</span>(RTT), such that the ACKs arrive <span class="keyword">after</span>
   the RTO timer expires.
    <span class="comment">-- F-RTO机制通过检测spurious retransmission，能够尽量的undo RTO造成的影响</span></span>
</code></pre><p>Early Retransmit技术可参考<a href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/" target="_blank" rel="external">这篇wiki</a><br>F-RTO技术可参考<a href="http://perthcharles.github.io/2015/06/16/wiki-network-tcp-frto/" target="_blank" rel="external">这篇wiki</a>  </p>
<p>Google Web servers上面，将近70%的重传是RTO超时重传，只有30%是Fast Recovery重传。<br>同时还有数据表明，96%的RTO超时重传是在没有收到任何dupack的情况下发生的。<br>没有到任何dupack就意味着FR和ER机制都是无法生效的。  </p>
<hr>
<h4 id="RTO与RTT的比值分布">RTO与RTT的比值分布</h4>
<p>Googler们还收集RTO/RTT的分布，来了解RTO值到底比RTT值大多少。下面是统计结果  </p>
<pre><code><span class="variable">Percentile</span>      <span class="variable">RTO</span>/<span class="variable">RTT</span>
<span class="number">50</span><span class="comment">%             4.3</span>
<span class="number">75</span><span class="comment">%             11.3</span>
<span class="number">90</span><span class="comment">%             28.9</span>
<span class="number">95</span><span class="comment">%             53.9</span>
<span class="number">99</span><span class="comment">%             214</span>
</code></pre><p>根据这个数据，显然这是一个CDF的统计。也就是说，50%的流，RTO/RTT小于4.3，75%的流，RTO/RTT小于11.3<br>不过反过来看，有50%的流RTO/RTT超过4.3，25%的流RTO/RTT超过11.3。<br>不过这个数据Googler并没有进一步的解释，有很多疑问在里面。<br>RTO的min值默认是200ms，这数据里面的是多少？这个数据里面是否同时包含了internet-face流和local-face流。<br>比如说，local-face流的rtt一般很小，常见值就是1.875ms，而min RTO值200ms的话，显然RTO/RTT很容易超过100<br>不过话说回来，数据来看，local-face的流应该没有包括，但是min RTO就不清楚了。  </p>
<p>Googler认为”Such large RTOs make a huge contribution to the long tail on the<br>latency statistics of short flows.”<br>这点如果结合TLP考虑的情景，推断确实合理。  </p>
<p>那将RTO的计算值设置的较小一点如何？可能会造成两个问题：<br>a. spurious retransmission<br>b. 更多的RTO =&gt; cwnd=1</p>
<p>TLP试图解决的方式是将”尾丢包+RTO”这种case转换为”尾丢包+尾探测+FR”。</p>
<hr>
<h4 id="TLP算法">TLP算法</h4>
<p>名词解释  </p>
<pre><code>FlightSize: <span class="keyword">the</span> amount <span class="keyword">of</span> data <span class="keyword">that</span> has been sent <span class="keyword">but</span> <span class="keyword">not</span> yet *cumulatively* acknowledged.
    <span class="comment">-- 这个与内核中的packet_in_flight计数器要区分开，这里要强调累计确认</span>

PTO: Probe <span class="keyword">timeout</span> <span class="keyword">is</span> a timer event indicating <span class="keyword">that</span> an ACK <span class="keyword">is</span> overdue.

Open state: <span class="keyword">the</span> sender has so far received <span class="keyword">in</span>-sequence ACKs <span class="keyword">with</span> no SACK
            blocks, <span class="keyword">and</span> no other indications (such <span class="keyword">as</span> retransmission <span class="keyword">timeout</span>) <span class="keyword">that</span>
            a loss may have occurred.
    <span class="comment">-- 换成中文：TCP的正常状态，哈哈</span>

Consecutive PTOs: <span class="keyword">back</span>-<span class="keyword">to</span>-<span class="keyword">back</span> PTOs all scheduled <span class="keyword">for</span> <span class="keyword">the</span> same tail packets <span class="keyword">in</span> a flight.
</code></pre><p>算法逻辑  </p>
<pre><code><span class="number">1.</span> 在Open state发送新数据后，设置一个PTO计时器  
    <span class="keyword">if</span> (FlightSize &gt; <span class="number">1</span>)     PTO = <span class="built_in">max</span>(<span class="number">2</span>*SRTT, <span class="number">10</span>ms)
    <span class="keyword">if</span> (FlightSize == <span class="number">0</span>)    PTO = <span class="built_in">max</span>(<span class="number">2</span>*SRTT, <span class="number">1.5</span>*SRTT + WCDelAckT)
    <span class="keyword">if</span> (RTO is earlier)     PTO = <span class="built_in">min</span>(RTO, PTO)
        其中WCDelAckT表示worst <span class="keyword">case</span> delayed ACK timer，默认值是<span class="number">200</span>ms

<span class="number">2.</span> 启用PTO timer的条件：
    <span class="operator">a</span>. connection is <span class="operator">in</span> <span class="built_in">open</span> state
        <span class="comment">-- 如果不在open state，说明有其他信息帮助判断丢包。而无需启用TLP</span>
    b. connection is either cwnd limited <span class="operator">or</span> application limited
        <span class="comment">-- TLP必须满足tail这个条件</span>
    c. <span class="built_in">number</span> <span class="operator">of</span> consecutive PTOs &lt;= <span class="number">2</span>
        <span class="comment">-- TLP 不要尝试太多次</span>
    d. connection is SACK enable
        <span class="comment">-- TLP依赖于SACK选项来提供是否触发FR的决策</span>

<span class="number">3.</span> 当PTO超时后：
    <span class="keyword">if</span> (能发新数据)         发送一个新数据包，FlightSize += SMSS, cwnd不改变
    <span class="keyword">if</span> (没有新数据可发)     发送一个序号最大的数据包
    增加loss probe的计数器
    如果步骤<span class="number">2</span>中的条件满足，则再次设置PTO；否则设置RTO超时计时器<span class="string">'now+RTO'</span>

<span class="number">4.</span> 在处理收到的ACK包时
    取消PTO timer
    如果步骤<span class="number">2</span>条件满足，则设置PTO timer
</code></pre><hr>
<h4 id="基于FACK机制的FR触发算法">基于FACK机制的FR触发算法</h4>
<p>理解FACK机制最终的一点就是意识到SACK信息能够反应较准确的接收端接收情况。<br>FACK机制的算法如下，非常好理解：  </p>
<pre><code><span class="keyword">if</span> (SND.FACK - SND.UNA) &gt; dupack threshold:
    -&gt; Invoke Fast Retransmit <span class="operator">and</span> Fast Recovery.
SND.FACK relects <span class="operator">the</span> forward-most data held <span class="keyword">by</span> <span class="operator">the</span> received plus <span class="constant">one</span>.
</code></pre><hr>
<h4 id="如果丢失的包就是TLP重传的数据包会怎样">如果丢失的包就是TLP重传的数据包会怎样</h4>
<p>如果丢失的包刚好是最后一个数据包，那么TLP的重传可能会恰巧修复了这个丢包。<br>这样对于congestion control机制来说，就无法发现这个丢包。这与TCP的拥塞控制<br>机制相违背。<br>因此TLP需要设计一个检测丢包是否被TLP探测包修复的逻辑。  </p>
<p>检测的核心思想就是：  </p>
<pre><code>如果发送了<span class="keyword">N</span>次TLP探测包，判断是否收到了<span class="keyword">N</span>个<span class="string">"TLP dupacks"</span>。
如果没有，则意味着第一个TLP探测报可能就刚好修复了一个丢失包。  
</code></pre><hr>
<h4 id="TLP丢包检测算法">TLP丢包检测算法</h4>
<p>名词解释  </p>
<pre><code>TLPRtxOout: <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> unacknowledged TLP retransmissions <span class="operator">in</span> current TCP episode.

TLPHighRxt: <span class="operator">the</span> <span class="built_in">value</span> <span class="operator">of</span> SND.NXT <span class="keyword">at</span> <span class="operator">the</span> <span class="built_in">time</span> <span class="operator">of</span> TLP retransmission.
</code></pre><p>算法步骤：</p>
<pre><code><span class="number">1</span>. 初始化  
    当TCP流进入ESTABLISHED状态，或者RTO超时后，或者进入Fast Recovery后，对上面两个变量进行初始化
    <span class="variable">TLPRtxOut =</span> <span class="number">0</span>;
    <span class="variable">TLPHighRxt =</span> <span class="number">0</span>;
<span class="number">2</span>. 当发送一个TLP探测包后  
    <span class="keyword">if</span> (<span class="variable">TLPRtxOut =</span>= <span class="number">0</span>)
        <span class="variable">TLPHighRxt =</span> SND.NXT
    TLPRtxOut++;
<span class="number">3</span>. 在收到一个ACK包后  
    当满足所有以下条件时，认为这个ACK是由TLP包触发的，而且这个TLP是完全多余的
    a. TLPRtxOut &gt; <span class="number">0</span>                        <span class="comment">/* 首先当然得发送过TLP包 */</span>
    b. SEG.<span class="variable">ACK =</span>= TLPHighRxt                <span class="comment">/* ACK包确认了SND.NXT序号 */</span>
    c. ACK不包含序号超过TLPHighRxt的SACK段  <span class="comment">/* 意味着这个ACK就是TLP包序号触发的，而不是TLPHighRxt序号之后某个包触发的 */</span>
    d. ACK没有移动SND.UNA                   <span class="comment">/* 说明这是一个纯粹的dupack，并且ACK号是SND.NXT证明这个ACK包对应的TLP是完全多余的 */</span>
    e. ACK包不含数据                        <span class="comment">/* 就是要证明这个ACK是一个完全多余的TLP包触发的 */</span>
    f. ACK包不是一个窗口更新包              <span class="comment">/* 理由同e */</span>
    以上条件都满足时，TLPRtxOut--

    如果ACK.SEQ &gt; TLPHighRxt，则说明TLP阶段应该结束了。最后来判断是否发现了丢包
    <span class="variable">isLoss =</span> (TLPRtxOut &gt; <span class="number">0</span>) &amp;&amp;     <span class="comment">/* 不为0说明有一个TLP包不是多余的，也就是说有丢包发生 */</span>
             (ACK不携带任何TLP重传相关的DSACK信息)      <span class="comment">/* 如果包含DSACK信息，也能证明TLP是多余的。所以要排除这种情况 */</span>
    <span class="variable">TLPRtxOut =</span> <span class="number">0</span>
    <span class="keyword">if</span> (isLoss)
        EnterRecovery()
<span class="number">4</span>. TLP探测包的发送条件，除了满足TLP原始算法中步骤<span class="number">2</span>中的条件外，还要满足  
    (<span class="variable">TLPRxtOut =</span>= <span class="number">0</span>) || (SND.<span class="variable">NXT =</span>= TLPHighRxt)
    -- The sender maintains this invariant so that there is at most
       one TLP retransmission <span class="string">"espisode"</span> happening at a time.
</code></pre><hr>
<h4 id="统一了丢包恢复机制">统一了丢包恢复机制</h4>
<p>在原生TCP中，如果丢包发生在packet train的中间，很容易触发快速重传进行丢包恢复；<br>但是如果丢包发生packet train的末端，则基本只能靠RTO超时来恢复。<br>而这就意味着丢包的位置的不同，也可能造成TCP不同的重传机制被触发。这与TCP设计时的common sense不一致。  </p>
<p>如果使用TLP机制，则能避免丢包位置的不同对TCP重传机制的选择造成影响。  </p>
<hr>
<h4 id="恢复任意程度的尾丢包">恢复任意程度的尾丢包</h4>
<p>根据Googler们的讨论，Tail Loss Probe + Early Retransmit能够解决任意程度的尾丢包<br>下面是所有case情境的讨论汇总  </p>
<table>
<thead>
<tr>
<th>number of losses</th>
<th>scoreboard after TLP retrans ACKed</th>
<th>mechanism</th>
<th>final outcome</th>
</tr>
</thead>
<tbody>
<tr>
<td>AAAL</td>
<td>AAAA</td>
<td>TLP loss detection</td>
<td>all repaired</td>
</tr>
<tr>
<td>AALL</td>
<td>AALS</td>
<td>ER</td>
<td>all repaired</td>
</tr>
<tr>
<td>ALLL</td>
<td>ALLS</td>
<td>enhanced ER</td>
<td>all repaired</td>
</tr>
<tr>
<td>LLLL</td>
<td>LLLS</td>
<td>FACK FR</td>
<td>all repaired</td>
</tr>
<tr>
<td>&gt;=5 L</td>
<td>..LS</td>
<td>FACK FR</td>
<td>all repaired</td>
</tr>
</tbody>
</table>
<p>其中：<br>A = ACKed segment<br>L = Lost segment<br>S = SACKed segment  </p>
<p>其中case “ALLL”依赖于Googler们提出的enhanced ER机制，首先这个增加做了什么  </p>
<pre><code>Propose <span class="built_in">to</span> allow <span class="operator">a</span> delayed early retransmit <span class="operator">in</span> <span class="operator">the</span> <span class="keyword">case</span> where there
are <span class="constant">three</span> outstanding segments that have <span class="operator">not</span> been cumulatively
acknowledged <span class="operator">and</span> ont segment that has been fully SACKed.
</code></pre><p>具体来讲，就体现在之前介绍<a href="http://perthcharles.github.io/2015/10/31/wiki-network-tcp-early-retrans/" target="_blank" rel="external">ER的wiki</a>中提到的如下一个代码更改  </p>
<pre><code>@ <span class="keyword">static</span> <span class="keyword">bool</span> tcp_time_to_recover()
-   (tp-&gt;packets_out == (tp-&gt;sacked_out + <span class="number">1</span>) &amp;&amp; tp-&gt;packets_out &lt; <span class="number">4</span>) &amp;&amp; 
+   (tp-&gt;packets_out &gt;= (tp-&gt;sacked_out + <span class="number">1</span>) &amp;&amp; tp-&gt;packets_out &lt; <span class="number">4</span>) &amp;&amp; 
</code></pre><p>具体分析以下，如果是’==’的形式，case”ALLL”会得到”ALLS”的scoreboard，但是这里的packets_out=3，而sacked_out=1所以还无法触发ER。<br>此时解决方法有两种：要么在重传一个TLP探测报，使sacked_out值增长为2，要么放松条件改用”&gt;=”。<br>很明显，Googler们选了后者。<br>而对于case”AALL”这种packets_out=2的情况，一个TLP包引起的dupack就能触发ER，也就无影响了。<br>下面我来讨论一下packets_out=3的情况，其中R表示reorder达到接收端，即没有被丢弃    </p>
<pre><code><span class="number">1</span>. ALLL
    这种使用TLP和enhanced ER能够做到all repaired。没问题
<span class="number">2</span>. ALRR
    这种能够通过ER机制修复。但是如果使用了enhanced ER，那么在收到第一个reorder触发的SACK信息后，
    socreboard为ALS_状态，此时由于使用了enhanced ER，在第二个SACK信息没有收到时就会被判为启动ER。
    因为<span class="variable">packets_out=</span><span class="number">3</span>, <span class="variable">sacked_out =</span> <span class="number">1</span>, 满足enhanced ER的条件
    当然由于enhanced ER还有一个重要的特性是delayed，如果第二SACK信息能够及时的到来，最严重的后果也就是
    early retransmit的timer被设置两次而已。

<span class="number">3</span>. ALLR
    这种情况首先肯定不会触发TLP机制，因为必能能收到一个dupack。应该属于ER机制要解决的范畴。  
    但是它又由于没有足够的dupack，<span class="variable">packet_out=</span><span class="number">3</span>，dupack等于<span class="number">1</span>。标准的ER对此无能为力。  
    只能靠enhanced ER来恢复。
<span class="number">4</span>. ALRL
    <span class="variable">packets_out=</span><span class="number">3</span>,<span class="variable">dupack=</span><span class="number">1</span>。不能触发TLP，标准ER又解决不了。只能靠enhanced ER来恢复。
</code></pre><hr>
<hr>
<h3 id="源码分析">源码分析</h3>
<p>以下代码基于Linux3.10内核  </p>
<hr>
<h4 id="函数调用逻辑">函数调用逻辑</h4>
<pre><code>1. 正常数据的发送流程中，增加调度安装PTO超时计时器的逻辑
   即TLP算法逻辑的第一步。  

__tcp_push_pending_frame()
    =<span class="ruby"><span class="output"><span class="status">=&gt;</span> tcp_write_xmit() with push_one=<span class="number">0</span></span>
</span>        =<span class="ruby"><span class="output"><span class="status">=&gt;</span> tcp_schedule_loss_probe()   /* 尝试安装<span class="constant">PTO</span>超时计时器的安装 *<span class="regexp">/
</span></span></span>
2. 处理ack时，增加调度安装PTO超时计时器和结束TLP状态的逻辑
   即TLP算法的最后一步 

tcp_ack()
    =<span class="ruby"><span class="output"><span class="status">=&gt;</span> if (tp-&gt;tlp_high_seq) tcp_process_tlp_ack();    <span class="regexp">/* 判断是否需要结束TLP状态 */</span></span>
</span>    =<span class="ruby"><span class="output"><span class="status">=&gt;</span> tcp_schedule_loss_probe()</span></span>
</code></pre><hr>
<h4 id="安装PTO超时计时器">安装PTO超时计时器</h4>
<pre><code><span class="comment">/* 返回false代表未设置timer, 返回true代表设置了PTO timer */</span>
<span class="keyword">bool</span> tcp_schedule_loss_probe(<span class="keyword">struct</span> sock *sk)
{
    ...  
    <span class="keyword">u32</span> rtt = tp-&gt;srtt &gt;&gt; <span class="number">3</span>;    <span class="comment">/* tp-&gt;srtt存的实际是RFC中SRTT的8倍 */</span>
    ...  
    <span class="comment">/* TLP is only scheduled when next timer event is RTO. */</span>
    <span class="keyword">if</span> (icsk-&gt;icsk_pending != ICSK_TIME_RETRANS)
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">/* Schedule a loss probe in 2*RTT for SACK capable connections
     * in Open state, that are either limited by cwnd or application.
     */</span>
    <span class="keyword">if</span> (sysctl_tcp_early_retrans &lt; <span class="number">3</span> ||     <span class="comment">/* 没开TLP */</span>
        !rtt ||                             <span class="comment">/* 没有RTTsample可用，没法设置PTO */</span>
        !tp-&gt;packets_out ||                 <span class="comment">/* 网络中没有未被确认的数据包，没必要设置PTO */</span>
        !tcp_is_sack(tp) ||                 <span class="comment">/* 不支持SACK选项 */</span>
        !inet_csk(sk)-&gt;icsk_ca_state != TCP_CA_Open)    <span class="comment">/* 只有在open状态才设置PTO */</span>
        <span class="keyword">return</span> <span class="keyword">false</span>;

    <span class="comment">/* Probe timeout is at lease 1.5*rtt + TCP_DELACK_MAX to account
     * for delayed ack when there's one outstanding packet.
     */</span>
    <span class="comment">/* 这段代码完全符合TLP算法逻辑，不解释了 */</span>
    timeout = rtt &lt;&lt; <span class="number">1</span>;
    <span class="keyword">if</span> (tp-&gt;packets_out == <span class="number">1</span>)
        timeout = max_t(<span class="keyword">u32</span>, timeout, (rtt + (rtt &gt;&gt; <span class="number">1</span>) + TCP_DELACK_MAX));
    timeout = max_t(<span class="keyword">u32</span>, timeout, msecs_to_jiffies(<span class="number">10</span>));

    <span class="comment">/* If RTO is shorter, just schedule TLP in its place. */</span>
    <span class="comment">/* PTO = min(PTO, RTO) */</span>
    tlp_time_stamp = tcp_time_stamp + timeout;
    rto_time_stamp = (<span class="keyword">u32</span>)inet_csk(sk)-&gt;icsk_timeout;
    <span class="keyword">if</span> ((s32)(tlp_time_stamp - rto_time_stamp) &gt; <span class="number">0</span>) {
        s32 delta = rto_time_stamp - tcp_time_stamp;
        <span class="keyword">if</span> (delta &gt; <span class="number">0</span>)
            timeout = delta;
    }

    inet_csk_reset_xmit_timer(sk, ICSK_TIME_LOSS_PROBE, timeout, TCP_RTO_MAX);
    <span class="keyword">return</span> <span class="keyword">true</span>;
}

<span class="comment">// 在tcp_write_timer_handler中会根据event的类型，来做相应的处理</span>
<span class="comment">// 如果是PTO超时，则调用tcp_send_loss_probe(sk)来发送TLP探测包</span>
<span class="comment">/* When probe timeout (PTO) fires, send a new segment if one exists, else
 * retransmit the last segment.
 */</span>
void tcp_send_loss_probe(<span class="keyword">struct</span> sock *sk)
{
    ...
    <span class="comment">/*
     * 如果有新数据可以发送，则发新数据作为探测包
     * TLP用了一个push_one=2的trick来区分是正常的发送包，还是loss probe包
     */</span>
    <span class="keyword">if</span> (tcp_send_head(sk) != NULL) {        
        err = tcp_write_xmit(sk, mss, TCP_NAGLE_OFF, <span class="number">2</span>, GFP_ATOMIC);
        goto rearm_timer;
    }

    <span class="comment">/* At most one outstanding TLP retransmission */</span>
    <span class="keyword">if</span> (tp-&gt;tlp_high_seq)
        goto rearm_timer;

    <span class="comment">/* Retransmit last segment */</span>
    skb = tcp_write_queue_tail(sk);
    <span class="keyword">if</span> (WARN_ON(!skb))
        goto rearm_timer;

    <span class="comment">/* 省略一些判断tcp fragment的代码 */</span>

    <span class="comment">/* Probe with zero data doesn't trigger fast recovery */</span>
    <span class="keyword">if</span> (skb-&gt;len &gt; <span class="number">0</span>)
        err = <span class="number">__</span>tcp_retransmit_skb(sk, skb);

    <span class="comment">/* Record snd_nxt for loss detection */</span>
    <span class="keyword">if</span> (!likely(!err))
        tp-&gt;tlp_high_seq = tp-&gt;snd_nxt;

rearm_timer:
    <span class="comment">/* 重新安装RTO超时计时器 */</span>
    inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, inet_csk(sk)-&gt;icsk_rto, TCP_RTO_MAX);

    <span class="keyword">if</span> (likely(!err))   <span class="comment">/* 增加计数器的值，可以在/proc/net/snmp中看到，netstat -s也可以 */</span>
        NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSSPROBES);

    <span class="keyword">return</span>;
}
</code></pre><hr>
<h4 id="何时结束一个episode">何时结束一个episode</h4>
<pre><code><span class="comment">/* This routine deals with acks during a TLP episodes. */</span>
<span class="keyword">static</span> void tcp_process_tlp_ack(<span class="keyword">struct</span> sock *sk, <span class="keyword">u32</span> ack, <span class="keyword">int</span> flag)
{
    <span class="keyword">struct</span> tcp_sock *tp = tcp_sk(sk);
    <span class="comment">/* 判断TLP是否是多余的，及产生了多余的dupack。逻辑参考RFC */</span>
    <span class="keyword">bool</span> is_tlp_dupack = (ack == tp-&gt;tlp_high_seq) &amp;&amp;   
                         !(flag &amp; (FLAG_SND_UNA_ADVANCED | 
                                  FLAG_NOT_DUP | FLAG_DATA_SACKED));

    <span class="comment">/* Mark the end of TLP episode on receiving TLP dupack or when
     * ack is after tlp_high_seq.
     */</span>
    <span class="comment">/* 可见实现TLP时，选择了最多有一个TLP包发送出去，所以省去了RFC中的TLPRxtOut计数器 */</span>
    <span class="keyword">if</span> (is_tlp_dupack) {
        tp-&gt;tlp_high_seq = <span class="number">0</span>;
        <span class="keyword">return</span>;
    }

    <span class="keyword">if</span> (after(ack, tp-&gt;tlp_high_seq)) {
        tp-&gt;tlp_high_seq = <span class="number">0</span>;
        <span class="comment">/* Don't reduce cwnd if DSACK arrives for TLP retrans */</span>
        <span class="keyword">if</span> (!(flag &amp; FLAG_DSACKING_ACK)) {
            <span class="comment">/* 折腾这么一圈，最关键的就是降cwnd: ssthresh = 0.7*cwnd; cwnd=ssthresh */</span>
            tcp_init_cwnd_reduction(sk, <span class="keyword">true</span>);
            tcp_set_ca_state(sk, TCP_CA_CWR);
            tcp_end_cwnd_reduction(sk);
            tcp_set_ca_state(sk, TCP_CA_Open);
            NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPLOSSPROBERECOVERY);
        }
    }
}
</code></pre><blockquote>
<p>问题：代码什么地方体现了TLP中的Tail ?<br>&lt; 没有dupack收到，自然就认为是Tail了。并不需要想ER那样判断什么packets_out,sacked_out等。<br>这样的问题可能就是跟RTO抢活了。</p>
</blockquote>
<p>最后说一句，TLP的loss probe次数和loss recovery 次数Linux中都有相应的计数器跟踪，<br>分别对应LINUX_MIB_TCPLOSSPROBES，LINUX_MIB_TCPLOSSPROBERECOVERY。</p>
<hr>
<h4 id="TLP与ER的关系">TLP与ER的关系</h4>
<p>一句话总结  </p>
<pre><code>ER解决的是dupack不够用的情况
TLP解决的是没有dupack可用的情况
</code></pre><hr>
<hr>
<h3 id="TLP性能评测数据">TLP性能评测数据</h3>
<p><a href="http://www.net.in.tum.de/fileadmin/TUM/NET/NET-2014-03-1/NET-2014-03-1_01.pdf" target="_blank" rel="external">Measuring TCP Tail Loss Probe Performance</a>中的测试数据显示</p>
<pre><code>TLP <span class="keyword">is</span> able <span class="keyword">to</span> decrease <span class="keyword">the</span> total transfer <span class="property">time</span> <span class="keyword">in</span> high-speed networks <span class="keyword">by</span> <span class="number">38</span>% <span class="keyword">and</span> <span class="keyword">the</span> <span class="property">time</span> <span class="keyword">until</span> data <span class="keyword">is</span> retransmitted <span class="keyword">by</span> <span class="number">81</span>%.
These improvements decrease significantly <span class="keyword">for</span> higher <span class="command">delay</span> links.
</code></pre><p>文章中用到mininet和iptables的方式来模拟网络倒是点醒了我。之前我干嘛非得搭物理机环境啊。T_T  </p>
<p><a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2015/January/0000000-0000000.pdf" target="_blank" rel="external">An Evaluation of Tail Loss Recovery Mechanisms for TCP</a><br>文章评测了RTO Restart(RTOR)、TLP、TLPR三种技术对尾丢包情境性能的影响。都是TLPR得到的性能更好，当然TLP的性能也不赖。<br>RTOR这个技术主要解决的是现有RTO计时器在每次收到ACK后都会重新reset的问题。而RTOR的timer只要设置好，就不会随着dupack的到来而更改了。这个思路刚好解决了我看RTO代码时的疑问，又是脑洞大开啊。<br>看来paper还是要保持看下去啊，跟住研究的脚本才能了解技术的变迁。也能了解技术发展过程中的方方面面，而看内核代码只能了解被社区选用的技术(暂且不去评论社区选的好坏)。 </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01" target="_blank" rel="external">Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses Probe</a><br><a href="http://www.net.in.tum.de/fileadmin/TUM/NET/NET-2014-03-1/NET-2014-03-1_01.pdf" target="_blank" rel="external">Measuring TCP Tail Loss Probe Performance</a><br><a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2015/January/0000000-0000000.pdf" target="_blank" rel="external">An Evaluation of Tail Loss Recovery Mechanisms for TCP</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>Early Retransmit机制解决了dupack较少，无法触发快速重传的问题。<br>但是如果发生了尾丢包，由于尾包后面没有更多的数据包，也就没有办法触发任何的dupack。<br>为解决这种尾丢包的问题，Google的几位大神提出了TLP算法。通过TLP算法，发送一个loss probe包，来产生足够的SACK/FACK的信息来触发RF。根据Google的测试，TLP能够有效的避免较长的RTO超时，进而提高TCP性能。  </p>
]]>
    
    </summary>
    
      <category term="tlp" scheme="http://perthcharles.github.com/tags/tlp/"/>
    
      <category term="rfc" scheme="http://perthcharles.github.com/tags/rfc/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Early Retransmit for TCP]]></title>
    <link href="http://perthcharles.github.com/2015/10/31/wiki-network-tcp-early-retrans/"/>
    <id>http://perthcharles.github.com/2015/10/31/wiki-network-tcp-early-retrans/</id>
    <published>2015-10-31T02:00:21.000Z</published>
    <updated>2015-10-31T10:52:50.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>Early Retransmit(ER)机制的提出主要解决的是在某些特定场景下，没有足够的<br>dupack触发fast retransmit造成的问题。<br>本质上就是通过检测出某些考虑到的特定场景，然后降低触发FR的dupack threshold值。<br>具体需要考虑那些特定场景后续后详细介绍。  </p>
<a id="more"></a>  

<hr>
<h3 id="RFC5827解读">RFC5827解读</h3>
<p>ER要解决的问题:<br>当无法收到足够的dupack时，TCP标准的Fast Retransmit机制无法被<br>触发，只能等待RTO超时才能进行丢包的重传。而RTO超时不管是时间等待代价，还是<br>性能损耗代价都很大。</p>
<p>ER的解决方法:<br>检测出无法收到足够dupack的场景，进而降低dupack threshold来触发快速重传。<br>从而避免等待RTO超时重传，对性能造成较大的损耗。  </p>
<p>TCP中的标准的重传机制:<br>a. 如果超过RTO时间没有收到ACK包，则会触发RTO超时机制。代价就是cwnd=1，慢启动<br>b. 如果收到三个重复dupack，则会触发快速重传。代价是cwnd减半(视congestion算法而定)，拥塞避免</p>
<p>为什么需要等三个重复dupack ？<br>那是因为dupack即可能是丢包造成的，也可能是网络乱序造成的。所以那帮设计标准的<br>牛牛们，一方面拍拍脑袋，一方面测点实验数据定了这么一个值：3。<br>倒也正好吻合了一句古话：事不过三。哈哈</p>
<p>但是阈值设置为三，也存在一些问题。<br>比如当cwnd较小时(比如3)，当发生丢包后，可能就无法产生足够的dupack来触发快速重传。<br>结果就是只能靠RTO超时来重传丢包了。  </p>
<p>那么什么情况下cwnd会比较小呢？</p>
<pre><code><span class="bullet">1. </span>TCP流经过的链路bandwidth-delay product (BDP)很小，就会导致很小的cwnd

<span class="bullet">2. </span>应用层限制，没有足够的数据可以发送，进而导致cwnd一直很小

<span class="bullet">3. </span>由于接收端的接收窗口的限制，导致cwnd很小
</code></pre><hr>
<p>总结下，出现dupack不够的情况：<br>a. cwnd较小<br>b. 发送窗口里大量的数据包都被丢失了<br>c. 在数据发送的尾端发生丢包时  </p>
<p>但是，上面各种极端的case有共同的特点：<br>m. 无法产生足够的dupack<br>n. 没有新的数据包可以发送进入网络  </p>
<p>Early Retransmit机制就是在判断条件m和n都成立后，选择降低触发Fast Retransmit<br>的阈值，来避免只能通过RTO超时重传的问题。  </p>
<hr>
<h4 id="ER算法">ER算法</h4>
<p>名词解释</p>
<pre><code><span class="label">oseg:</span> outstanding segments, segements sent but not yet acknowledged
    并且是没有被累计确认！及内核中的snd_nxt - snd_una

<span class="label">ER_thresh:</span> 启用ER算法后，触发快速重传的dupack个数阈值
</code></pre><p>算法逻辑</p>
<pre><code>ER_thresh = <span class="number">3</span>   <span class="comment">// 等于3，表示还是标准的FR算法</span>
<span class="keyword">if</span> (oseg &lt; <span class="number">4</span> &amp;&amp; <span class="keyword">new</span> data cannot be sent)    <span class="comment">// 如果满足条件，考虑启用ER算法</span>
    <span class="keyword">if</span> (SACK <span class="keyword">is</span> unsupport)                  <span class="comment">// 如果SACK选项不支持，则使用oseg-1作为阈值</span>
        ER_thresh = oseg - <span class="number">1</span>
    elif (SACKed packet == oseg-<span class="number">1</span>)          <span class="comment">// 否则，只有当oseg-1个包被SACK，才能启用ER    </span>
        ER_thresh = oseg - <span class="number">1</span>
</code></pre><p>RFC的算法的算法主要是看个思路，具体算法的实现和逻辑细节还是要看代码。<br>The code in the real world is another cat compared with RFC’s.  </p>
<hr>
<h4 id="开启SACK的必要性">开启SACK的必要性</h4>
<p>总的来说就是更推荐使用SACK选项的方法  </p>
<pre><code>假设发送了三个数据包，S1，S2，S3，但是S2被丢弃了。
当S1到达接收端时，它是按序到达的。接收方可能会delay这个ACK，所以分两种情况讨论：

a. S1的ack被delay了：这种情况下S3的接收会触发一个ACK被发送（因为delay ack
   机制最多能delay一个数据包）。那么此时如果没有带SACK信息，发送发就会收到
   一个正常的ACK，而不是dupack。这样一个dupack都没有收到过，所以也就不会触发
   ER机制，而只能靠RTO超时来进行重传(而且S2和S3都要重传)。
   而如果有SACK信息，<span class="variable">oseg=</span><span class="number">1</span>，进而ER算法就能被启用。
   具体就是：支持SACK，<span class="variable">oseg=</span><span class="number">1</span>, <span class="variable">oseg-1=</span><span class="number">0</span>     =&gt; 启用ER
             不支持SACK，<span class="variable">oseg=</span><span class="number">2</span>, <span class="variable">oseg-1=</span><span class="number">1</span>   =&gt; 无法启用ER，因为没收到任何dupack

b. 如果ack没有被delay，ER都能被启用。
   具体就是：支持SACK，<span class="variable">oseg=</span><span class="number">1</span>, <span class="variable">oseg-1=</span><span class="number">0</span>     =&gt; 启用ER
             不支持SACK，<span class="variable">oseg=</span><span class="number">2</span>, <span class="variable">oseg-1=</span><span class="number">1</span>   =&gt; 启用ER
</code></pre><hr>
<h4 id="ER的问题">ER的问题</h4>
<p>核心意思就是：如果一条TCP流，cwnd一直很小，然后cwnd内发送的数据<br>每次都乱序到达接收端，这样使用ER算法就可能导致较多的spurious retransmit。<br>比如cwnd=2，而每次这两个包都reorder，结果就是发两个数据包，就ER重传一个。</p>
<p>是的，这就叫TCP设计里面常提到的pathological case.  </p>
<p>一种可能的解决办法就是发送一个TCP层data payload=0的包去增加dupack的个数，<br>但是这会一定程度上浪费网络资源。暂时未找到采用了这一思想的TCP实现。  </p>
<hr>
<h4 id="解决降低DupACK阈值可能带来的问题">解决降低DupACK阈值可能带来的问题</h4>
<p>RFC附录提到了三种缓解ER可能带来问题的方法，具体如下<br>a. 判断ER是否发送了多次spurious retransmit数据，利用的手段就是D-SACK技术<br>b. 如果无法判断ER是否发送了spurious retransmit，则可以暴力的设置一个固定值来限制ER被触发的次数<br>c. 当需要触发ER机制时，等待一个固定长度的时间再重传。<br>   Linux默认选用这种方式</p>
<hr>
<hr>
<h3 id="源码分析">源码分析</h3>
<p>下面的源码分析，基于Linux3.10版本  </p>
<hr>
<h4 id="是否开启ER功能">是否开启ER功能</h4>
<p>既然RFC中说了ER还是实验性的，而不是标准。故Linux kernel提供了选项来开启或关闭ER功能。<br>开关的名字是tcp_early_retrans，当然3.10的代码中还有Tail Loss Probe(TLP)的内容，暂时咱可以<br>忽略，之后再写一篇关于TLP的wiki。 </p>
<pre><code>sysctl_tcp_early_retrans (defalut:<span class="number">3</span>)
    <span class="number">0</span> disables ER
    <span class="number">1</span> enables ER
    <span class="number">2</span> enables ER but delays fast recovery <span class="operator">and</span> fast retransmit <span class="keyword">by</span> <span class="operator">a</span>
    <span class="keyword">fourth</span> <span class="operator">of</span> RTT.
    <span class="number">3</span> enables delayed ER <span class="operator">and</span> TLP.
    <span class="number">4</span> enables TLP only.
</code></pre><p>具体的判断函数就是在TCP sock初始化(tcp_init_sock)时，调用tcp_enable_early_retrans()<br>来判断是否开启  </p>
<pre><code>static inline <span class="keyword">void</span> tcp_enable_early_retrans(<span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *tp)
</span>{
    tp-&gt;do_early_retrans = 
        sysctl_tcp_early_retrans &amp;&amp;         <span class="comment">/* ER开关是否开启 */</span>
        sysctl_tcp_early_retrans &lt; <span class="number">4</span> &amp;&amp;     <span class="comment">/* ER开关是否开启 */</span>
        !sysctl_tcp_thin_dupack &amp;&amp;          <span class="comment">/* 只有关闭thin-dupack才开ER */</span>
        sysctl_tcp_reordering == <span class="number">3</span>;         <span class="comment">/* 需要默认的reordering是3菜开ER */</span>
}
</code></pre><p>根据3.10内核默认的配置，ER是默认开启的，也就是tp-&gt;do_early_retrans默认等于1</p>
<p>当然了，在下面几种情况下也会disable ER<br>a. 应用程序通过setsockopt设置了TCP_THIN_DUPACK<br>b. TCP层发现了reorder，调用tcp_update_reordering尝试更新了reorder值<br>c. 配置了TCP_METRIC_REORDERING值，改变了reordering值</p>
<hr>
<h4 id="判断是否触发FR中ER判断部分">判断是否触发FR中ER判断部分</h4>
<p>tcp_time_to_recoever这个函数就是判断是否该触发FR的函数  </p>
<pre><code><span class="keyword">static</span> <span class="keyword">bool</span> tcp_time_to_recover(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> flag)
{
    ...

    <span class="comment">/* Trick#6: TCP early retransmit, per RFC5827. To avoid spurious
     * retransmissions due to small network reorderings, we implement
     * Mitigation A.3 in the RFC and delay the retransmission for a short
     * interval if appropriate.
     */</span>
    <span class="keyword">if</span> (tp-&gt;do_early_retrans &amp;&amp;                     <span class="comment">/* 内核配置是否开启ER */</span>
        !tp-&gt;retrans_out &amp;&amp;                         <span class="comment">/* 当前没有重传数据 */</span>
        tp-&gt;sacked_out &amp;&amp;                           <span class="comment">/* 当前收到了dupack */</span>
        tp-&gt;packets_out &lt; <span class="number">4</span> &amp;&amp;                      <span class="comment">/* packets_out很小, 及RFC oseg &lt; 4 */</span>
        tp-&gt;packets_out &gt;= (tp-&gt;sacked_out + <span class="number">1</span>) &amp;&amp;  <span class="comment">/* dupack个数满足ER/TLP条件 */</span>
        !tcp_may_send_now(sk))                      <span class="comment">/* 没有新数据可发送 */</span>
        <span class="keyword">return</span> !tcp_pause_early_retransmit(sk, flag);   <span class="comment">/* 判断是否等待一段时间再触发ER */</span>

    <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 默认返回false，即不进入fast recovery阶段</span>
}
</code></pre><p>主要需要解释的变量，应该是tp-&gt;sacked_out。<br>如果没有开SACK选项，那么该值就是表示dupack的个数。具体可参考tcp_add_reno_sack()函数相关代码<br>如果开启了SACK选项，那么这个值无疑就是表示被SACK的乱序包的个数。具体可参考tcp_sacktag_one()函数相关代码。  </p>
<p>另外，观察仔细的人也许会发现”tp-&gt;packets_out &gt;= (tp-&gt;sacked_out + 1)”与ER的RFC不一致，<br>应该是’==’，而不是’&gt;=’。至于为什么代码中是这样修改的，暂时还不明确。<br>但可以确定的是这个概念是由于TLP算法的引入而改变的，具体的修改发生在<a href="https://github.com/torvalds/linux/commit/6ba8a3b19e764b6a65e4030ab0999be50c291e6c#diff-d06665370d013ab0df986a88d8e3a128" target="_blank" rel="external">Nandita的这个patch中</a>  </p>
<hr>
<h4 id="等四分之一RTT再触发ER">等四分之一RTT再触发ER</h4>
<p>Linux中选择了等待四分之一RTT再触发ER的方式，来缓解降低dupack threshold可能带来的问题。<br>相关代码在tcp_pause_early_retransmit()中  </p>
<pre><code><span class="comment">// 返回false表示立即进入FR，即立即触发ER；返回ture则是等待一个超时时间后再进入FR</span>
<span class="keyword">static</span> <span class="keyword">bool</span> tcp_pause_early_retransmit(<span class="keyword">struct</span> sock *sk, <span class="keyword">int</span> flag)
{
    <span class="keyword">struct</span> tcp_sock *tp = tcp_sk(sk);
    <span class="keyword">unsigned</span> <span class="keyword">long</span> delay;

    <span class="comment">/* Delay early retransmit and entering fast recovery for
     * max(RTT/4, 2msec) unless ack has ECE mark, mo RTT samples
     * available, or RTO is scheduled to fire first.
     */</span>
    <span class="keyword">if</span> (sysctl_tcp_early_retrans &lt; <span class="number">2</span> ||     <span class="comment">/* kernel就没开delay ER的功能*/</span>
        sysctl_tcp_early_retrans &gt; <span class="number">3</span> ||     <span class="comment">/* kernel跟本就没开ER功能(这个地方与do_early_retrans的判断有重复，感觉有点多余) */</span> 
        (flag &amp; FLAG_ECE) ||                <span class="comment">/* ECE mark，ECN-Echo, Explict Congestion Notification */</span>
        !tp-&gt;srtt)                          <span class="comment">/* 没有RTT采样 */</span>
        <span class="keyword">return</span> <span class="literal">false</span>;

    delay = max_t(<span class="keyword">unsigned</span> <span class="keyword">long</span>, (tp-&gt;srtt &gt;&gt; <span class="number">5</span>), msecs_to_jiffiec(<span class="number">2</span>));     <span class="comment">/* 计算delay ER的时间 */</span>
    <span class="keyword">if</span> (!time_after(inet_csk(sk)-&gt;icsk_timeout, (jiffies + delay)))         <span class="comment">/* 如果RTO先超时 */</span>
        <span class="keyword">return</span> <span class="literal">false</span>;

    <span class="comment">// 设置ER超时计时器</span>
    inet_csk_reset_xmit_timer(sk, ICSK_TIME_EARLY_RETRANS, delay, TCP_RTO_MAX);
    <span class="keyword">return</span> <span class="literal">true</span>;
}
</code></pre><p>ICSK_TIME_EARLY_RETRANS超时后，会调用tcp_resume_early_retransmit(sk)  </p>
<pre><code><span class="keyword">void</span> tcp_resume_early_retransmit(<span class="keyword">struct</span> sock *sk)
{
    strcut tcp_sock *tp = tcp_sk(sk);

    tcp_rearm_rto(sk);  <span class="comment">// 重设RTO计时器</span>

    <span class="comment">/* Stop if ER is disabled after the delayed ER timer is sheduled */</span>
    <span class="keyword">if</span> (!tp-&gt;do_early_retrans)
        <span class="keyword">return</span>;

    <span class="comment">// 进入快速重传阶段</span>
    tcp_enter_recovery(sk, <span class="keyword">false</span>);
    tcp_update_scoreboard(sk, <span class="number">1</span>);
    tcp_xmit_retransmit_queue(sk);
}
</code></pre><hr>
<p>说一句题外话，TCP的具体设计经常需要考虑很多极端的case。<br>这类case，以前一般也就称之为corner case。但是越看RFC，越发现corner已经不足以<br>形容TCP设计的严谨性了，只能用pathological了。T_T</p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tools.ietf.org/html/rfc5827" target="_blank" rel="external">RFC 5827</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>Early Retransmit(ER)机制的提出主要解决的是在某些特定场景下，没有足够的<br>dupack触发fast retransmit造成的问题。<br>本质上就是通过检测出某些考虑到的特定场景，然后降低触发FR的dupack threshold值。<br>具体需要考虑那些特定场景后续后详细介绍。  </p>
]]>
    
    </summary>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="rfc" scheme="http://perthcharles.github.com/tags/rfc/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在Linux上探测TCP的内部状态]]></title>
    <link href="http://perthcharles.github.com/2015/10/28/inspecting-internal-tcp-state/"/>
    <id>http://perthcharles.github.com/2015/10/28/inspecting-internal-tcp-state/</id>
    <published>2015-10-28T13:28:11.000Z</published>
    <updated>2015-10-28T14:27:48.000Z</updated>
    <content type="html"><![CDATA[<p>发现一篇使用ss获取TCP内部状态信息的好文，不由的记录一笔。<br>并结合之前会的方法适当总结总结。<br><a id="more"></a>  </p>
<hr>
<h3 id="Inspecting_Internal_TCP_State_on_Linux"><a href="https://blogs.janestreet.com/inspecting-internal-tcp-state-on-linux/" target="_blank" rel="external">Inspecting Internal TCP State on Linux</a></h3>
<p>这种好文当然是推荐去读原文了，这里对文章中的方法只做简单摘要。<br>而这类相似方法还有哪些，以及各自的优缺点可以看看下一节的总结。  </p>
<pre><code><span class="comment">// 可查看尽量多的显示socket相关的内部信息  </span>
<span class="preprocessor"># ss -eipn  </span>

Internally, ss uses the tcp_diag kernel module to extract
information (<span class="keyword">this</span> is done via an<span class="constant"> AF_NETLINK </span>socket).

<span class="comment">// 通过crash根据sk的内存地址，获取更多的sk结构体item信息</span>
<span class="preprocessor"># sudo crash -e emacs</span>

crash &gt; <span class="keyword">struct</span> tcp_sock.rcv_nxt,snd_una,reordering ffff8802305a0800
</code></pre><hr>
<h3 id="总结">总结</h3>
<p>目前掌握的获取TCP内部状态的方法，这里讨论的方法都是不需要额外在内核中做开发的：<br>a. 使用tcp_probe内核模块<br>改改tcp_probe几乎可以获取TCP内部的任何状态<br>具体怎么使用tcp_probe模块，在之前的<a href="http://perthcharles.github.io/2014/12/19/tcp-probe-intro/" target="_blank" rel="external">这篇博客</a>中有详细的介绍。  </p>
<pre><code>优点(考虑适当自定制该模块)：
    1. 功能性：可查看TCP流的几乎所有的内部状态
    2. 灵活性：定制一次必须重编一次模块
缺点：
    1. 功能性：不适合线上设备使用，大量不同流的信息混在一起简直是灾难(如何有效的使用过滤策略是一个好问题)
    2. 可用性：如果没有kernel-devel包，无法自定制编译使用内核模块
</code></pre><p>b. 使用systemtap脚本  </p>
<pre><code>优点：
    <span class="number">1</span>. 功能性：几乎可以探测TCP流在任何处理逻辑(内联函数是一个痛点)处的信息
    <span class="number">2</span>. 灵活性：方便设置过滤策略，(相对tcp_probe而言)可方便的统计出想要的信息。
       不管是通过指定脚本参数，还是直接修改脚本，都比修改tcp_probe内核模块方便
缺点：
    <span class="number">1</span>. 可用性：依赖kernel-devel, kernel-debuginfo, kernel-debuginfo-<span class="built_in">common</span>包
       而为了避免暴露自定制内核的内部实现，这些包默认都是不安装的
</code></pre><p>c. ss+crash<br>如果只需要ss默认支持的信息，那这种方法当然是最佳的。<br>但可信的就是ss默认支持的信息，还是太少，因此可能需要crash来补充  </p>
<pre><code>优点：
    <span class="number">1</span>. 功能性：在仅需要<span class="literal">ss</span>默认支持的信息时，最实用。只要安装<span class="literal">ss</span>软件即可
       本质上<span class="literal">ss</span>输出的信息，是内核统计的，<span class="literal">ss</span>只是一个输出工具而已
缺点：
    <span class="number">1</span>. 功能性：受限于内核统计的信息，受限与<span class="literal">ss</span>工具的选择的输出信息
    <span class="number">2</span>. 可用性：如果试图通过<span class="literal">ss</span>得到的sk内存地址，利用crash进一步获得信息，则需要内核image能找到。
       这点在线上设备上也显然是不现实的
</code></pre><p>不过受ss+crash这种方法的启发，既然能拿到sk结构体的内存地址，有没有更简单，<br>方便的方法来获取sk内部item的值呢？<br>如果大家有更好的方法，非常欢迎留言交流。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>发现一篇使用ss获取TCP内部状态信息的好文，不由的记录一笔。<br>并结合之前会的方法适当总结总结。<br>]]>
    
    </summary>
    
      <category term="ss" scheme="http://perthcharles.github.com/tags/ss/"/>
    
      <category term="crash" scheme="http://perthcharles.github.com/tags/crash/"/>
    
      <category term="networking" scheme="http://perthcharles.github.com/categories/networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记(第三期)]]></title>
    <link href="http://perthcharles.github.com/2015/10/26/wiki-weekly-readlist-20151026/"/>
    <id>http://perthcharles.github.com/2015/10/26/wiki-weekly-readlist-20151026/</id>
    <published>2015-10-26T13:30:23.000Z</published>
    <updated>2015-11-02T14:49:30.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="DigitalOcean如何在红海市场做用户增长"><a href="https://strace.co/cn/post/growth-hacking-digitalocean.html" target="_blank" rel="external">DigitalOcean如何在红海市场做用户增长</a></h2>
<pre><code>摘要：
    1. 先确立独特点，研究增长计划  
    2. 做产品而非服务，产品更容易扩张  
    3. 加入创业加速器，获得初期用户和商业关系网络  
    4. 漂亮的增长数字和对未来清晰的定位，是打动顶级风投的亮点
    5. Freemium模式
    6. 获取并了解前100个客户(找一个高水准的技术聚会是一个很好的切入点)
    7. 针对高智商的开发者用户的口碑营销和社区营销
    8. 测量各个推广渠道的转化率
点评：
    1. 学到一个新词：<span class="function">freemium</span>(免费增值),即通过为少部分有更高需求的用户提供增值服务赢利
    2. digitalocean在linode已经拥有大量客户的时候，才进入VPS服务器这个红海市场，
       依然能做起来。至今成为行业第二，足以说明它的战术和战略都是很成功的。
       找机会得去体验一把digitalocean。
</code></pre><a id="more"></a>  

<hr>
<h2 id="好的架构是进化来的，不是设计来的"><a href="http://news.oneapm.com/shenjian-oneapm-course/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">好的架构是进化来的，不是设计来的</a></h2>
<pre><code>摘要：
    <span class="number">1.</span> 创业初期，成本是设计架构的重要因素
    <span class="number">2.</span> 在每一个阶段，找到对应该阶段网站架构所面临的问题，然后在不断解决这些问题的过程中，
       真个战略的架构就是在不断的演进了
    <span class="number">3.</span> 第一阶段：<span class="literal">ALL</span> <span class="keyword">IN</span> ONE。特点：单机系统，程序耦合，逻辑核心是CURD
    <span class="number">4.</span> 中等规模：流量跨过十万阶段，数据库成为瓶颈。特点：分布式系统，动静分离，读写分离
    <span class="number">5.</span> 进一步：静态数据使用CDN服务，MVC结构，负载均衡
    <span class="number">6.</span> 大流量：将整个windows技术体系转向了Java体系
    <span class="number">7.</span> 高可用：进一步垂直拆分，分层抽象，水平拆分
    <span class="number">8.</span> 技术：反向代理，智能DNS
    <span class="number">9.</span> 当架构变成蜘蛛网，人肉已很难搞定
点评：
    <span class="number">1.</span> 架构这个东西不是想出来的，而是做出来的
    <span class="number">2.</span> 同时，做也要聪明的做。前期好的设计，好的远见很重要
    <span class="number">3.</span> learn <span class="keyword">to</span> <span class="keyword">do</span>(学会去做), learning <span class="keyword">by</span> doing(从实践中学)
</code></pre><hr>
<h2 id="The_50_Most_Popular_MOOCs_of_All_Time"><a href="http://www.onlinecoursereport.com/the-50-most-popular-moocs-of-all-time/" target="_blank" rel="external">The 50 Most Popular MOOCs of All Time</a></h2>
<pre><code>摘要：
    <span class="number">50.</span> Internet History, Technology, <span class="operator">and</span> Security / University <span class="operator">of</span> Michigan
    <span class="number">39.</span> Social Network Analysis / University <span class="operator">of</span> Michigan
    <span class="number">37.</span> Introduction <span class="built_in">to</span> Databases / Stanford University
    <span class="number">34.</span> Statistics – Making Sense <span class="operator">of</span> Data / University <span class="operator">of</span> Toronto
    <span class="number">33.</span> Critical Thinking <span class="operator">in</span> Global Challenges / The University <span class="operator">of</span> Edinburgh
    <span class="number">29.</span> A History <span class="operator">of</span> <span class="operator">the</span> World Since <span class="number">1300</span> / Princeton University
    <span class="number">28.</span> Justice / Harvard University
    <span class="number">23.</span> Data Analysis / Johns Hopkins Bloomberg School
    <span class="number">20.</span> Introduction <span class="built_in">to</span> Financial Accounting / University <span class="operator">of</span> Pennsylvania / Wharton
    <span class="number">17.</span> Financial Markets / Yale University
    <span class="number">16.</span> Computational Investing, Part I / Georgia Institute <span class="operator">of</span> Technology
    <span class="number">9.</span> Think Again: How <span class="built_in">to</span> Reason <span class="operator">and</span> Argue / Duke University
    <span class="number">2.</span> Introduction <span class="built_in">to</span> Philosophy / University <span class="operator">of</span> Edinburgh
</code></pre><hr>
<h2 id="相信技术的力量，出门问问获谷歌投资"><a href="http://www.infoq.com/cn/news/2015/10/chumenwenwen-the-new-milestone" target="_blank" rel="external">相信技术的力量，出门问问获谷歌投资</a></h2>
<pre><code>点评：了解了解出门问问
</code></pre><p>相关阅读:<br><a href="http://www.ifanr.com/378180" target="_blank" rel="external">出门问问李志飞：我们想做 Google 那样的公司</a><br><a href="http://www.csdn.net/article/2014-11-13/2822638-From-Hardcore-Coder-to-Startup-TechManager" target="_blank" rel="external">雷欣：从技术极客到核心管理的秘密</a><br><a href="http://www.huxiu.com/article/42572/1.html" target="_blank" rel="external">出门问问CEO李志飞: 那些牛逼的工程师适合创业吗?</a>  </p>
<hr>
<h2 id="Five_Things_Old_Programmers_Should_Remember"><a href="https://medium.com/@garywiz/five-things-old-programmers-need-to-remember-e78caf0b0973?imm_mid=0daeb8&amp;cmp=em-prog-na-na-newsltr_20151024#.bpqamw9yz" target="_blank" rel="external">Five Things Old Programmers Should Remember</a></h2>
<pre><code>摘要：
    <span class="number">1.</span> The industry I joined was an industry <span class="keyword">of</span> specialists.
       Commitment <span class="keyword">and</span> discipline were a requirement. 
    <span class="number">2.</span> <span class="keyword">If</span> I may be so bold, it was a mistake <span class="keyword">for</span> you <span class="keyword">to</span> accept promotion.
       Commanding a starship <span class="keyword">is</span> your first, best destiny;
       anything <span class="keyword">else</span> <span class="keyword">is</span> a waste <span class="keyword">of</span> material. — Spock (引自星际迷航)
    <span class="number">3.</span> It’s what you signed up <span class="keyword">for</span>, <span class="keyword">and</span> <span class="keyword">if</span> you really want <span class="keyword">to</span> contribute,
       you need <span class="keyword">to</span> rope <span class="keyword">in</span> the demons <span class="keyword">of</span> getting old <span class="keyword">and</span> be different
       than most everybody you grew up <span class="keyword">with</span>. Go out <span class="keyword">on</span> a limb, <span class="keyword">and</span> enjoy
       the fact that life <span class="keyword">is</span> <span class="keyword">not</span> ending, it <span class="keyword">is</span> always just beginning.
    <span class="number">4.</span> Just <span class="keyword">like</span> any accessible sport, most people are amateurs,
       a few have promise, <span class="keyword">and</span> very few reach the Olympics.
    <span class="number">5.</span> Your Health <span class="keyword">Is</span> Your <span class="keyword">New</span> Business Partner.
点评：
    <span class="number">1.</span> 选你所爱，爱你所选
    <span class="number">2.</span> <span class="keyword">do</span> one thing, <span class="keyword">do</span> onething perfectly
    <span class="number">3.</span> 安心做技术人，忌浮躁。太多的潜力项目、公司都是被半吊子的技术型管理人员搞挂的。
       <span class="keyword">Do</span> <span class="keyword">not</span> be one <span class="keyword">of</span> them !
    <span class="number">4.</span> 这篇博文给国内一种<span class="string">"程序员是年轻人的职业"</span>的论调一记响亮的耳光。
       博主和评论中的诸多older coders都非常高龄。
    <span class="number">5.</span> 正确看待你的工作，用心认真对待它。它是你的事业，也是一生中重要的标记，可以引以为豪的标记。
</code></pre><hr>
<h2 id="过一过ArchSummit的PPT">过一过ArchSummit的PPT</h2>
<p>百度云盘地址: <a href="http://pan.baidu.com/s/1hqngEqg" target="_blank" rel="external">http://pan.baidu.com/s/1hqngEqg</a></p>
<hr>
<h2 id="不要使用公共DNS服务"><a href="http://mawenjian.net/p/281.html" target="_blank" rel="external">不要使用公共DNS服务</a></h2>
<p>多一些看待公共DNS服务的视角</p>
<hr>
<h2 id="过一个QCon的PPT">过一个QCon的PPT</h2>
<p>重点了解跟网络相关的部分，无论网络运维、网络虚拟化、网络加速、网络架构、网络加速。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="DigitalOcean如何在红海市场做用户增长"><a href="https://strace.co/cn/post/growth-hacking-digitalocean.html" target="_blank" rel="external">DigitalOcean如何在红海市场做用户增长</a></h2>
<pre><code>摘要：
    1. 先确立独特点，研究增长计划  
    2. 做产品而非服务，产品更容易扩张  
    3. 加入创业加速器，获得初期用户和商业关系网络  
    4. 漂亮的增长数字和对未来清晰的定位，是打动顶级风投的亮点
    5. Freemium模式
    6. 获取并了解前100个客户(找一个高水准的技术聚会是一个很好的切入点)
    7. 针对高智商的开发者用户的口碑营销和社区营销
    8. 测量各个推广渠道的转化率
点评：
    1. 学到一个新词：<span class="function">freemium</span>(免费增值),即通过为少部分有更高需求的用户提供增值服务赢利
    2. digitalocean在linode已经拥有大量客户的时候，才进入VPS服务器这个红海市场，
       依然能做起来。至今成为行业第二，足以说明它的战术和战略都是很成功的。
       找机会得去体验一把digitalocean。
</code></pre>]]>
    
    </summary>
    
      <category term="digitalocean" scheme="http://perthcharles.github.com/tags/digitalocean/"/>
    
      <category term="wiki-阅读周记" scheme="http://perthcharles.github.com/categories/wiki-%E9%98%85%E8%AF%BB%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记(第二期)]]></title>
    <link href="http://perthcharles.github.com/2015/10/19/wiki-weekly-readlist-20151019/"/>
    <id>http://perthcharles.github.com/2015/10/19/wiki-weekly-readlist-20151019/</id>
    <published>2015-10-19T02:57:45.000Z</published>
    <updated>2015-10-26T01:31:07.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="从学渣到学霸_-_我的100天阅读简史"><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTA3MjUwMA==&amp;mid=400032224&amp;idx=1&amp;sn=335f870597a6f888d219daf687357fdd&amp;scene=2&amp;srcid=1018D0eWR4z8X0yo9xV2Gg0s&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="external">从学渣到学霸 - 我的100天阅读简史</a></h2>
<pre><code>点评：
    1. 行动力是第一的，有想法就要去实际动手。作者就是一个行动派，敬佩！  
    2. 每天早上起床后的时间，也是可以利用的。对我个人而言，早睡一会，早起一个小时。然后利用这一个小时，花几个番茄钟去读书！
    3. 对于不同的性质的书，要采用不同的方式阅读  
    4. 自己能够成为一个行动派？真正成为一个爱读书的人？纸上得来终觉浅，绝知此事要躬行。  
    5. 每读完一段书，写一个短评(如125字)去总结，是一个便于梳理知识的好方法。  
</code></pre><a id="more"></a>  

<hr>
<h2 id="一个可以显示Linux命令运行进度的伟大工具"><a href="https://linux.cn/article-4741-weibo.html" target="_blank" rel="external">一个可以显示Linux命令运行进度的伟大工具</a></h2>
<pre><code>摘要：
    <span class="number">1</span>. Coreutils Viewer（cv）是一个简单的程序，它可以用于显示任何核心组件命令
    （如：<span class="keyword">cp</span>、mv、dd、tar、gzip、gunzip、<span class="keyword">cat</span>、<span class="keyword">grep</span>、fgrep、egrep、cut、<span class="built_in">sort</span>、xz、exiting）的进度
点评：
    <span class="number">1</span>. 不过感觉没那么实用，就指放在这里做个备忘吧  
</code></pre><hr>
<h2 id="网易163/126邮箱过亿数据泄漏"><a href="http://www.wooyun.org/bugs/wooyun-2015-0147763" target="_blank" rel="external">网易163/126邮箱过亿数据泄漏</a></h2>
<pre><code>点评：
    网络世界无安全啊，还是忧伤的去改相关密码吧。  
</code></pre><hr>
<h2 id="What’s_New_in_CPUs_Since_the_80s_and_How_Does_It_Affect_Programmers?"><a href="http://danluu.com/new-cpu-features/" target="_blank" rel="external">What’s New in CPUs Since the 80s and How Does It Affect Programmers?</a></h2>
<pre><code>摘要：
    <span class="number">1.</span> Memory/Caches: The solution <span class="keyword">to</span> <span class="keyword">the</span> problem <span class="keyword">of</span> having relatively slow memory has been <span class="keyword">to</span> add
       caching, which provides fast access <span class="keyword">to</span> frequently used data, <span class="keyword">and</span> prefetching, which preloads
       data <span class="keyword">into</span> caches <span class="keyword">if</span> <span class="keyword">the</span> access pattern <span class="keyword">is</span> predictable.  
    <span class="number">2.</span> TLBs(CPU中最重要的特殊功能的cache):
        a. TLBs, which are caches <span class="keyword">for</span> virtual memory lookups(done via
           a <span class="number">4</span>-level page table structure <span class="function_start"><span class="keyword">on</span></span> x86). 
        b. If you use <span class="number">4</span>k pages, <span class="keyword">the</span> limited size <span class="keyword">of</span> TLBs limits <span class="keyword">the</span> amount
           <span class="keyword">of</span> memory you can address <span class="keyword">without</span> incurring a TLB miss.
        c. X87 also supports <span class="number">2</span>MB <span class="keyword">and</span> <span class="number">1</span>GB pages; <span class="keyword">some</span> applications will
           benefits a lot <span class="keyword">from</span> using larger page sizes.
        d. Also, <span class="keyword">first</span>-level caches are ususally limited <span class="keyword">by</span> <span class="keyword">the</span> page size <span class="keyword">times</span>
           <span class="keyword">the</span> associativity <span class="keyword">of</span> <span class="keyword">the</span> cache. 
           Haswell has an <span class="number">8</span>-way associative cache <span class="keyword">and</span> <span class="number">4</span>kB pages. Its L1 data cache
           <span class="keyword">is</span> `<span class="number">8</span> * <span class="number">4</span> kB = <span class="number">32</span>kB.
    <span class="number">3.</span> Out <span class="keyword">of</span> Order Execution/Serialization: For a couple decades now, x86 chips
       have been able <span class="keyword">to</span> speculatively execute <span class="keyword">and</span> re-order execution(<span class="keyword">to</span> avoid
       blocking <span class="function_start"><span class="keyword">on</span></span> a single stalled resource).
    <span class="number">4.</span> Memory/Concurrency(即多核):
        a. <span class="keyword">if</span> core0 <span class="keyword">and</span> core1 interact, there’s no guarantee <span class="keyword">that</span> their interaction <span class="keyword">is</span> ordered.
        b. To make a sequence atomic, we can use xchg <span class="keyword">or</span> cmpxchg, which are always locked <span class="keyword">as</span> compare-<span class="keyword">and</span>-swap primitives.
    <span class="number">5.</span> Memory/Non-Temporal Stores/Write-Combine Memory:
        a. UC memory: uncacheable memory
        b. WC: <span class="command">write</span> combine
        c. WC <span class="keyword">is</span> kind <span class="keyword">of</span> eventually consistent UC. Writes have <span class="keyword">to</span> eventually
           make <span class="keyword">it</span> <span class="keyword">to</span> memory, <span class="keyword">but</span> they can be buffered internally.
    <span class="number">6.</span> Memory/NUMA:
        a. Non-uniform memory access, <span class="keyword">where</span> memory latencies <span class="keyword">and</span> bandwidth are
           different <span class="keyword">for</span> different processors.
        b. The takeaway here <span class="keyword">is</span> <span class="keyword">that</span> threads <span class="keyword">that</span> share memory should be
           <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> same socket, <span class="keyword">and</span> a memory-mapped I/O heavy thread should
           make sure <span class="keyword">it</span>'s <span class="function_start"><span class="keyword">on</span></span> <span class="keyword">the</span> socket <span class="keyword">that</span>'s colsest <span class="keyword">to</span> <span class="keyword">the</span> I/O device <span class="keyword">it</span>'s
           talking <span class="keyword">to</span>.
    <span class="number">7.</span> Context Switches/Syscalss:
        a. A side effect <span class="keyword">of</span> all <span class="keyword">the</span> caching <span class="keyword">that</span> modern cores have <span class="keyword">is</span> <span class="keyword">that</span>
           context switches are expensive, which causes syscalls <span class="keyword">to</span> be expensive.
        b. The high cost <span class="keyword">of</span> syscalls <span class="keyword">is</span> <span class="keyword">the</span> reason people have switched <span class="keyword">to</span> using
           batched versions <span class="keyword">of</span> syscalls <span class="keyword">for</span> high-performance code (e.g., epoll, <span class="keyword">or</span> recvmmsg)
           <span class="keyword">and</span> <span class="keyword">the</span> reason <span class="keyword">that</span> perple who need very high performance I/O often use userspace I/O
           stacks.
        c. More generally, <span class="keyword">the</span> cost <span class="keyword">of</span> context switches <span class="keyword">is</span> why high-performance code
           <span class="keyword">is</span> often thread-per-core(<span class="keyword">or</span> even single threaded <span class="function_start"><span class="keyword">on</span></span> a pinned thread) <span class="keyword">and</span> <span class="keyword">not</span>
           thread-per-logical-task.
    <span class="number">8.</span> SIMD(Single Instruction Multiple Data):
        a. Since <span class="keyword">it</span>’s common <span class="keyword">to</span> want <span class="keyword">to</span> do <span class="keyword">the</span> same operation multiple <span class="keyword">times</span>,
           Intel added instructions <span class="keyword">that</span> will let you operate <span class="function_start"><span class="keyword">on</span></span> a <span class="number">128</span>-bit
           chunk <span class="keyword">of</span> data <span class="keyword">as</span> <span class="number">2</span> <span class="number">64</span>-bit chunks, <span class="number">4</span> <span class="number">32</span>-bit chunks, <span class="number">8</span> <span class="number">16</span>-bit chunks, etc. 
        b. It’s pretty common <span class="keyword">to</span> <span class="keyword">get</span> a <span class="number">2</span>x-<span class="number">4</span>x speedup <span class="keyword">from</span> using SIMD instructions;
           <span class="keyword">it</span>’s definitely worth looking <span class="keyword">into</span> <span class="keyword">if</span> you’ve got a computationally heavy workload.

点评：
    <span class="number">1.</span> Out <span class="keyword">of</span> Order Execution/Serialization:
        a. 乱序的最大限度，受限于CPU OFO buffer大小
        b. 乱序执行是对分支预测技术的一个重要支撑
        c. 乱序并不是意味着没有约束，读后读，读后写，写后读都是限制乱序执行是否允许的
    <span class="number">2.</span> Memory/Concurrency(即多核):
        a. MESI protocol是一个解决多核访问时，cache不一致问题的重要知识点
           M: Modified  E: Exclusive  S: Shared  I: Invalid
    <span class="number">3.</span> NUMA的由来：cache一致性问题(多核之间交互一致性信息开销大，复杂），从而让每个socket负责
       一个region的memory。因此形成了NUMA结构。但NUMA结构的缺点也就很明显：在跨socket访问memory
       时，延迟开销较大。
    <span class="number">4.</span> GPU(Graphical Processing Units): 就是数量取胜。通过大量的负责专用计算用途(浮点计算，矩阵运算)的
       小核组成。  
    <span class="number">5.</span> Branches: 作者的意思是说分支预测其实开销已经很小了。
        一方面，Haswell架构的CPU，分支预测错误的额外开销也就<span class="number">14</span>个cycle；
        同时，分支预测错误率现在也已经很低了（作者通过perf stat测试了常用程序后得出的结论），即分支预测已经做的很好了，预测成功的概率很大了。
    <span class="number">6.</span> Alignment: 强迫症似得去对齐page-size现在已经没有必要了，CPU已经对这类代码优化的很好了。
       现在还强制的区对其可能还会造成性能损耗。  
    <span class="number">7.</span> Self-modifying code: 暂时不动self-modifying code是个神马意思。待查。。。
</code></pre><hr>
<h2 id="Use_multiple_CPU_Cores_with_your_Linux_commands_—_awk,_sed,_bzip2,_grep,_wc,_etc-"><a href="http://www.rankfocus.com/use-cpu-cores-linux-commands/" target="_blank" rel="external">Use multiple CPU Cores with your Linux commands — awk, sed, bzip2, grep, wc, etc.</a></h2>
<pre><code>点评：目前的功能内容，不太设计超大文件的文本处理，所以现在还可以接收。
    这篇文章提到的parallel用法确实挺吸引人的，所以放在这里备忘。  
    不过针对我个人的情况，如果偶尔需要处理超大文件，或许可以用下面这个思路解决：
    首先通过<span class="built_in">split</span>命令将大文件切割，然后在用多进程去利用多核进行处理。  
相关：http:<span class="comment">//blog.sciencenet.cn/blog-548663-812884.html</span>
</code></pre><hr>
<h2 id="手把手教你用Strace诊断问题"><a href="http://huoding.com/2015/10/16/474" target="_blank" rel="external">手把手教你用Strace诊断问题</a></h2>
<pre><code>摘要：
    1. 运行<span class="attribute">top</span>时,按<span class="attr_selector">[1]</span>打开CPU列表,按<span class="attr_selector">[shift+p]</span>以CPU排序
    2. 内核态的函数调用跟踪用<span class="attr_selector">[strace]</span>,用户态的函数调用跟踪用<span class="attr_selector">[ltrace]</span>
    3. strace使用实例
        # strace -<span class="tag">p</span> &lt;PID&gt;               <span class="comment">// 使用strace跟踪某个进程的系统调用，不过就等着被刷屏吧</span>
        # strace -cp &lt;PID&gt;              <span class="comment">// 使用[-c]选项可以汇总各个操作的总耗时，调用次数等信息，很实用</span>
        # strace -T -e clone -<span class="tag">p</span> &lt;PID&gt;   <span class="comment">// -T选项获得操作实际消耗的时间，-e指定单独跟踪后一个函数</span>
点评：
    1. 文章介绍的strace选项很少，但排查问题的思路却很值得学习
    2. 问题排查思路：
        <span class="tag">a</span>. 通过<span class="attribute">top</span>找到系统资源瓶颈，进而找到对应的进程(比如如果系统CPU消耗较高，就找到CPU最高的进程)
        <span class="tag">b</span>. CPU的消耗是需要区分内核态<span class="attr_selector">[sy]</span>还是用户态<span class="attr_selector">[us]</span>的，根据此来决定是通过strace还是ltrace来排查
        c. 使用strace排查问题时，先使用-c来找到进程中的最耗时的系统调用
        d. 然后使用-T, -e来针对具体的函数调用来排查
        e. 最终结合真实的业务代码，来定位前面排查的函数对应的代码部分
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="从学渣到学霸_-_我的100天阅读简史"><a href="http://mp.weixin.qq.com/s?__biz=MjM5OTA3MjUwMA==&amp;mid=400032224&amp;idx=1&amp;sn=335f870597a6f888d219daf687357fdd&amp;scene=2&amp;srcid=1018D0eWR4z8X0yo9xV2Gg0s&amp;from=timeline&amp;isappinstalled=0#rd" target="_blank" rel="external">从学渣到学霸 - 我的100天阅读简史</a></h2>
<pre><code>点评：
    1. 行动力是第一的，有想法就要去实际动手。作者就是一个行动派，敬佩！  
    2. 每天早上起床后的时间，也是可以利用的。对我个人而言，早睡一会，早起一个小时。然后利用这一个小时，花几个番茄钟去读书！
    3. 对于不同的性质的书，要采用不同的方式阅读  
    4. 自己能够成为一个行动派？真正成为一个爱读书的人？纸上得来终觉浅，绝知此事要躬行。  
    5. 每读完一段书，写一个短评(如125字)去总结，是一个便于梳理知识的好方法。  
</code></pre>]]>
    
    </summary>
    
      <category term="读书" scheme="http://perthcharles.github.com/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="CPU" scheme="http://perthcharles.github.com/tags/CPU/"/>
    
      <category term="strace" scheme="http://perthcharles.github.com/tags/strace/"/>
    
      <category term="wiki-阅读周记" scheme="http://perthcharles.github.com/categories/wiki-%E9%98%85%E8%AF%BB%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[阅读周记(第一期)]]></title>
    <link href="http://perthcharles.github.com/2015/10/15/wiki-weekly-readlist-20151015/"/>
    <id>http://perthcharles.github.com/2015/10/15/wiki-weekly-readlist-20151015/</id>
    <published>2015-10-15T05:15:52.000Z</published>
    <updated>2015-10-19T01:55:45.000Z</updated>
    <content type="html"><![CDATA[<hr>
<h2 id="Save_Some_Bandwidth_By_Turning_Off_TCP_Timestamps"><a href="http://highscalability.com/blog/2015/10/14/save-some-bandwidth-by-turning-off-tcp-timestamps.html" target="_blank" rel="external">Save Some Bandwidth By Turning Off TCP Timestamps</a></h2>
<pre><code>想法: tcp timestamp选项会引入额外的<span class="number">12</span>字节的包头开销，因此关闭tcp timestamp选项理论上能够少量的提高有效数据的吞吐率
评测: 使用qperf benchmark评测关闭tcp timestamp后，能提升大约<span class="number">1</span>%的吞吐率
      对于<span class="number">10</span>GE NIC，关闭timestamp能将下载速度从<span class="number">9370</span>Mbits/s提升至<span class="number">9460</span>Mbits/s
点评: 关闭timestamp正常情况下确实能提高有效数据的吞吐率，但在某些情况下可能就不那么理想了。
      比如timestamp提出的初衷之一就是解决RTT测量不准，导致spurious retransmission的情况。如果关闭timestamp导致了更多的RTO，则肯定是划不来的。  
      正如文中建议的：
        Results show <span class="keyword">that</span> <span class="keyword">it</span> <span class="keyword">is</span> reasonable <span class="keyword">to</span> turn off timestamps <span class="function_start"><span class="keyword">on</span></span> <span class="number">10</span>GE interfaces, 
        <span class="keyword">but</span> keep <span class="keyword">in</span> mind <span class="keyword">that</span> <span class="keyword">it</span> should be performed only <span class="keyword">in</span> low latency networks.
      使用<span class="number">10</span>GE网卡是为了<span class="number">1</span>%的提升效果更明显，强调低延迟是因为RTO有系统最小值<span class="number">200</span>ms限制。低延迟下更难出现spurious retransmission
</code></pre><p>相关阅读：<br><a href="http://serverfault.com/questions/566889/is-it-fine-to-turn-off-tcp-window-scaling-and-tcp-timestamps-on-server" target="_blank" rel="external">Is it fine to turn off tcp window scaling and tcp timestamps on server?</a><br><a href="http://stackoverflow.com/questions/7880383/what-benefit-is-conferred-by-tcp-timestamp" target="_blank" rel="external">What benefit is conferred by TCP timestamp?</a>  </p>
<a id="more"></a>  

<hr>
<h2 id="优秀管理者需要具备的气质"><a href="http://www.zhihu.com/question/35959303" target="_blank" rel="external">优秀管理者需要具备的气质</a></h2>
<pre><code>摘要：
    1. 管理者需要懂得妥协，越是困难的事，管理者就越要协调更多资源参与。管理者需要做的就是在冲突域妥协中找到平衡点。  
    2. 基层是操作层，中层是执行层，高层是创造层和领导层，这是分工标准。  
    3. 提到工作本身，管理者的条件（处理问题的能力）一定要胜过下属，才是第一保障。  
点评：
    了解公司管理者需要具备的素质与气质，在职业生涯初期能有助于辨别出（不）好的领导。
    正所谓良禽择木而栖，跟对一个优秀的领导对于职业发展是有重大帮助的。  
</code></pre><hr>
<h2 id="The_Best_DevOps_Tools_on_OSX"><a href="https://dzone.com/articles/the-best-devops-tools-on-osx" target="_blank" rel="external">The Best DevOps Tools on OSX</a></h2>
<pre><code>点评：一个推荐工具的blog，质量确实不错。另外为什么要关注DevOps的工具呢？毕竟想通往<span class="keyword">Full</span>-<span class="keyword">Stack</span>啊^_^  
</code></pre><hr>
<h2 id="How_to_make_your_code_self-documenting"><a href="http://codeutopia.net/blog/2014/12/01/how-to-make-your-code-self-documenting/" target="_blank" rel="external">How to make your code self-documenting</a></h2>
<pre><code>摘要：
    <span class="number">1</span>. There are three basic methods <span class="keyword">for</span> <span class="keyword">self</span>-documenting code:
        Nameing things: Use names <span class="keyword">to</span> explain the purpose <span class="keyword">of</span> variables, functions, ect.
        Extracting <span class="function"><span class="keyword">function</span>:</span> Move code <span class="keyword">into</span> functions <span class="keyword">to</span> clarify purpose
        Introduce a variable: Move expressions <span class="keyword">into</span> dedicated variables <span class="keyword">to</span> clarify them
    <span class="number">2</span>. addition methods:
        <span class="keyword">Class</span> <span class="keyword">and</span> <span class="keyword">module</span> interfaces: What functions your classes <span class="keyword">and</span> modules expose effect the clarity <span class="keyword">of</span> the code
        Code grouping: You can indicate relatinships between different pieces <span class="keyword">of</span> code <span class="keyword">with</span> grouping
点评：
    <span class="number">1</span>. 这篇文章提出了一些增强代码<span class="keyword">self</span>-documentating的技巧，那为什么需要代码<span class="keyword">self</span>-documenting呢？
    尽管可以通过添加注释来解释代码，但实践中往往还是可读性更好的代码更易维护，更易理解。
    那么可读性好是什么？我的定义：一个相同领域的工程师，在不需要额外的文档、注释的情况下，
    就是很快的理解代码的逻辑和功能。
    <span class="number">2</span>. 关于Extracing <span class="function"><span class="keyword">function</span>之前我的理解还只是一个函数负责单一的一个逻辑。
    没有意识到，这样做还能帮助减少<span class="title">duplicate</span> <span class="title">code</span>，甚至能优化设计<span class="params">(improve your architecture)</span>。
    更没意识到的是，下例所展示出的一个作用:</span>

        优化前: 
            <span class="keyword">var</span> width = (value - <span class="number">0.5</span>) *<span class="number">16</span>;
        优化后: 
            <span class="keyword">var</span> width = emToPixel(value);

            <span class="function"><span class="keyword">function</span> <span class="title">emToPixels</span><span class="params">(ems)</span> <span class="comment">{
                return (ems - 0.5) * 16;
            }</span>

    优化前，如果不额外添加注释，时间长了很难记着这一行到底在干嘛。
    优化后，尽管没有注释，不管过了多久，一看代码就会知道完成的作用就是单位转换。
    同理文章还有一个将复杂的判断逻辑放到一个函数中去的例子，出发点是相同的。这里就不罗列了。  
    在这一点上，还需要在以后的实践中多多注意和体会。  </span>
</code></pre><p>相关阅读：<br><a href="http://perthcharles.github.io/2014/04/20/the-art-of-readable-code/" target="_blank" rel="external">强烈推荐之前读过的:The Art of Readable Code</a>  </p>
<hr>
<h2 id="KCon_2015_黑客安全大会"><a href="http://www.ichunqiu.com/course/775" target="_blank" rel="external">KCon 2015 黑客安全大会</a></h2>
<p>看看视频，了解了解KCon.  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<h2 id="Save_Some_Bandwidth_By_Turning_Off_TCP_Timestamps"><a href="http://highscalability.com/blog/2015/10/14/save-some-bandwidth-by-turning-off-tcp-timestamps.html" target="_blank" rel="external">Save Some Bandwidth By Turning Off TCP Timestamps</a></h2>
<pre><code>想法: tcp timestamp选项会引入额外的<span class="number">12</span>字节的包头开销，因此关闭tcp timestamp选项理论上能够少量的提高有效数据的吞吐率
评测: 使用qperf benchmark评测关闭tcp timestamp后，能提升大约<span class="number">1</span>%的吞吐率
      对于<span class="number">10</span>GE NIC，关闭timestamp能将下载速度从<span class="number">9370</span>Mbits/s提升至<span class="number">9460</span>Mbits/s
点评: 关闭timestamp正常情况下确实能提高有效数据的吞吐率，但在某些情况下可能就不那么理想了。
      比如timestamp提出的初衷之一就是解决RTT测量不准，导致spurious retransmission的情况。如果关闭timestamp导致了更多的RTO，则肯定是划不来的。  
      正如文中建议的：
        Results show <span class="keyword">that</span> <span class="keyword">it</span> <span class="keyword">is</span> reasonable <span class="keyword">to</span> turn off timestamps <span class="function_start"><span class="keyword">on</span></span> <span class="number">10</span>GE interfaces, 
        <span class="keyword">but</span> keep <span class="keyword">in</span> mind <span class="keyword">that</span> <span class="keyword">it</span> should be performed only <span class="keyword">in</span> low latency networks.
      使用<span class="number">10</span>GE网卡是为了<span class="number">1</span>%的提升效果更明显，强调低延迟是因为RTO有系统最小值<span class="number">200</span>ms限制。低延迟下更难出现spurious retransmission
</code></pre><p>相关阅读：<br><a href="http://serverfault.com/questions/566889/is-it-fine-to-turn-off-tcp-window-scaling-and-tcp-timestamps-on-server" target="_blank" rel="external">Is it fine to turn off tcp window scaling and tcp timestamps on server?</a><br><a href="http://stackoverflow.com/questions/7880383/what-benefit-is-conferred-by-tcp-timestamp" target="_blank" rel="external">What benefit is conferred by TCP timestamp?</a>  </p>
]]>
    
    </summary>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="管理" scheme="http://perthcharles.github.com/tags/%E7%AE%A1%E7%90%86/"/>
    
      <category term="devops" scheme="http://perthcharles.github.com/tags/devops/"/>
    
      <category term="KCon" scheme="http://perthcharles.github.com/tags/KCon/"/>
    
      <category term="wiki-阅读周记" scheme="http://perthcharles.github.com/categories/wiki-%E9%98%85%E8%AF%BB%E5%91%A8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015 Q2 Akamai互联网状态报告]]></title>
    <link href="http://perthcharles.github.com/2015/10/15/wiki-report-internet-state-2015Q2/"/>
    <id>http://perthcharles.github.com/2015/10/15/wiki-report-internet-state-2015Q2/</id>
    <published>2015-10-15T01:39:33.000Z</published>
    <updated>2015-10-17T08:27:49.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇博客分享一下Akamai发布的互联网状态报告，推荐每一个网络从业人员读一读。<br>不一定要细看，多看看图，了解了解趋势。若能触发一些自己的思考便是极好的。<br>甚至以后做报告，做PTT时想要一些网络相关的图表，多看看看这个系列的报告也是收益良多的。  </p>
<p>另外也推荐阅读后续将发布的<a href="https://www.stateoftheinternet.com/resources-web-security-2015-q2-internet-security-report.html" target="_blank" rel="external">安全报告</a>,<br>尤其是被DDoS坑过的小伙伴们。T_T…<br>着急的可以先看看这个<a href="https://www.stateoftheinternet.com/downloads/pdfs/Q2-2015-SOTI-Connectivity-Executive-Summary.pdf" target="_blank" rel="external">summary</a>  </p>
<p>最后也推荐有兴趣的小伙伴订阅一下stateoftheinternet网站的RSS，保持跟进。  </p>
<hr>
<h3 id="What_you_need_to_know">What you need to know</h3>
<pre><code>&gt;&gt; Global average connection speed increased <span class="number">17</span>% <span class="property">year</span>-<span class="keyword">over</span>-<span class="property">year</span>; South Korea leads <span class="keyword">at</span> <span class="number">23.1</span> Mbps.
&lt;&lt; 全球平均网速(connection speed)每年增加<span class="number">17</span>%; 韩国领跑全球，达到<span class="number">23.1</span>Mbps.

&gt;&gt; Global average peak connection speed reached <span class="number">32.5</span> Mbps; up <span class="number">26</span>% <span class="property">year</span>-<span class="keyword">over</span>-<span class="property">year</span>.
&lt;&lt; 全球平均峰值网速达到<span class="number">32.5</span>Mbps，每年增长<span class="number">26</span>%。 

&gt;&gt; Gabon, Cameroon, Nepal <span class="keyword">and</span> Iraq experienced significant Internet disruptions.
&lt;&lt; 加蓬、喀麦隆、尼泊尔和伊拉克存在严重的网络干扰。（呵呵一笑）  

&gt;&gt; Mobile data traffic grew <span class="keyword">around</span> <span class="number">15</span>% <span class="keyword">between</span> <span class="keyword">the</span> Q1 <span class="keyword">and</span> Q2, <span class="keyword">and</span> increased <span class="number">55</span>% <span class="property">year</span> <span class="keyword">over</span> <span class="property">year</span> <span class="keyword">between</span> <span class="keyword">the</span> Q2 <span class="number">2014</span> <span class="keyword">and</span> Q2 <span class="number">2015</span>, based <span class="function_start"><span class="keyword">on</span></span> traffic data collected <span class="keyword">by</span> Ericsson.
&lt;&lt; 基于Ericsson的统计数据，移动数据流量Q2季度增长了<span class="number">15</span>%左右，每年的增长量在<span class="number">55</span>%左右。 （移动流量真是疯涨啊）  
</code></pre><p><a id="more"></a>  </p>
<hr>
<h3 id="Spotlight:_Internet_and_Broadband_Adoption">Spotlight: Internet and Broadband Adoption</h3>
<pre><code>The State <span class="operator">of</span> <span class="operator">the</span> Internet reports <span class="command"><span class="keyword">on</span> <span class="title">25</span> <span class="title">Mbps</span> <span class="title">broadband</span> <span class="title">connectivity</span>, <span class="title">reflecting</span> <span class="title">the</span> <span class="title">U</span>.<span class="title">S</span>. <span class="title">Federal</span> <span class="title">Communications</span> <span class="title">Commission</span>’<span class="title">s</span> (<span class="title">FCC</span>) <span class="title">adoption</span> <span class="title">of</span> <span class="title">25</span> <span class="title">Mbps</span> <span class="title">as</span> <span class="title">the</span> <span class="title">new</span> <span class="title">benchmark</span> <span class="title">broadband</span> <span class="title">speed</span>.</span>

&gt;&gt; Globally, <span class="number">4.9</span>% <span class="operator">of</span> unique IP addresses connected <span class="built_in">to</span> Akamai <span class="keyword">at</span> <span class="built_in">average</span> speeds <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">25</span> Mbps, <span class="operator">a</span> <span class="number">7.5</span>% increase over <span class="operator">the</span> previous quarter.
&lt;&lt; 全球范围内，连接至Akamai的<span class="number">4.9</span>%的IP的平均速率超过<span class="number">25</span>Mbps, 这一比例相比于上一季度增长了<span class="number">7.5</span>%.  

&gt;&gt; In <span class="operator">the</span> United States, <span class="constant">five</span> states had <span class="number">10</span>% <span class="operator">or</span> more <span class="operator">of</span> unique IP addresses connect <span class="built_in">to</span> Akamai <span class="keyword">at</span> <span class="built_in">average</span> speeds <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">25</span> Mbps.
&lt;&lt; 在美国，五个州存在超过<span class="number">10</span>%的连接至Akamai的IP的平均速率超过<span class="number">25</span>Mbps。

&gt;&gt; Japan (<span class="number">16.4</span> Mbps) saw <span class="operator">the</span> largest quarterly gain <span class="operator">in</span> <span class="built_in">average</span> speed <span class="keyword">at</span> <span class="number">7.8</span>%.The <span class="built_in">global</span> <span class="built_in">average</span> connection speed increased <span class="number">3.5</span>% <span class="built_in">to</span> <span class="number">5.1</span> Mbps
&lt;&lt; 日本(<span class="number">16.4</span>Mbps)在上一个季度的平均网速增长最快，增长了<span class="number">7.8</span>%。全球平均网络增长了<span class="number">3.5</span>%，达到了<span class="number">5.1</span>Mbps.

&gt;&gt; Global <span class="built_in">average</span> peak connection speeds increased <span class="number">12</span>% <span class="built_in">to</span> <span class="number">32.5</span> Mbps. Average peak connection speeds increased <span class="number">100</span>% <span class="operator">in</span> Egypt (<span class="number">23.4</span> Mbps).
&lt;&lt; 全球的平均峰值网速增长了<span class="number">12</span>%，达到了<span class="number">32.5</span>Mbps。埃及的增速达到<span class="number">100</span>%，增至<span class="number">23.4</span>%。  

&gt;&gt; <span class="number">27</span>% <span class="operator">of</span> unique IP addresses globally connected <span class="built_in">to</span> Akamai <span class="keyword">at</span> <span class="built_in">average</span> speeds above <span class="number">10</span> Mbps, <span class="operator">an</span> increase <span class="operator">of</span> <span class="number">2.1</span>%.
&lt;&lt; 全球<span class="number">27</span>%连接至Akamai的IP的平均网速超过<span class="number">10</span>Mbps，增长了<span class="number">2.1</span>%.  

&gt;&gt; Among <span class="operator">the</span> top <span class="number">10</span> countries, Singapore rose <span class="operator">the</span> most (<span class="number">8.4</span>%) <span class="built_in">to</span> achieve <span class="number">50</span>% adoption <span class="operator">of</span> <span class="number">10</span> Mbps <span class="operator">or</span> higher.
&lt;&lt; 在网速做好的前<span class="number">10</span>个国家中，新加坡超过<span class="number">10</span>Mbps的比例增长最多(<span class="number">8.4</span>%)，达到了<span class="number">50</span>%的覆盖率。  

&gt;&gt; Among all countries, Kazakhstan rose <span class="operator">the</span> most (<span class="number">118</span>%) <span class="built_in">to</span> reach <span class="number">16</span>% adoption <span class="operator">of</span> <span class="number">10</span> Mbps <span class="operator">or</span> higher.
&lt;&lt; 所有国家中，哈萨克斯坦超过<span class="number">10</span>Mbps的比例增长最多(<span class="number">118</span>%)，达到了<span class="number">16</span>%的覆盖率。  

&gt;&gt; Reversing <span class="operator">the</span> trend seen <span class="operator">in</span> <span class="operator">the</span> <span class="keyword">first</span> quarter, <span class="operator">the</span> <span class="built_in">number</span> <span class="operator">of</span> unique IPv4 addresses worldwide connecting <span class="built_in">to</span> Akamai dropped <span class="keyword">by</span> about <span class="number">8.6</span> million <span class="operator">in</span> Q2.
&lt;&lt; 与第一季度的趋势相反，全球连接至Akamai的IPv4地址减少了<span class="number">8.7</span>million。

&gt;&gt; Six <span class="operator">of</span> <span class="operator">the</span> top <span class="number">10</span> countries saw <span class="operator">a</span> quarterly decline <span class="operator">in</span> unique IPv4 address.
&lt;&lt; 前<span class="number">10</span>的国家中，有六个国家检测到了IPv4地址的季度性下滑

&gt;&gt; Roughly half <span class="operator">of</span> <span class="operator">the</span> countries <span class="operator">and</span> regions had <span class="operator">an</span> increase <span class="operator">in</span> unique IPv4 address counts, <span class="operator">with</span> <span class="number">34</span> growing <span class="number">10</span>% <span class="operator">or</span> more.
&lt;&lt; 接近一半的国家和地区IPv4地址数量在增加，其中有<span class="number">34</span>个的增长率超过<span class="number">10</span>%。

&gt;&gt; European countries continued <span class="built_in">to</span> dominate <span class="operator">the</span> <span class="number">10</span> countries <span class="operator">and</span> regions <span class="operator">with</span> <span class="operator">the</span> largest percentage <span class="operator">of</span> content requests made <span class="built_in">to</span> Akamai over IPv6.
&lt;&lt; 在通过IPv6连接至Akamai的内容请求中，欧洲国家依然占据着前<span class="number">10</span>名中的大多数。

&gt;&gt; The only <span class="constant">two</span> non-European counties <span class="operator">among</span> <span class="operator">the</span> top <span class="number">10</span> were <span class="operator">the</span> U.S. <span class="operator">and</span> Peru. Both <span class="operator">of</span> which had significant double-digit quarterly improvements <span class="built_in">to</span> adoption rates <span class="operator">of</span> <span class="number">19</span>% <span class="operator">and</span> <span class="number">17</span>%, respectively.
&lt;&lt; 两个非欧洲国家分别是美国和秘鲁。两者该季度都有两位数的覆盖率的增长，分别达到了<span class="number">19</span>%和<span class="number">17</span>%。
</code></pre><hr>
<h2 id="报告正文摘要">报告正文摘要</h2>
<h3 id="Section_1:_internet_penetration">Section 1: internet penetration</h3>
<p>Akamai在该季度发现了804 million个IPv4地址连接到了Akamai的服务，连接请求分别来自242个国家和地区。(注：IPv4的理论总数约4.2 billion，可见Akamai的实力啊。Orz…)</p>
<p>尽管只发现了804 million个IPv4地址，但Akamai推测这背后至少有1 billion个网名用户。因为有许多用户是通过代理，NAT等技术来访问网络的。  </p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_1.jpg" alt=""><br>如果出现图片打不开的情况，可以自行前往下载: <a href="https://www.stateoftheinternet.com/downloads/pdfs/2015-q2-state-of-the-internet-report-figures-charts-graphs.zip" target="_blank" rel="external">Figures</a><br>从上图中可以看到，美国和中国是IPv4地址的大户(很显然嘛)，英国、日本和韩国的IPv4使用量每年还在以超过10%的速度在增长。<br>但就Q1和Q2季度而言，前十中有六个国家的IPv4地址数量在下降。Akamai的解释是认为新技术和IPv6地址的普及造成了这一现象。  </p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_2.jpg" alt=""><br><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_3.jpg" alt=""><br><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_4.jpg" alt=""><br>这三张图，反应的是Reginal Internet Registries(RIRs)该季度的IPv4地址存货量和分配量。<br>ARIN(American Registry for Internet Numbers)这个机构也是够拼的，几乎卖光了。  </p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_5.jpg" alt=""><br>比利时和瑞士的IPv6流量都超过20%了啊，欧洲真是走在网络基础设置更新的前列啊。  </p>
<hr>
<h3 id="Section_2-6:_geography_global/usa/americas/apac/emea">Section 2-6: geography global/usa/americas/apac/emea</h3>
<p>这几章主要是各个国家和地区的网速对比，看着略伤心。列几个图吧。<br><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_7.jpg" alt=""><br><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_10.jpg" alt=""><br><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_24.jpg" alt=""><br>第三张图显示的数据也是让人心碎，Global Rank排名92(总计242个国家地区)，而且统计的平均网速还在下降！！！太可怜了。。。  </p>
<hr>
<h3 id="Section_7:_mobile_connectivity">Section 7: mobile connectivity</h3>
<p>这次关于mobile的内容由于Akamai的统计技术在做调整，因此只有下面这一张图的数据。<br>不过还是能反映整体mobile这边的趋势的。  </p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_34.jpg" alt="">  </p>
<hr>
<h3 id="Section_8:_Situational_Performance">Section 8: Situational Performance</h3>
<p>这章是Akamai通过它的Real User Monitoring(RUM)技术获取的真实数据，还挺有意思的。  </p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/figure_35.jpg" alt=""><br>可以看到尽管表中很多国家在平均网络在前面的数据上看起来落后领先国家较多，但真实的页面平均加载时间上却并没有落后太多。<br>比如Hong Kong在平均网络方面要远好于Indonesia，但是从平均页面加载时间来看，Indonesia在Broadband方面也就慢500ms左右，<br>而且在Mobile方面甚至远好于Hong Kong.  </p>
<p>Akamai对此的解释有如下几点：<br>a. 数据采集不全，这受限于RUM技术<br>b. 这种相应时间受多方面因素影响，而不仅仅是网速。比如页面的总大小，页面的组成以及页面是否针对移动网络优化(这点可能是导致有不少地区mobile时间还小于broadboard时间的原因)都对平均加载时间有影响。<br>关于第二点，我表示十分认同。因为就我自身的上网经验而言，由于直接使用手机3G网络访问网络性能实在不能忍，所以基本都是在有WiFi时才去访问。<br>另外如果我在一个3G或4G网络本身就很快的地区，我可能就会任性的直接使用手机网络。甚至使用手机3G网络做比如看视频，下载文件这类耗流量的事情，<br>也就更有可能访问page weight大的网页，造成统计平均页面加载时间相对教程的现象。</p>
<hr>
<h3 id="Section_9:_Internet_disruptions_+_events">Section 9: Internet disruptions + events</h3>
<p>这章到底在讲什么？下面是Akamai对于disruption的解释。  </p>
<pre><code>These disruptions may be accidental (backhoes <span class="keyword">or</span> ship anchors severing buried fiber), 
<span class="typename">natural</span> (hurricanes <span class="keyword">or</span> earthquakes), <span class="keyword">or</span> political (governments shutting off Internet <span class="keyword">access</span> <span class="keyword">in</span> response <span class="keyword">to</span> unrest). 
</code></pre><p>好了，理解了disruption的发生理由，大家随便看看这章就好。躺枪的国家有：Gabon, Cameroon, Nepal, Iraq。</p>
<p><img src="/resources/2015-q2-state-of-the-internet-report-figures-charts-graphs/_appendix.jpg" alt=""><br>最后是整体网络相关指标的的表格，方便对比查看。  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://www.stateoftheinternet.com/resources-connectivity-2015-q2-state-of-the-internet-report.html" target="_blank" rel="external">AKAMAI’S STATE OF THE INTERNET: Q2 2015 REPORT</a><br><a href="https://www.stateoftheinternet.com/downloads/pdfs/Q2-2015-SOTI-Connectivity-Executive-Summary.pdf" target="_blank" rel="external">Q2 2015 STATE OF THE INTERNET SUMMARY</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇博客分享一下Akamai发布的互联网状态报告，推荐每一个网络从业人员读一读。<br>不一定要细看，多看看图，了解了解趋势。若能触发一些自己的思考便是极好的。<br>甚至以后做报告，做PTT时想要一些网络相关的图表，多看看看这个系列的报告也是收益良多的。  </p>
<p>另外也推荐阅读后续将发布的<a href="https://www.stateoftheinternet.com/resources-web-security-2015-q2-internet-security-report.html" target="_blank" rel="external">安全报告</a>,<br>尤其是被DDoS坑过的小伙伴们。T_T…<br>着急的可以先看看这个<a href="https://www.stateoftheinternet.com/downloads/pdfs/Q2-2015-SOTI-Connectivity-Executive-Summary.pdf" target="_blank" rel="external">summary</a>  </p>
<p>最后也推荐有兴趣的小伙伴订阅一下stateoftheinternet网站的RSS，保持跟进。  </p>
<hr>
<h3 id="What_you_need_to_know">What you need to know</h3>
<pre><code>&gt;&gt; Global average connection speed increased <span class="number">17</span>% <span class="property">year</span>-<span class="keyword">over</span>-<span class="property">year</span>; South Korea leads <span class="keyword">at</span> <span class="number">23.1</span> Mbps.
&lt;&lt; 全球平均网速(connection speed)每年增加<span class="number">17</span>%; 韩国领跑全球，达到<span class="number">23.1</span>Mbps.

&gt;&gt; Global average peak connection speed reached <span class="number">32.5</span> Mbps; up <span class="number">26</span>% <span class="property">year</span>-<span class="keyword">over</span>-<span class="property">year</span>.
&lt;&lt; 全球平均峰值网速达到<span class="number">32.5</span>Mbps，每年增长<span class="number">26</span>%。 

&gt;&gt; Gabon, Cameroon, Nepal <span class="keyword">and</span> Iraq experienced significant Internet disruptions.
&lt;&lt; 加蓬、喀麦隆、尼泊尔和伊拉克存在严重的网络干扰。（呵呵一笑）  

&gt;&gt; Mobile data traffic grew <span class="keyword">around</span> <span class="number">15</span>% <span class="keyword">between</span> <span class="keyword">the</span> Q1 <span class="keyword">and</span> Q2, <span class="keyword">and</span> increased <span class="number">55</span>% <span class="property">year</span> <span class="keyword">over</span> <span class="property">year</span> <span class="keyword">between</span> <span class="keyword">the</span> Q2 <span class="number">2014</span> <span class="keyword">and</span> Q2 <span class="number">2015</span>, based <span class="function_start"><span class="keyword">on</span></span> traffic data collected <span class="keyword">by</span> Ericsson.
&lt;&lt; 基于Ericsson的统计数据，移动数据流量Q2季度增长了<span class="number">15</span>%左右，每年的增长量在<span class="number">55</span>%左右。 （移动流量真是疯涨啊）  
</code></pre><p>]]>
    
    </summary>
    
      <category term="wiki-好文共享" scheme="http://perthcharles.github.com/categories/wiki-%E5%A5%BD%E6%96%87%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[剖析free命令]]></title>
    <link href="http://perthcharles.github.com/2015/09/28/wiki-tool-free/"/>
    <id>http://perthcharles.github.com/2015/09/28/wiki-tool-free/</id>
    <published>2015-09-28T03:07:21.000Z</published>
    <updated>2015-09-28T05:42:14.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>Linux中有许多的查看系统状态的命令，但是如果没有一些相关的背景知识就很容易<br>造成误解。free命令就是一个明显的例子。本系列wiki就结合一些好的资料并<br>结合自身理解来尝试剖析一些常用又常被误解的Linux命令。  </p>
<p><a id="more"></a><br>本文最要参考<a href="http://www.linuxnix.com/2013/05/find-ram-size-in-linuxunix.html" target="_blank" rel="external">这篇好文</a>,英文无压力的建议再读读原文。  </p>
<hr>
<h3 id="从一则free使用实例说开">从一则free使用实例说开</h3>
<pre><code><span class="preprocessor"># free</span>
             total       used       free     shared    buffers     cached
<span class="label">Mem:</span>      <span class="number">16426628</span>   <span class="number">16372464</span>      <span class="number">54164</span>          <span class="number">0</span>      <span class="number">35408</span>   <span class="number">10861984</span>
-/+ buffers/cache:    <span class="number">5475072</span>   <span class="number">10951556</span>
<span class="label">Swap:</span>     <span class="number">32764556</span>    <span class="number">7985476</span>   <span class="number">24779080</span>
</code></pre><p>第一行和第三行字面意思都好立即，第二行往往很多人不理解。主要是看不懂”-/+ buffers/cache”<br>到底是什么鬼。<br>也正是很多人不理解第二行，往往看到类似上面的free结果后，就认为系统已经没有空闲内存给新进程使用了。<br>下面给出一个计算公式，基本一看就能懂了。  </p>
<pre><code><span class="attribute">line1[used] - (line1[buffers] + line1[cached]) </span>=<span class="string"> line2[used]
line1[total] - line2[used] = line2[free]</span>
</code></pre><p>根据实例验证一下  </p>
<pre><code><span class="attribute">16372464 - (35408 + 10861984) </span>=<span class="string"> 5475072
16426628 - 5475072 = 10951556</span>
</code></pre><p>那么当有人问起，看到这样一个free结果时，系统还有多少可用的空闲内存呢(free RAM available) ?<br>我们的回答应该是line2[free]而不是line1[free]。下面会详细解释。  </p>
<hr>
<h3 id="buffers和cached到底是什么">buffers和cached到底是什么</h3>
<p>buffers是被一个特定进程使用的用于<em>临时</em>存放数据的内存空间，这些内容不会被其他进程访问。<br><a href="http://www.linuxnix.com/2013/05/find-ram-size-in-linuxunix.html" target="_blank" rel="external">这篇文章</a>用了带宽的概念来<br>类比，非常贴切。<br>当你试图通过网络发送大量的突发数据时，如果网卡的带宽(capacity)仅支持发送一部分时，<br>它会将剩下的数据存在buffers中，用于后续发送。</p>
<p>而cached用于存放频繁访问的一些数据，目的是做到更快的数据访问。<br>比如多个进程需要读同一个文件，此时内存可能就分配一片cached区域，用于作为CPU到磁盘<br>之间的cache。  </p>
<p>buffers和cached的区别：<br>a. buffers是供单个进程使用的，而cached可供多个进程使用<br>b. buffers是一次性的，而cached是可以反复使用的<br>buffers和cached的共同之处就在于它们都是临时性的存储，如果后续有进程需要使用<br>这些内存空间，Linux会释放(free)这些临时性占用的内存。</p>
<hr>
<h3 id="swap分区">swap分区</h3>
<p>swap分区的目的是将一些不被频繁访问的内存数据放到磁盘，但是当需要时又能尽快的恢复到内存中去  </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.linuxnix.com/2013/05/find-ram-size-in-linuxunix.html" target="_blank" rel="external">Understanding free command in Linux/Unix</a><br><a href="http://www.linuxatemyram.com/" target="_blank" rel="external">Linux ate my ram! Don’t Panic! Your ram is fine!</a><br><a href="http://www.linuxatemyram.com/play.html" target="_blank" rel="external">Experiments and fun with the Linux disk cache</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>Linux中有许多的查看系统状态的命令，但是如果没有一些相关的背景知识就很容易<br>造成误解。free命令就是一个明显的例子。本系列wiki就结合一些好的资料并<br>结合自身理解来尝试剖析一些常用又常被误解的Linux命令。  </p>
<p>]]>
    
    </summary>
    
      <category term="free" scheme="http://perthcharles.github.com/tags/free/"/>
    
      <category term="linux" scheme="http://perthcharles.github.com/tags/linux/"/>
    
      <category term="shell" scheme="http://perthcharles.github.com/tags/shell/"/>
    
      <category term="wiki-tools" scheme="http://perthcharles.github.com/categories/wiki-tools/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ssh forward跨局域网访问]]></title>
    <link href="http://perthcharles.github.com/2015/09/22/ssh-forward/"/>
    <id>http://perthcharles.github.com/2015/09/22/ssh-forward/</id>
    <published>2015-09-22T13:02:36.000Z</published>
    <updated>2015-09-22T14:17:40.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在平时需要夸局域网访问某台设备时，都是选择先ssh登录跳板机，然后通过跳板机<br>再去访问目的设备。但在某些时候可能比较麻烦，比如涉及到图形化界面时。<br>这篇文章就来介绍一下如何使用ssh forward功能，达到在跨局域网访问时，<br>像访问同一局域网设备一样方便。  </p>
<a id="more"></a>  

<hr>
<h3 id="网络拓扑">网络拓扑</h3>
<p>假设存在一下网络拓扑，这是一个非常常见的办公网络环境拓扑  </p>
<pre><code><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>                 <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
<span class="comment">|</span>    <span class="comment">设备A</span>    <span class="comment">|</span>                 <span class="comment">|</span>    <span class="comment">设备B</span>     <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">1</span><span class="string">.</span><span class="comment">11|</span>   &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;   <span class="comment">|</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">1</span><span class="string">.</span><span class="comment">22</span> <span class="comment">|</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>                 <span class="comment">|</span>              <span class="comment">|</span>
                                <span class="comment">|</span>              <span class="comment">|</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>                 <span class="comment">|</span>              <span class="comment">|</span>
<span class="comment">|</span>    <span class="comment">设备C</span>    <span class="comment">|</span>                 <span class="comment">|</span>              <span class="comment">|</span>
<span class="comment">|</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">2</span><span class="string">.</span><span class="comment">11|</span>   &lt;<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>&gt;   <span class="comment">|</span> <span class="comment">192</span><span class="string">.</span><span class="comment">168</span><span class="string">.</span><span class="comment">2</span><span class="string">.</span><span class="comment">22</span> <span class="comment">|</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>                 <span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span><span class="literal">-</span>
</code></pre><p>平时如果设备A想要访问设备C，可以首先登陆设备B，然后再登陆设备C，即</p>
<pre><code><span class="variable">@A</span> <span class="comment"># ssh usr@192.168.1.22</span>
<span class="variable">@B</span> <span class="comment"># ssh usr@192.168.2.11</span>
</code></pre><p>此时设备B发挥的作用一般就称为跳板机。<br>但假设这样一种情景，设备C提供了视频web服务，想直接使用设备A上面的浏览器<br>播放，此时会有两种办法。  </p>
<h5 id="配置正确的路由和网关信息">配置正确的路由和网关信息</h5>
<p>比如  </p>
<pre><code><span class="variable">@A</span> <span class="comment"># route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.22 dev eth1</span>
<span class="variable">@C</span> <span class="comment"># route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.2.22 dev eth1</span>
<span class="variable">@B</span> <span class="comment"># echo 1 &gt; /proc/sys/net/ipv4/ip_forward    // 开启ip forward</span>
</code></pre><p>可以看到，这种方法需要在三台机器上进行route相关的配置，比较麻烦。<br>并且很多时候，设备A的用户是没有修改设备C和设备B的系统配置的权限的。  </p>
<h5 id="配置ssh_forward">配置ssh forward</h5>
<p>这种方法使用方便，目的性强（也就意味着适用性差）。具体操作如下  </p>
<pre><code><span class="variable">@A</span> <span class="comment"># ssh -L 8000:192.168.2.11:80  usr@192.168.1.22</span>
</code></pre><p>man ssh里面的解释最准确简介，直接贴上来  </p>
<pre><code>-L [bind_address:]port:host:hostport
    Specifies that <span class="operator">the</span> given port <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">local</span> (<span class="title">client</span>) <span class="title">host</span> <span class="title">is</span> <span class="title">to</span> <span class="title">be</span></span>
    forwarded <span class="built_in">to</span> <span class="operator">the</span> given host <span class="operator">and</span> port <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">remote</span> <span class="title">side</span>.  <span class="title">This</span></span>
    works <span class="keyword">by</span> allocating <span class="operator">a</span> <span class="built_in">socket</span> <span class="built_in">to</span> listen <span class="built_in">to</span> port <span class="command"><span class="keyword">on</span> <span class="title">the</span> <span class="title">local</span> <span class="title">side</span>,</span>
    optionally bound <span class="built_in">to</span> <span class="operator">the</span> specified bind_address.  Whenever <span class="operator">a</span> con-
    nection is made <span class="built_in">to</span> this port, <span class="operator">the</span> connection is forwarded over
    <span class="operator">the</span> secure channel, <span class="operator">and</span> <span class="operator">a</span> connection is made <span class="built_in">to</span> host port
    hostport <span class="built_in">from</span> <span class="operator">the</span> remote machine.  Port forwardings can also be
    specified <span class="operator">in</span> <span class="operator">the</span> configuration <span class="built_in">file</span>.  IPv6 addresses can be spec-
    ified <span class="keyword">by</span> enclosing <span class="operator">the</span> address <span class="operator">in</span> square brackets.  Only <span class="operator">the</span>
    superuser can forward privileged ports.  By default, <span class="operator">the</span> <span class="built_in">local</span>
    port is bound <span class="operator">in</span> accordance <span class="operator">with</span> <span class="operator">the</span> GatewayPorts setting.  How-
    ever, <span class="operator">an</span> explicit bind_address may be used <span class="built_in">to</span> bind <span class="operator">the</span> connection
    <span class="built_in">to</span> <span class="operator">a</span> specific address.  The bind_address <span class="operator">of</span> <span class="string">''</span>localhost<span class="string">''</span> indi-
    cates that <span class="operator">the</span> listening port be bound <span class="keyword">for</span> <span class="built_in">local</span> use only, <span class="keyword">while</span>
    <span class="operator">an</span> <span class="constant">empty</span> address <span class="operator">or</span> <span class="string">'*'</span> indicates that <span class="operator">the</span> port should be avail-
    able <span class="built_in">from</span> all interfaces. 
</code></pre><p>执行上面命令后，会将访问本地的8000端口的数据转到192.168.2.11:80，反向也一样。<br>此时即可直接在设备A上打开浏览器，输入localhost:8000地址，即可访问设备C提供的web服务</p>
<hr>
<h3 id="更进一步">更进一步</h3>
<p>如果存在以下拓扑，设备A想要访问设备D的web服务，如果使用配置route方式，则会更加麻烦。<br>而使用ssh forward方式，只需要简单的两条命令就能搞定  </p>
<pre><code>---------------                 ----------------
<span class="string">|    设备A    |                 |    设备B     |</span>
<span class="string">| 192.168.1.11|   &lt;---------&gt;   | 192.168.1.22 |</span>
---------------                 <span class="string">|              |</span>
                                <span class="string">|              |</span>
---------------                 <span class="string">|              |</span>
<span class="string">|    设备C    |                 | 192.168.2.22 |</span>
<span class="string">| 192.168.2.11|   &lt;---------&gt;   ----------------</span>
<span class="string">|             |                 </span>
<span class="string">|             |                 </span>
<span class="string">|             |                 ----------------</span>
<span class="string">| 192.168.3.11|   &lt;---------&gt;   |    设备D     |</span>
---------------                 <span class="string">| 192.168.3.22 |</span>
                                ----------------

@A <span class="preprocessor"># ssh -gL 8000:设备B:8000 usr@设备B</span>
@B <span class="preprocessor"># ssh -L  8000:设备D:80   usr@设备C</span>
</code></pre><p>其中-g的含义如下  </p>
<pre><code>-g  Allows remote hosts <span class="built_in">to</span> connect <span class="built_in">to</span> <span class="built_in">local</span> forwarded ports
</code></pre><p>由上面的例子可知，可以很方便的配置多个ssh forward，用以实现跨多个局域网的网络访问。<br>想要了解更多理论和具体的解释，强烈推荐看看参考资料。   </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="external">实战SSH端口转发</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在平时需要夸局域网访问某台设备时，都是选择先ssh登录跳板机，然后通过跳板机<br>再去访问目的设备。但在某些时候可能比较麻烦，比如涉及到图形化界面时。<br>这篇文章就来介绍一下如何使用ssh forward功能，达到在跨局域网访问时，<br>像访问同一局域网设备一样方便。  </p>
]]>
    
    </summary>
    
      <category term="Linux" scheme="http://perthcharles.github.com/tags/Linux/"/>
    
      <category term="ssh" scheme="http://perthcharles.github.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Taming the Elephants -- New TCP Slow Start]]></title>
    <link href="http://perthcharles.github.com/2015/09/15/wiki-hybird-slow-start/"/>
    <id>http://perthcharles.github.com/2015/09/15/wiki-hybird-slow-start/</id>
    <published>2015-09-15T15:13:26.000Z</published>
    <updated>2015-09-17T01:05:13.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>这篇文章给出了对于老古董技术Slow Start的诸多现有性能问题评测分析，<br>并最后提出一种叫Hybird Slow Start (Hystart)的技术来尝试解决分析的一些问题。<br>这篇文章是理解最新的slow start技术的关键文章。<br><a id="more"></a>  </p>
<hr>
<h3 id="现有Slow-Start的性能问题">现有Slow-Start的性能问题</h3>
<p>长肥网络<a href="https://en.wikipedia.org/wiki/Bandwidth-delay_product" target="_blank" rel="external">[1]</a>中的TCP性能问题是现代TCP设计的一个重要领域。这不，连那么naive的slow start都在长肥网络中遇到的诸多性能问题。  </p>
<p>a. 标准的Slow Start算法可能引起严重的网络丢包<br>在ssthreshold值设置的过高时，慢启动一段时间后，cwnd的指数增长会显得过快。<br>有可能在上一个RTT，cwnd刚好等于BDP；下一个RTT，cwnd就等于2BDP了。<br>这样就可能导致多出的一个BDP的数据包被丢弃。这类丢包属于burst packet losses  </p>
<p>b. Slow start可能导致系统负载过高，尤其是在使用SACK机制时<br>关于SACK选项可能引起CPU utilization过高的问题已经有了普遍的认识<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/index.html" target="_blank" rel="external">[2]</a><br>这篇论文给出的一个数据倒是令我比较感兴趣：  </p>
<pre><code>The problems consistently occur <span class="operator">in</span> all <span class="constant">three</span> dominant operating systems,
Linux, Windows XP <span class="operator">and</span> FreeBSD during more than <span class="number">40</span>% <span class="operator">of</span> slow start runs
<span class="operator">in</span> large BDP networks.  
</code></pre><p>解决Slow Start问题两个明显的思路：  </p>
<pre><code>1. 继续优化SACK的处理机制，提高遍历重传队列的效率
    -<span class="ruby">- 这也是目前较热的一个研究和工程趋势
</span>2. 解决slow start可能带来的burst losses，进而也能缓解SACK性能问题 
    -<span class="ruby">- 这是这篇论文所主要关心的思路</span>
</code></pre><p>吐个小槽：这篇论文的数据来看，Window XP被黑的不轻啊，╮(╯▽╰)╭  </p>
<hr>
<h3 id="Hybird-Slow-Start">Hybird-Slow-Start</h3>
<p>本文提出一种叫做Hybird Slow Start的算法来解决上述问题，论文中有不少精妙的<br>理论分析，这里就不再赘述。  </p>
<p>主要想解释一下packet train是个什么样的概念。<br>举个栗子，下图是我理解的一个packet train的样子，[Packet1]这些是表示一个具体<br>的数据包，’-‘用于表示两个数据包之间的发送时间间隔。<br>那么这样一个packet train能用来干嘛呢？计算带宽利用率！<br>具体来说，图中四个数据包的数据总量可以求和得到，然后总的时间间隔也可以得到<br>(timestamp4 - timestamp1)。</p>
<pre><code><span class="attr_selector">[Packet1]</span> <span class="tag">--</span> <span class="attr_selector">[Packet2]</span> <span class="tag">------</span> <span class="attr_selector">[Packet3]</span> <span class="tag">----</span> <span class="attr_selector">[Packet4]</span>
</code></pre><p>那这篇论文就利用的类似的思路，通过ACK train信息判断一个Safe Exit Point<br>for Slow Start. 同时为了避免计算带宽，通过一个巧妙的转换(具体建议看论文)，只要判断时间差<br>是否超过Forward one-way delay(Dmin)来决定是否退出慢启动。</p>
<p>总的来说，Hystart算法可以总结如下  </p>
<pre><code>Hystart算法通过以下两个技术来判断是否应该退出慢启动
<span class="bullet">1. </span>一个窗口内的数据包的总传输间隔是否超过Dmin
<span class="bullet">2. </span>数据包的RTT sample是否出现较大幅度的增长
</code></pre><p>论文给出的伪代码如下图所示<br><img src="/resources/hybird-slow-start.png" alt="">  </p>
<hr>
<h3 id="内核源码分析">内核源码分析</h3>
<p>从上面的hystart算法伪代码可以看出，hystart算法主要包括两个方面：<br>a. 在每个RTT区间开始时，重置hystart算法相关变量<br>b. 对于每个收到的ACK，根据ack train算法和RTT波动来判断是否应该退出slow start  </p>
<p>在Linux 3.10内核中，hybird slow start算法被集成在了默认的CUBIC算法中。<br>在tcp_cubic.c文件中有两个函数分别对应以上两个步骤，<br>分别是bictcp_hystart_reset()和hystart_update()。<br>这两个函数几乎是严格按照上述伪代码来实现的，所以也就没有接着展开解释的必要。<br>下面主要从整体的处理逻辑方面来分析源码  </p>
<pre><code>// cubic算法的关键数据结构  
static struct tcp_congestion_ops <span class="variable">cubictcp =</span> {
    .<span class="variable">init           =</span> bictcp_init,              // 在TCP流建立之初调用
    .<span class="variable">ssthresh       =</span> bictcp_recalc_ssthresh,
    .<span class="variable">cong_avoid     =</span> bictcp_cong_avoid,
    .<span class="variable">set_state      =</span> bictcp_state,
    .<span class="variable">undo_cwnd      =</span> bictcp_undo_cwnd,
    .<span class="variable">pkts_acked     =</span> bictcp_acked,             // 每次收到ACK数据包后调用
    .<span class="variable">owner          =</span> THIS_MODULE,
    .<span class="variable">name           =</span> <span class="string">"cubic"</span>,
};
</code></pre><p>上面是cubic算法的关键结构体的初始化部分，bictcp_init()负责TCP流建立时的初始化动作，<br>bictcp_acked()负责在每次收到ACK包后，更新相关信息。所有hystart算法上面的两个<br>函数也分别是在cubic的这两个函数中。下面依次看cubic中这两个函数的实现  </p>
<pre><code><span class="keyword">static</span> void bictcp_init(<span class="keyword">struct</span> sock *sk)
{
    bictcp_reset(inet_csk_ca(sk));

    <span class="keyword">if</span> (hystart)                    <span class="comment">// 如果开启(默认开启)，则进行hystart相关变量的初始化</span>
        bictcp_hystart_reset(sk);

    <span class="keyword">if</span> (!hystart &amp;&amp; initial_ssthresh)
        tcp_sk(sk)-&gt;snd_ssthresh = initial_ssthresh;
}

<span class="keyword">static</span> void bictcp_acked(<span class="keyword">struct</span> sock *sk, <span class="keyword">u32</span> cnt, s32 rtt_us)
{
    ...
    <span class="comment">/* first time call or link delay decreases */</span>
    <span class="keyword">if</span> (ca-&gt;delay_min == <span class="number">0</span> || ca-&gt;delay_min &gt; delay)
        ca-&gt;delay_min = delay;

    <span class="comment">/* hystart triggers when cwnd is larger than some threshold */</span>
    <span class="keyword">if</span> (hystart &amp;&amp; tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh &amp;&amp; tp-&gt;snd_cwnd &gt;= hystart_low_window)
        hystart_update(sk, delay);
}
</code></pre><hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://netsrv.csc.ncsu.edu/export/hystart_techreport_2008.pdf" target="_blank" rel="external">Taming the Elephant: New TCP Slow Start</a><br><a href="http://www.ibm.com/developerworks/cn/linux/l-oprof/index.html" target="_blank" rel="external">用OProfile彻底了解性能</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>这篇文章给出了对于老古董技术Slow Start的诸多现有性能问题评测分析，<br>并最后提出一种叫Hybird Slow Start (Hystart)的技术来尝试解决分析的一些问题。<br>这篇文章是理解最新的slow start技术的关键文章。<br>]]>
    
    </summary>
    
      <category term="TCP" scheme="http://perthcharles.github.com/tags/TCP/"/>
    
      <category term="SACK" scheme="http://perthcharles.github.com/tags/SACK/"/>
    
      <category term="OProfile" scheme="http://perthcharles.github.com/tags/OProfile/"/>
    
      <category term="wiki-paper" scheme="http://perthcharles.github.com/categories/wiki-paper/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用ip命令修改初始拥塞窗口和接收窗口]]></title>
    <link href="http://perthcharles.github.com/2015/09/14/ip-route-initcwnd/"/>
    <id>http://perthcharles.github.com/2015/09/14/ip-route-initcwnd/</id>
    <published>2015-09-14T10:14:04.000Z</published>
    <updated>2015-09-14T14:16:31.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在不修改内核的情况下，Linux提供了一种使用ip命令修改初始拥塞窗口和接收窗口的机制。<br>具体的例子可看<a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">这篇文章</a><br><a id="more"></a>  </p>
<hr>
<h3 id="修改初始拥塞窗口">修改初始拥塞窗口</h3>
<p>使用如下命令可修改init cwnd  </p>
<pre><code>sudo ip route change <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> dev eth0  proto <span class="keyword">static</span> initcwnd <span class="number">10</span>
</code></pre><p>内核源码分析  </p>
<pre><code><span class="comment">// 初始化cwnd的函数，会判断是否设置了route来指定initcwnd  </span>
<span class="number">__u32</span> tcp_init_cwnd(<span class="keyword">const</span> <span class="keyword">struct</span> tcp_sock *tp, <span class="keyword">const</span> <span class="keyword">struct</span> dst_entry *dst)
{
    <span class="number">__u32</span> cwnd = (dst ? dst_metric(dst, RTAX_INITCWND) : <span class="number">0</span>);

    <span class="keyword">if</span> (!cwnd)
        cwnd = TCP_INIT_CWND;
    <span class="keyword">return</span> min_t(<span class="number">__u32</span>, cwnd, tp-&gt;snd_cwnd_clamp);
}

<span class="comment">// 内核中一个典型的调用序列  </span>
tcp_finish_connect()
    =&gt; tcp_init_metrics()
        =&gt; tp-&gt;snd_cwnd = tcp_init_cwnd(tp, dst);
</code></pre><hr>
<h3 id="修改初始接收窗口">修改初始接收窗口</h3>
<p>使用如下命令可修改init rwnd  </p>
<pre><code>sudo ip route change <span class="keyword">default</span> via <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> dev eth0  proto <span class="keyword">static</span> initrwnd <span class="number">10</span>
</code></pre><p>内核源码分析  </p>
<pre><code><span class="regexp">//</span> 一个典型的调用序列
tcp_connect_init<span class="function"><span class="params">()</span>
    =&gt;</span> tcp_select_inital_window<span class="function"><span class="params">()</span>
        =&gt;</span> dst_metric(dst, RTAX_INITRWND)
</code></pre><h3 id="参考资料">参考资料</h3>
<p><a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">Tuning initcwnd for optimum performance</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在不修改内核的情况下，Linux提供了一种使用ip命令修改初始拥塞窗口和接收窗口的机制。<br>具体的例子可看<a href="http://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/" target="_blank" rel="external">这篇文章</a><br>]]>
    
    </summary>
    
      <category term="ip" scheme="http://perthcharles.github.com/tags/ip/"/>
    
      <category term="tool" scheme="http://perthcharles.github.com/tags/tool/"/>
    
      <category term="Networking" scheme="http://perthcharles.github.com/categories/Networking/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊一聊重传次数]]></title>
    <link href="http://perthcharles.github.com/2015/09/07/wiki-tcp-retries/"/>
    <id>http://perthcharles.github.com/2015/09/07/wiki-tcp-retries/</id>
    <published>2015-09-07T13:40:02.000Z</published>
    <updated>2015-09-08T05:28:05.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>在<a href="http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/" target="_blank" rel="external">RTO的计算方法</a>中，介绍了RFC6298对于RTO的计算和RTO timer的管理算法。<br>但有一个重要的问题RFC没有提到，那就是如果出现了超时重传，那重传多少次可以放弃呢？<br>当然这是一个实现相关的细节，不同的操作系统可能有不同的实现策略。<br>在这篇wiki中，就来介绍一下Linux中是怎么限制超时重传次数的。<br><a id="more"></a>  </p>
<hr>
<h3 id="听说Linux有两个参数限制超时重传次数">听说Linux有两个参数限制超时重传次数</h3>
<p>没错，Linux中确实定义了两个参数来限定超时重传的次数的，以下是源码中Documentation/networking/ip-sysctl.txt文档中的描述  </p>
<pre><code>tcp_retries1 - INTEGER
    This <span class="built_in">value</span> influences <span class="operator">the</span> <span class="built_in">time</span>, <span class="keyword">after</span> which TCP decides, that
    something is wrong due <span class="built_in">to</span> unacknowledged RTO retransmissions,
    <span class="operator">and</span> reports this suspicion <span class="built_in">to</span> <span class="operator">the</span> network layer.
    See tcp_retries2 <span class="keyword">for</span> more details.

    RFC <span class="number">1122</span> recommends <span class="keyword">at</span> least <span class="number">3</span> retransmissions, which is <span class="operator">the</span>
    default.

tcp_retries2 - INTEGER
    This <span class="built_in">value</span> influences <span class="operator">the</span> timeout <span class="operator">of</span> <span class="operator">an</span> alive TCP connection,
    when RTO retransmissions remain unacknowledged.
    Given <span class="operator">a</span> <span class="built_in">value</span> <span class="operator">of</span> N, <span class="operator">a</span> hypothetical TCP connection following
    exponential backoff <span class="operator">with</span> <span class="operator">an</span> initial RTO <span class="operator">of</span> TCP_RTO_MIN would
    retransmit N times <span class="keyword">before</span> killing <span class="operator">the</span> connection <span class="keyword">at</span> <span class="operator">the</span> (N+<span class="number">1</span>)th RTO.

    The default <span class="built_in">value</span> <span class="operator">of</span> <span class="number">15</span> yields <span class="operator">a</span> hypothetical timeout <span class="operator">of</span> <span class="number">924.6</span>
    <span class="built_in">seconds</span> <span class="operator">and</span> is <span class="operator">a</span> <span class="built_in">lower</span> bound <span class="keyword">for</span> <span class="operator">the</span> <span class="keyword">effective</span> timeout.
    TCP will effectively <span class="built_in">time</span> out <span class="keyword">at</span> <span class="operator">the</span> <span class="keyword">first</span> RTO which exceeds <span class="operator">the</span>
    hypothetical timeout.

    RFC <span class="number">1122</span> recommends <span class="keyword">at</span> least <span class="number">100</span> <span class="built_in">seconds</span> <span class="keyword">for</span> <span class="operator">the</span> timeout,
    which corresponds <span class="built_in">to</span> <span class="operator">a</span> <span class="built_in">value</span> <span class="operator">of</span> <span class="keyword">at</span> least <span class="number">8.</span>
</code></pre><p>就是这样一段话，可能由于过于概括，会令人产生很多疑问，甚至产生一些误解。<br>比如常见的问题有：<br>a. 超过tcp_retries1这个阈值后，到底是report了怎样一种suspicion呢？<br>b. tcp_retries1和tcp_retries2的数字是表示RTO重传的次数上限，对吗？<br>c. 文档中提到，924.6s is a lower bound for the effective timeout。<br>这里的effective timeout是指什么？<br>为什么是lower bound，tcp_retries2不应该是限制重传次数的upper bound吗？  </p>
<p>下面就结合Linux 3.10的源码来逐个解释一下以上几个问题。并在最后给出一个总结。  </p>
<hr>
<h3 id="重传超过tcp_retries1会怎样">重传超过tcp_retries1会怎样</h3>
<p>文档中说的suspicion到底是什么呢？来看一下tcp_retries1相关的代码部分  </p>
<pre><code>// RTO timer的处理函数是tcp_retransmit_timer()，与tcp_retries1相关的代码调用关系如下  
tcp_retransmit_timer()
    =&gt; tcp_write_timeout()  // 判断是否重传了足够的久
        =&gt; retransmit_timed_out(sk, sysctl_tcp_retries1, <span class="number">0</span>, <span class="number">0</span>)  // 判断是否超过了阈值

// tcp_write_timeout()的具体相关内容  
<span class="keyword">...</span>
<span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_SYN_SENT | TCPF_SYN_RECV)) {
    // 如果超时发生在三次握手期间，此时有专门的tcp_syn_retries来负责限定重传次数
    <span class="keyword">...</span>
} <span class="keyword">else</span> {    // 如果超时发生在数据发送期间
    // 这个函数负责判断重传是否超过阈值，返回真表示超过。后续会详细分析这个函数  
    <span class="keyword">if</span> (retransmits_timed_out(sk, sysctl_tcp_retries1, <span class="number">0</span>, <span class="number">0</span>)) { 
        /* Black hole detection */
        tcp_mtu_probing(icsk, sk);  // 如果开启tcp_mtu_probing(默认关闭)了，则执行PMTU

        dst_negative_advice(sk);    // 更新路由缓存
    }
    <span class="keyword">...</span>
}
</code></pre><p>从以上的代码可以看到，一旦重传超过阈值tcp_retries1，主要的动作就是更新路由缓存。<br>用以避免由于路由选路变化带来的问题。  </p>
<hr>
<h3 id="重传超过tcp_retries2会怎样">重传超过tcp_retries2会怎样</h3>
<p>会直接放弃重传，关闭TCP流  </p>
<pre><code>// 依然还是在tcp_write_timeout()中，retry_until一般是tcp_retries2
<span class="keyword">...</span>
<span class="keyword">if</span> (retransmits_timed_out(sk, retry_until, syn_set ? <span class="number">0</span> : icsk-&gt;icsk_user_timeout, syn_set)) {
    /* Has it gone just too far? */
    tcp_write_err(sk);      // 调用tcp_done关闭TCP流
    <span class="keyword">return</span> <span class="number">1</span>;
}
</code></pre><hr>
<h3 id="retries限制的重传次数吗">retries限制的重传次数吗</h3>
<p>咋一看文档，很容易想到retries的数字就是限定的重传的次数，甚至源码中对于retries常量注释中都写着”This is how many retries it does…”  </p>
<pre><code><span class="comment">#define TCP_RETR1       3   /*</span>
                             * This is how many retries <span class="keyword">it</span> does <span class="keyword">before</span> <span class="keyword">it</span>
                             * tries <span class="built_in">to</span> figure out <span class="keyword">if</span> <span class="operator">the</span> gateway is
                             * down. Minimal RFC <span class="built_in">value</span> is <span class="number">3</span>; <span class="keyword">it</span> corresponds
                             * <span class="built_in">to</span> ~<span class="number">3</span><span class="built_in">sec</span>-<span class="number">8</span><span class="built_in">min</span> depending <span class="command"><span class="keyword">on</span> <span class="title">RTO</span>.</span>
                             */

<span class="comment">#define TCP_RETR2       15  /*</span>
                             * This should take <span class="keyword">at</span> least
                             * <span class="number">90</span> minutes <span class="built_in">to</span> <span class="built_in">time</span> out.
                             * RFC1122 says that <span class="operator">the</span> limit is <span class="number">100</span> <span class="built_in">sec</span>.
                             * <span class="number">15</span> is ~<span class="number">13</span>-<span class="number">30</span><span class="built_in">min</span> depending <span class="command"><span class="keyword">on</span> <span class="title">RTO</span>.</span>
                             */
</code></pre><p>那就就来看看retransmits_timed_out的具体实现，看看到底是不是限制的重传次数  </p>
<pre><code>/* This <span class="reserved">function</span> calculates a <span class="string">"timeout"</span> which <span class="keyword">is</span> equivalent to the timeout <span class="keyword">of</span> a
 * TCP connection after <span class="string">"boundary"</span> unsuccessful, exponentially backed-<span class="literal">off</span>
 * retransmissions <span class="reserved">with</span> an initial RTO <span class="keyword">of</span> TCP_RTO_MIN <span class="keyword">or</span> TCP_TIMEOUT_INIT <span class="keyword">if</span>
 * syn_set flag <span class="keyword">is</span> set.
 */
static bool retransmits_timed_out(struct sock *sk,
                              unsigned int boundary,
                              unsigned int timeout,
                              bool syn_set)
{
    unsigned int linear_backoff_thresh, start_ts;
    <span class="regexp">//</span> 如果是在三次握手阶段，syn_set为真
    unsigned int rto_base = syn_set ? TCP_TIMEOUT_INIT : TCP_RTO_MIN;

    <span class="keyword">if</span> <span class="function"><span class="params">(!inet_csk(sk)-&gt;icsk_retransmits)</span>
            <span class="title">return</span> <span class="title">false</span>;

    // <span class="title">retrans_stamp</span>记录的是数据包第一次发送的时间，在<span class="title">tcp_retransmit_skb</span><span class="params">()</span>中设置
    <span class="title">if</span> <span class="params">(unlikely(!tcp_sk(sk)-&gt;retrans_stamp))</span>
            <span class="title">start_ts</span> = <span class="title">TCP_SKB_CB</span><span class="params">(tcp_write_queue_head(sk))</span>-&gt;</span><span class="keyword">when</span>;
    <span class="keyword">else</span>
            start_ts = tcp_sk<span class="function"><span class="params">(sk)</span>-&gt;</span>retrans_stamp;

    <span class="regexp">//</span> 如果用户态未指定timeout，则算一个出来
    <span class="keyword">if</span> (likely(timeout == <span class="number">0</span>)) {
            /* 下面的计算过程，其实就是算一下如果以rto_base为第一次重传间隔，
             * 重传boundary次需要多长时间
             */
            linear_backoff_thresh = ilog2(TCP_RTO_MAX/rto_base);

            <span class="keyword">if</span> (boundary &lt;= linear_backoff_thresh)
                    timeout = ((<span class="number">2</span> &lt;&lt; boundary) - <span class="number">1</span>) * rto_base;
            <span class="keyword">else</span>
                    timeout = ((<span class="number">2</span> &lt;&lt; linear_backoff_thresh) - <span class="number">1</span>) * rto_base +
                            (boundary - linear_backoff_thresh) * TCP_RTO_MAX;
    }
    <span class="regexp">//</span> 如果数据包第一次发送的时间距离现在的时间间隔，超过了timeout值，则认为重传超于阈值了
    <span class="keyword">return</span> (tcp_time_stamp - start_ts) &gt;= timeout;
}
</code></pre><p>从以上的代码分析可以看到，真正起到限制重传次数的并不是真正的重传次数。<br>而是以tcp_retries1或tcp_retries2为boundary，以rto_base(如TCP_RTO_MIN 200ms)为初始RTO，计算得到一个timeout值出来。如果重传间隔超过这个timeout，则认为超过了阈值。<br>上面这段话太绕了，下面举两个个例子来说明  </p>
<pre><code>以判断是否放弃TCP流为例，如果<span class="variable">tcp_retries2=</span><span class="number">15</span>，那么计算得到的<span class="variable">timeout=</span><span class="number">924600</span>ms。

<span class="number">1</span>. 如果RTT比较小，那么RTO初始值就约等于下限<span class="number">200</span>ms
   由于timeout总时长是<span class="number">924600</span>ms，表现出来的现象刚好就是重传了<span class="number">15</span>次，超过了timeout值，从而放弃TCP流

<span class="number">2</span>. 如果RTT较大，比如RTO初始值计算得到的是<span class="number">1000</span>ms
   那么根本不需要重传<span class="number">15</span>次，重传总间隔就会超过<span class="number">924600</span>ms。
   比如我测试的一个<span class="variable">RTT=</span><span class="number">400</span>ms的情况，当<span class="variable">tcp_retries2=</span><span class="number">10</span>时，仅重传了<span class="number">3</span>次就放弃了TCP流
</code></pre><hr>
<h3 id="另外几个小问题">另外几个小问题</h3>
<p>理解了Linux决定重传次数的真实机制，就不难回答一下几个问题了  </p>
<pre><code><span class="input"><span class="prompt">&gt;&gt;</span> effective timeout指的是什么？  </span>
<span class="input"><span class="prompt">&lt;&lt; 就是retransmits_timed_out计算得到的timeout值

&gt;&gt;</span> <span class="number">924.6</span>s是怎么算出来的？</span>
&lt;&lt; <span class="number">924.6</span>s = (( <span class="number">2</span> &lt;&lt; <span class="number">9</span>) -<span class="number">1</span>) * <span class="number">200</span>ms + (<span class="number">15</span> - <span class="number">9</span>) * <span class="number">120</span>s
<span class="input"><span class="prompt">
&gt;&gt;</span> 为什么<span class="number">924.6</span>s是lower bound？</span>
&lt;&lt; 重传总间隔必须大于timeout值，即 (tcp_time_stamp - start_ts) &gt;= timeout
<span class="input"><span class="prompt">
&gt;&gt;</span> 那<span class="constant">RTO</span>超时的间隔到底是不是源码注释的<span class="string">"15 is ~13-30min depending on RTO."</span>呢？  </span>
&lt;&lt; 显然不是! 虽然<span class="number">924.6</span>s(<span class="number">15</span>min)是一个lower bound，但是它同时也是一个upper bound!
   怎么理解？举例说明  
        <span class="number">1</span>. 如果某个<span class="constant">RTO</span>值导致，在已经重传了<span class="number">14</span>次后，总重传间隔开销是<span class="number">924</span>s
        那么它还需要重传第<span class="number">15</span>次，即使离<span class="number">924.6</span>s只差<span class="number">0</span>.<span class="number">6</span>s。这就是发挥了lower bound的作用
        <span class="number">2</span>. 如果某个<span class="constant">RTO</span>值导致，在重传了<span class="number">10</span>次后，总重传间隔开销是<span class="number">924</span>s
        重传第<span class="number">11</span>次后，第<span class="number">12</span>次超时触发时计算得到的总间隔变为<span class="number">1044</span>s，超过<span class="number">924.6</span>s
        那么此时会放弃第<span class="number">12</span>次重传，这就是<span class="number">924.6</span>s发挥了upper bound的作用
   总的来说，在<span class="constant">Linux3</span>.<span class="number">10</span>中，如果tcp_retres2设置为<span class="number">15</span>。总重传超时周期应该在如下范围内
        [<span class="number">924.6</span>s, <span class="number">1044.6</span>s)
</code></pre><p>所以综合上述，Linux并不是直接拿tcp_retries1和tcp_retries2来限制重传次数的，而是用计算得到<br>的一个timeout值来判断是否要放弃重传的。真正的重传次数同时与RTT相关。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>在<a href="http://perthcharles.github.io/2015/09/06/wiki-rtt-estimator/" target="_blank" rel="external">RTO的计算方法</a>中，介绍了RFC6298对于RTO的计算和RTO timer的管理算法。<br>但有一个重要的问题RFC没有提到，那就是如果出现了超时重传，那重传多少次可以放弃呢？<br>当然这是一个实现相关的细节，不同的操作系统可能有不同的实现策略。<br>在这篇wiki中，就来介绍一下Linux中是怎么限制超时重传次数的。<br>]]>
    
    </summary>
    
      <category term="rto" scheme="http://perthcharles.github.com/tags/rto/"/>
    
      <category term="tcp" scheme="http://perthcharles.github.com/tags/tcp/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RTO的计算方法(基于RFC6298和Linux 3.10)]]></title>
    <link href="http://perthcharles.github.com/2015/09/06/wiki-rtt-estimator/"/>
    <id>http://perthcharles.github.com/2015/09/06/wiki-rtt-estimator/</id>
    <published>2015-09-06T04:51:17.000Z</published>
    <updated>2015-09-06T10:03:58.000Z</updated>
    <content type="html"><![CDATA[<hr>
<p>RTO的准确计算对于TCP的可靠性传输和性能都具有重要作用。<br>这篇文章首先介绍最新的RFC中对于RTO的计算方法，然后结合Linux 3.10的源码对<br>具体的实现进行分析和理解。  </p>
<a id="more"></a>  

<hr>
<h3 id="RTO计算算法">RTO计算算法</h3>
<pre><code><span class="number">1.1</span>. 在没有任何rtt sample的时候，RTO &lt;- TCP_TIMEOUT_INIT (<span class="number">1</span>s)
   多次重传时同样适用指数回避算法(backoff)增加RTO  

<span class="number">1.2</span>. 获得第一个RTT sample后，
    SRTT &lt;- RTT
    RTTVAR &lt;- RTT/<span class="number">2</span>
    RTO &lt;- SRTT + max(G, K * RTTVAR)
其中K=<span class="number">4</span>, G表示timestamp的粒度(在CONFIG_HZ=<span class="number">1000</span>时，粒度为<span class="number">1</span>ms)

<span class="number">1.3</span>. 后续获得更多RTT sample后，
    RTTVAR &lt;- (<span class="number">1</span> - beta) * RTTVAR + beta * |SRTT - R|
    SRTT &lt;- (<span class="number">1</span> - alpha) * SRTT + alpha * R
其中beta = <span class="number">1</span>/<span class="number">4</span>, alpha = <span class="number">1</span>/<span class="number">8</span>

<span class="number">1.4</span>. Whenever RTO <span class="keyword">is</span> computed, <span class="keyword">if</span> <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">less than</span> <span class="number">1</span> <span class="keyword">second</span>, <span class="keyword">then</span> <span class="keyword">the</span>
   RTO SHOULD be rounder up <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">second</span>.

<span class="number">1.5</span>. A maximum value MAY be placed <span class="function_start"><span class="keyword">on</span></span> RTO provided <span class="keyword">it</span> <span class="keyword">is</span> <span class="keyword">at</span> least <span class="number">60</span> seconds.
</code></pre><p>RTTVAR表示的是平滑过的平均偏差，SRTT表示的平滑过的RTT。这两个值的具体含义会在后面介绍<br>具体实现的时候进一步的解释。<br>以上是计算一个初始RTO值的过程，当连续出现RTO超时后，<br>RTO值会用一个叫做指数回避的策略进行调整，下面来具体介绍。  </p>
<hr>
<h3 id="RTO_timer的管理">RTO timer的管理</h3>
<pre><code><span class="number">2.1</span>. 发送一个带有数据的包后，如果RTO <span class="built_in">timer</span>未启动，启动RTO <span class="built_in">timer</span>  

<span class="number">2.2</span>. 当所有发送的数据都被确认后，关闭RTO <span class="built_in">timer</span>

<span class="number">2.3</span>. 当收到一个ACK确认了新数据后，重新设置RTO时间为当前RTO值

如果RTO超时了
<span class="number">2.4</span>. 重传最早的一个未被确认的数据包(序号最小的，即tp-&gt;snd_una)

<span class="number">2.5</span>. RTO &lt;- RTO * <span class="number">2</span> (<span class="string">"back off the timer"</span>，即指数回避策略)

<span class="number">2.6</span>. 重现设定RTO时间为当前RTO值

<span class="number">2.7</span>. 如果是在等待SYN包的ACK时RTO超时的，在连接建立之后，会将RTO从TCP_TIMEOUT_INIT
   改为TCP_TIMEOUT_FALLBACK(<span class="number">3</span>s)
   就是如果syn包被重传过，则上一节第一步中的RTO则会从<span class="number">1</span>s被重设为<span class="number">3</span>s。
</code></pre><hr>
<h3 id="RFC6298中的其他要点">RFC6298中的其他要点</h3>
<pre><code>Note that <span class="operator">a</span> TCP implementation MAY <span class="built_in">clear</span> SRTT <span class="operator">and</span> RTTVAR <span class="keyword">after</span>
backing off <span class="operator">the</span> timer multiple times <span class="keyword">as</span> <span class="keyword">it</span> is likely that <span class="operator">the</span> current
SRTT <span class="operator">and</span> RTTVAR are bogus <span class="operator">in</span> this situation.  Once SRTT <span class="operator">and</span> RTTVAR
are cleared, they should be initialized <span class="operator">with</span> <span class="operator">the</span> next RTT sample
taken per (<span class="number">1.2</span>) rather than <span class="keyword">using</span> (<span class="number">1.3</span>). 

<span class="number">1.1</span>和<span class="number">2.7</span>是RFC6298与RFC2988的主要不同，RFC6298在Appendix A中详细解释了为什么将INIT_RTO从
<span class="number">3</span>s降到<span class="number">1</span>s。里面有一些dataset的测试数据证明，有兴趣的话可以看一看。  
</code></pre><hr>
<h3 id="Linux实现之RTO计算">Linux实现之RTO计算</h3>
<p>以下开始分析Linux 3.10关于RTO的具体实现，序号与RFC原理中的需要一一对应。<br>首先是RTO计算相关的部分。<br>在理解这部分代码之前，有几个关键变量需要解释一下。<br>tp-&gt;srtt实际上存的是8<em>SRTT，而tp-&gt;rttvar实际上存储的是4</em>RTTVAR。<br>所以在后续代码注释中，也会使用大小写加以区分。使用大写时与RFC定义的变量含义一致。  </p>
<pre><code><span class="number">1.1</span><span class="built_in">.</span> 对应在net/ipv4/tcp<span class="built_in">.</span>c line372 tcp_init_sock()
    <span class="attribute">...</span>
    tcp_init_xmit_timers(sk);       <span class="comment">// 初始化tcp中timer对应的处理函数</span>
    <span class="attribute">...</span>
    icsk<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> TCP_TIMEOUT_INIT;  <span class="comment">// 初始RTO设为1s</span>
    tp<span class="subst">-&gt;</span>mdev <span class="subst">=</span> TCP_TIMEOUT_INIT;        <span class="comment">// 初始medium deviation为1s</span>
    <span class="attribute">...</span>

<span class="number">1.2</span><span class="built_in">.</span> 对应net/ipv4/tcp_input<span class="built_in">.</span>c line639 tcp_rtt_estimator()
    <span class="attribute">...</span>
    <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">!=</span> <span class="number">0</span>) {
        <span class="attribute">...</span>
    } <span class="keyword">else</span> {    <span class="comment">// 第一次获取RTT sample</span>
        tp<span class="subst">-&gt;</span>srtt <span class="subst">=</span> m <span class="subst">&lt;&lt;</span> <span class="number">3</span>;  <span class="comment">// SRTT = RTT, 需要注意的是tp-&gt;srtt存的是8*SRTT</span>

        <span class="comment">/* RTTVAR = RTT/2, 需要注意的是tp-&gt;rttvar存的是4*RTTVAR
         * tcp_rto_min(sk)限制了rttvar的最小值为TCP_RTO_MIN(HZ/5)=200ms */</span>
        tp<span class="subst">-&gt;</span>mdev <span class="subst">=</span> m <span class="subst">&lt;&lt;</span> <span class="number">1</span>;  
        tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tp<span class="subst">-&gt;</span>rttvar <span class="subst">=</span> <span class="keyword">max</span>(tp<span class="subst">-&gt;</span>mdev, tcp_rto_min(sk));

        <span class="comment">/* 记录引起rttvar改变的序列号，用于后续判断是否过了一个RTT，这是常用技巧 */</span>
        tp<span class="subst">-&gt;</span>rtt_seq <span class="subst">=</span> tp<span class="subst">-&gt;</span>snd_nxt;  <span class="comment">// 注意这里是snd_nxt，不是snd_una</span>
    }

<span class="number">1.3</span><span class="built_in">.</span> 对应net/ipv4/tcp_input<span class="built_in">.</span>c line639 tcp_rtt_estimator()
    long m <span class="subst">=</span> mrtt; <span class="comment">// RTT</span>
    <span class="keyword">if</span> (m <span class="subst">==</span> <span class="number">0</span>)
        m <span class="subst">=</span> <span class="number">1</span>;
    <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">!=</span> <span class="number">0</span>) {
        m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">&gt;&gt;</span> <span class="number">3</span>);   <span class="comment">// m = RTT - SRTT</span>
        tp<span class="subst">-&gt;</span>srtt <span class="subst">+=</span> m;          <span class="comment">// 8SRTT = 7 * SRTT + 1 * RTT</span>
        <span class="keyword">if</span> (m <span class="subst">&lt;</span> <span class="number">0</span>) {
            m <span class="subst">=</span> <span class="attribute">-m</span>;             <span class="comment">// m = |RTT - SRTT|</span>
            m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;&gt;</span> <span class="number">2</span>);   <span class="comment">// m = |RTT - SRTT| - RTTVAR</span>
            <span class="keyword">if</span> (m <span class="subst">&gt;</span> <span class="number">0</span>)  
                <span class="comment">/* 此处m&gt;0意味着，RTT与SRTT之间的波动过大，甚至烧过了RTTVAR
                 * 因此选择使用更小的beta值= 1/(4*8)
                 *      执行下面语句后，再执行tp-&gt;mdev += m则会得到如下结果
                 *      RTTVAR = (1-1/32)RTTVAR + |RTT - SRTT|
                 * 这样做的目的是避免突发的RTT变化，对RTTVAR的历史记录造成过大的影响
                 */</span>
                m <span class="subst">&gt;&gt;=</span> <span class="number">3</span>;    <span class="comment">// m = 1/8 (|RTT - SRTT| - RTTVAR)</span>
        } <span class="keyword">else</span> {
            m <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;&gt;</span> <span class="number">2</span>);   <span class="comment">// m = |RTT - SRTT| - RTTVAR</span>
        }
        tp<span class="subst">-&gt;</span>mdev <span class="subst">+=</span> m;              <span class="comment">// 4RTTVAR = 3RTTVAR + |RTT - SRTT|</span>
        <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev <span class="subst">&gt;</span> tp<span class="subst">-&gt;</span>mdev_max) {
            tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tp<span class="subst">-&gt;</span>mdev;
            <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev_max <span class="subst">&gt;</span> tp<span class="subst">-&gt;</span>rttvar)
                <span class="comment">/* 真正的RTTVAR会取一个RTT中最大的RTTVAR，是一种相对保守的策
                 * 因为计算略微偏大的RTO不会引起大问题，
                 * 但如果计算的RTO偏小则可能引起spurious retransmission
                tp-&gt;rttvar = tp-&gt;mdev_max;  
        }
        /* 如果过了一个RTT，则重置mdev_max，并适当调整rttvar */</span>
        <span class="keyword">if</span> (after(tp<span class="subst">-&gt;</span>snd_una, tp<span class="subst">-&gt;</span>rtt_seq)) {  
            <span class="comment">/* 目前看到的代码里面唯一可能导致mdev_max &lt; rttvar的代码就是
             *      tp-&gt;mdev_max = tcp_rto_min(sk);
             */</span>
            <span class="keyword">if</span> (tp<span class="subst">-&gt;</span>mdev_max <span class="subst">&lt;</span> tp<span class="subst">-&gt;</span>rttvar)
                tp<span class="subst">-&gt;</span>rttvar <span class="subst">-=</span> (tp<span class="subst">-&gt;</span>rttvar <span class="subst">-</span> tp<span class="subst">-&gt;</span>mdev_max) <span class="subst">&gt;&gt;</span> <span class="number">2</span>;
            tp<span class="subst">-&gt;</span>rtt_seq <span class="subst">=</span> tp<span class="subst">-&gt;</span>snd_nxt;
            tp<span class="subst">-&gt;</span>mdev_max <span class="subst">=</span> tcp_rto_min(sk);     <span class="comment">// 每过一个RTT重置mdev_max</span>
        }
    }

<span class="number">1.4</span> 根据代码和实际测量值，均未发现Linux有将RTO设置round <span class="keyword">to</span> <span class="number">1</span>s了

<span class="number">1.5</span> net/ipv4/tcp_input<span class="built_in">.</span>c line705 tcp_set_rto()
    <span class="comment">/*1.2和1.3都只是计算srtt和rttvar，并未计算rto */</span>
    inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> __tcp_set_rto(tp);     <span class="comment">// 根据srtt和rttvar计算rto</span>
    tcp_bound_rto(sk);                              <span class="comment">// 限制rto的最大值</span>

其中，__tcp_set_rto(tp)和tcp_bound_rto(sk)的代码如下：
    static <span class="keyword">inline</span> u32 __tcp_set_rto(const struct tcp_sock <span class="subst">*</span>tp)
    {
        <span class="keyword">return</span> (tp<span class="subst">-&gt;</span>srtt <span class="subst">&gt;&gt;</span> <span class="number">3</span>) <span class="subst">+</span> tp<span class="subst">-&gt;</span>rttvar;    <span class="comment">// RTO = SRTT + 4 * RTTVAR</span>
    }

    static <span class="keyword">inline</span> <span class="literal">void</span> tcp_bound_rto(const struct sock <span class="subst">*</span>sk)
    {
        <span class="keyword">if</span> (inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">&gt;</span> TCP_RTO_MAX)
            inet_csk(sk)<span class="subst">-&gt;</span>icsk_rto <span class="subst">=</span> TCP_RTO_MAX;   <span class="comment">// TCP_RTO_MAX = 120s</span>
    }
</code></pre><p>为了更好的理解RTT采样和RTO的整体流程，可以参考<a href="http://blog.csdn.net/zhangskd/article/details/7196707" target="_blank" rel="external">这篇资料</a>，尤其是最后一张函数关系调用图。<br>关键就是理解下面这个函数的调用过程  </p>
<pre><code><span class="keyword">void</span> tcp_valid_rtt_meas(<span class="class"><span class="keyword">struct</span> <span class="title">sock</span> *sk, u32 seq_rtt)
</span>{
    tcp_rtt_estimator(sk, seq_rtt);     <span class="comment">// 根据RTT sample，更新SRTT和RTTVAR</span>
    tcp_set_rto(sk);                    <span class="comment">// 重新计算RTO值</span>
    inet_csk(sk)-&gt;icsk_backoff = <span class="number">0</span>;     <span class="comment">// 将backoff清零</span>
}
</code></pre><hr>
<h3 id="Linux实现之RTO_timer的管理">Linux实现之RTO timer的管理</h3>
<pre><code><span class="number">2.1</span> net/ipv4/tcp_output.c line72 tcp_event_new_data_sent()
<span class="keyword">...</span>
unsigned int prior_packets = tp-&gt;packets_out;
<span class="keyword">...</span>
tp-&gt;packets_out += tcp_skb_pcount(skb); // 更新已经发出未被确认的数据包数目
<span class="keyword">if</span> (!prior_packets      // 如果prior_packets=<span class="number">0</span>，表示之前未发送过数据，因此需要启动timer
    ||<span class="keyword">...</span>)
    tcp_rearm_rto(sk);  // 启动RTO timer

<span class="number">2.2</span> net/ipv4/tcp_input.c line2926 tcp_rearm_rto()
<span class="keyword">...</span>
/* 如果packet_out=<span class="number">0</span>，则停掉RTO timer */
<span class="keyword">if</span> (!tp-&gt;packets_out) {
    inet_csk_clear_xmit_timer(sk, ICSK_TIME_RETRANS);   
}

<span class="number">2.3</span> net/ipv4/tcp_input.c line3105 tcp_clean_rtx_queue()
<span class="keyword">...</span>
<span class="keyword">if</span> (flag &amp; FLA_ACKED) {
    <span class="keyword">...</span>
    tcp_ack_update_rtt(sk, flag, seq_rtt);  // 得到一个RTT sample，更新RTO
    tcp_rearm_rto(sk);                      // 重设RTO timer
    <span class="keyword">...</span>
}

<span class="number">2.4</span>+<span class="number">2.5</span>+<span class="number">2.6</span> net/ipv4/tcp_timer.c line340 tcp_retransmit_timer()
<span class="keyword">...</span>
tcp_enter_loss(sk, <span class="number">0</span>);  // 进入RTO超时重传阶段
<span class="keyword">if</span> (tcp_retransmit_skb(sk, tcp_write_queue_head(sk)) &gt; <span class="number">0</span>) // 重传第一个未确认的数据包
<span class="keyword">...</span>

/* 如果这是一个thin的TCP流，则不适用backoff机制 
 * 什么是thin tcp呢？就是网络中in_flight的数据包很少的流
 * 具体请看tcp_stream_is_thin(tp)
 */
<span class="keyword">if</span> (STREAM IS THIN ?) { 
    icsk-&gt;icsk_backoff = <span class="number">0</span>;
    icsk-&gt;icsk_rto = min(__tcp_set_rto(tp), TCP_RTO_MAX);
} <span class="keyword">else</span> {
    /* Use normal (exponential) backoff */  
    icsk-&gt;icsk_rto = min(icsk-&gt;icsk_rto &lt;&lt; <span class="number">1</span>, TCP_RTO_MAX); // 步骤<span class="number">2.5</span>
}
/* 步骤<span class="number">2.6</span> 重设RTO timer */
inet_csk_reset_xmit_timer(sk, ICSK_TIME_RETRANS, icsk-&gt;icsk_rto, TCP_RTO_MAX);

<span class="number">2.7</span> net/ipv4/tcp_metrics.c line441 tcp_init_metrics()
/* tcp_init_metrics是在TCP建立连接之后进行的初始化动作
 * 一个明显的例子： tcp_finish_connect() =&gt; tcp_init_metrics()
 */
<span class="keyword">...</span>
<span class="keyword">if</span> (tp-&gt;srtt == <span class="number">0</span>) {
    /* 如果在3WHS阶段没有获得srtt，基本就意味着发生了重传 */
    tp-&gt;mdev = tp-&gt;mdev_max = tp-&gt;rttvar = TCP_TIMEOUT_FALLBACK;
    inet_csk(sk)-&gt;icsk_rto = TCP_TIMEOUT_FALLBACK;
}  
</code></pre><p>至此，基本上把Linux 3.10中关于RTO的基本逻辑弄清楚了。RFC6298中proposed的算法的<br>主要步骤也找到了对应的代码实现位置。   </p>
<hr>
<h3 id="参考资料">参考资料</h3>
<p><a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="external">RFC 6298</a><br><a href="http://blog.csdn.net/zhangskd/article/details/7196707" target="_blank" rel="external">TCP中RTT的测量和RTO的计算</a>  </p>
]]></content>
    <summary type="html">
    <![CDATA[<hr>
<p>RTO的准确计算对于TCP的可靠性传输和性能都具有重要作用。<br>这篇文章首先介绍最新的RFC中对于RTO的计算方法，然后结合Linux 3.10的源码对<br>具体的实现进行分析和理解。  </p>
]]>
    
    </summary>
    
      <category term="rtt" scheme="http://perthcharles.github.com/tags/rtt/"/>
    
      <category term="rto" scheme="http://perthcharles.github.com/tags/rto/"/>
    
      <category term="rfc6298" scheme="http://perthcharles.github.com/tags/rfc6298/"/>
    
      <category term="wiki-network" scheme="http://perthcharles.github.com/categories/wiki-network/"/>
    
  </entry>
  
</feed>
